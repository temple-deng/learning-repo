# HTTP 条件请求

## 主要原则

HTTP 条件请求会根据不同的首部值执行不同的操作。这些首部会定义一个前提，请求的结果会根据前提满足与否而返回不同的结果。  

这种差异行为是由请求使用的方法及设置的前提的首部的定义的：  

+ 对于安全的方法来说，例如 GET，条件请求可能会在有必要的情况下返回文档。
+ 对于不安全的方法来说，例如 PUT，上传文件，只有在之前上传的内容与当前内容是处于同一服务器上时，条件请求才会上传内容。  

## 验证器

所有的条件首部都会检查是否服务器上资源匹配给定的版本，所以一般来说，条件首部都会指定一个资源的版本。这些版本值就被叫做验证器，分为下面两种类型：  

+ 文档上次的修改日期, `last-modified`。
+ 一个不透明的字符串，用来唯一识别一个版本，`entity tag` or `etag`。  

比较同于资源的版本时会有些复杂：根据上下文，有两种类型的质量检测：  

+ 当期望每个字节都相同时，使用强验证 `Strong validation`。例如当恢复下载时。
+ 当用户代理只需要确认是否两份资源有相同的内容时使用弱验证 `Weak validation`。  

验证的类型是与使用的验证器相互独立的。两种类型的验证器都支持强弱验证。HTTP 默认使用强验证。  

相对来说 `Last-Modified` 使用一个唯一的标识符来实现强验证是比较困难的。通常来说使用资源
的MD5 值在 `ETag` 中来实现强验证。  

弱验证不考虑两份资源是否是相同的，只考虑两份资源是否可以认作是相等的。    

## 条件首部

+ If-Match: 如果资源的ETag与这个首部列表中的某一个相等就是匹配成功。默认情况下，除非 etag 前缀了 `'W/'`,否则都是强验证。  

+ If-None-Match: 如果资源的ETag与这个首部列表中的吗每一个都不相等就是匹配成功。默认情况下，除非 etag 前缀了 `'W/'`,否则都是强验证。   

+ If-Modified-Since: 如果资源的 Last-Modified 比首部的时间更接近限制就是匹配成功。  

+ If-Unmodified-Since: 如果资源的 Last-Modified 比首部的时间更老限制就是匹配成功。

+ If-Range: 类似于 If-Match, If-Unmodified-Since。但是只有一个 etag 或者 date。  

## Cache-Control

注意，服务器和客户端都可以用 `Cache-Control` 来说明新鲜度。所有下面很多指令都有两个版本。  

| 指令 | 报文类型 | 描述 |
| :------------- | :------------- | :------------- |
| no-cache | 请求 | 在重新向服务器验证之前，不要返回文档的缓存副本 |
| no-store | 请求 | 不要反悔文档的缓存副本。不要保存服务器的响应。 |
| max-age | 请求 | 缓存中的文档不能超过指定的试用期。 |
| max-stale | 请求 | 文档允许过期（根据服务器提供的过期信息计算），但不能超过指令中指定的过期值 |
| min-fresh | 请求 | 文档的使用期不能小于这个指定的时间与它的当前存活时间之和。换句话说，响应必须至少在这段时间内保持新鲜。（没懂这个） |
| no-transform | 请求 | 文档在发送之前不允许被转换 |
| only-if-cached | 请求 | 只有文档在缓存中才发送，不要联系原始服务器 |
| public | 响应 | 响应可以被任何服务器缓存 |
| private | 响应 | 响应可以被缓存，但只能被单个客户端访问 |
| no-cache | 响应 | 如果该指令伴随一个首部列表的话，那么内容可以被缓存并提供给客户端，但必须先删除所列出的首部。如果没有指定首部，缓存中的副本在没有重新向服务器验证之前不能提供给客户端 |
| no-store | 响应 | 响应不允许被缓存 |
| no-transform | 响应 |  响应在提供给客户端之前不能做任何形式的修改 |
| must-revalidate | 响应 | 响应在提供给客户端之前必须重新向服务器验证 |
| proxy-revalidate | 响应 | 共享的缓存在提供给客户端之前必须向原始的服务器验证。私有的缓存可以忽略这条指令。|
| max-age | 响应 | 指定文档可以被缓存以及新鲜度的最长时间 |
| s-max-age | 响应 | 指定文档作为共享缓存的最长使用时间。私有的缓存可以忽略本指令。 |
