# 权威指南

标签（空格分隔）： 未分类

---
    1.类型、值和变量
    2.表达式和运算符
    3.数组
    4.对象
    5.Window对象
	6.客户端JavaScript
	7.脚本化文档
---

### 1.类型、值和变量
以数字表示的字符串可以直接转换为数字，也允许在开头和结尾添加空格，但在开始和结尾处任意非空格字符都不会被当成数字直接量的一部分，进而造成字符串转换为数字的结果为NaN。（按理说在哪部分有了非空格字符都会出错吧。。。）

不通过new操作符调用 Number()、String()、Boolean()函数时只是简单的作为类型转换函数，但使用了new操作符便会生成包装对象。
```
    var S = new String('123');
    typeof S; //  "object"
    S == '123';   //true
    S === '123';  //false
```

对象到字符串的转换：
  1.如果有toString()方法，就调用方法，如果返回原始值，将原始值转换为字符串，并返回这个字符串结果。
  2.如果没有这个方法或者不返回原始值，就调用valueOf()方法，如果存在就调用，返回原始值就转换为字符串返回。
  3.抛出类型错误异常。
  
对象到数字的转换：类似于到字符串的转换，只是先调用valueOf方法再调用toString()方法，还有就是把原始值转换为数字而不是字符串。



### 2.表达式和运算符

原始表达式，即简单表达式有3种，变量，关键字(true,null等)、直接量。

in运算符希望左操作数是一个字符串或可以转换为字符串，右操作数是一个对象。（当右边是数组的时候，会有奇怪的表现，针对索引数组，左边的字符串被转换为对应的索引）
```
    var arr=[1,2,'3'];
    '3' in arr; //false
    3 in arr;   //false
```
当左操作数为假值时，整个表达式结果也是假值，因此运算符简单地返回左操作数的值。如果左操作数为真值时，‘&&’将计算右操作数的值并将其返回作为整个表达式的计算结果。

    
### 3、数组
所有的索引都是属性名，但只有在0~2的32次方-2 之间的整数属性名才是索引。所有的数组都是对象，可以任意创建任意名称的属性。但如果使用的属性是数组的索引，数组的特殊行为就是将根据需要更新它们的length值(可能还会填充undefin的属性值)。
```javascript
    Array.concat()   //衔接数组，得到新数组并返回，如果参数本身是一个一维数组，会将元素衔接进去。
                     //但是并不能递归扁平化一维以上的数组。
    var arr=[1,2];
    var a1=arr.concat([3,4],[[5,6],[7,8]]);  //a1=[1,2,3,4,[5,6],[7,8]];
    
    Array.every()    //测试断言函数是否对每个元素为真。如果又一次遍历返回false，会提前终止遍历并立刻返回false。 空数组会返回true。
    
    Array.filter()    //返回通过断言的数组元素组成的新数组。包含那些让断言函数返回真值的数组元素。
    
    Array.forEach()   //为每个元素调用函数，无返回值
    
    Array.map()       //返回一个新数组，由传入函数计算出的元素组成。 长度和原数组长度一样。
                      //filter会跳过稀疏数组空缺元素，而map不会。
    //forEach、map、filter、every、some 都接受可选的第二个参数，可以修改第一个函数参数体内的this指向。
    
    Array.join()     //省略参数时使用默认的逗号，传入" "和""不会使用默认的逗号。
    var arr = [1,2,3];
    arr.join();  // "1,2,3";
    arr.join(" ")  //"1 2 3";
    arr.join("")   //"123"
    
    Array.slice(start, end)         //返回从start到end之间的数组片段，包括start处的元素，但不包括end处的元素
    
    Array.splice(start, deleteCount, value,...)  //插入、删除或替换数组元素
    //deleteCount 要删除的元素个数，从start开始，并包含start处的元素，如果指定为0，表示插入，不用删除。
    //value，... 要插入的元素值，在start元素前面开始插入，注意这里不能扁平化数组。
    //如果删除了元素，就返回删除元素组成的新数组
    
    indexOf, lastIndexOf,pop, push, shift, unshift, reduce, reduceRight, reverse,sort, some, toString,
```
<br>
<br>
### 4、对象
**检测属性**
  in运算符、对象的hasOwnProperty()方法和对象的 propertyIsEnumerable()方法。
  in运算符， 对象的自有或者继承属性包含左边的属性返回true。
  hasOwnProperty()， 自有属性返回true，继承返回false
  propertyIsEnumerable() 自有且可枚举的属性返回true。

**枚举属性**
 for/in循环、Object.keys()、Object.getOwnPropertyNames()
 for/in循环可以遍历对象中所有可枚举的属性（包括自有的和继承的）（注意和in运算符的区别，这里只有可枚举的才能遍历，但in可以找出不可枚举的）
 Object.keys()返回一个数组，由对象可枚举的自有属性的名称组成。
 Object.getOwnPropertyNames()只返回自有属性的名称，不仅仅是可枚举的。
 

### 5.   Window对象

**Location对象**
window对象的location属性和document的location属性都引用了Location对象。但是`window.location=== Location // false`(Location 是一个构造函数可能)（等等，Location对象好像其实是location，这就能说通了`window.location===location`）；
`location === window.location === document.location`
```
Location的属性
http://www.oreilly.com:1234/catalog/search.html?q=JavaScript&m=10#results
string hash             #results
string host             http://www.oreilly.com:1234
string hostname         http://www.oreilly.com
string href             完整URL文本，赋值将跳转到新页面
string pathname         /catalog/search.html
string port             1234 注意是string不是number
string protocol         http: 包括冒号
string search           ?q=JavaScript&m=10  包括开头的问号

3个方法
assign(string url) 
replace(string url) 
加载指定的url的内容，不同的是replace会在历史中替换当前文档，所以后退按钮回不去了。url可以是相对路径
reload()重新加载当前页面
```
<br>
**History对象**
```
readonly long length 历史条数
back()      //回退一步
forward()   //前进一步
go(long)
接受整数参数，前进或后退几步，非整数也能转换为整数。如果参数为0或者没有参数，就重新加载当前文档（不能转化为整数的参数好像也是这个效果）
```

**window.open方法**
```
    Window open([string url], [string target], [string features], [string replace])
    url: 打开窗口的url地址，接受相对地址，没有指定就使用“about: blank”；
    target： 指定新打开窗口的名字，没有指定就使用“_blank”，如果target为"_blank"或不存在指定名字的已有窗口，就创建新窗口，否则将用新url的文档替换已有名字窗口文档的内容。
    features：打开窗口的特性设置，忽略。
    replace：指定是否替换历史记录。true会直接替换，false或未指定，会添加一条记录。（具体实践时无论true还是false都会新加一条历史记录，不清楚什么情况）
    返回值就是新打开页面window对象的引用，可以通过这个对象操作新窗口，但要注意同源策略的限制。
    在新打开的窗口中，opener属性引用的是打开它的窗口。
    注意这个方法可能被禁用
    window.close()关闭窗口
    注意，即使一个窗口关闭了，代表它的Window对象依然存在，有个值为true的closed属性。
```
在窗体中parent引用的是父窗口的window对象，top是祖先window对象。在最外层的window对象中`parent === top === self`

<br>
### 6.客户端JavaScript
客户端Javascipt执行时间线
1.Web浏览器创建Document对象，开始解析页面，添加Dom节点。document.readystate属性值为"loading".
2.当解析器遇到没有defer和async属性的script标签元素时，开始下载（如果需要）并同步执行，此时解析器会暂停解析HTML文档。
3.当遇到了async属性的script标签元素，会异步下载脚本，此时解析器可以继续解析文档，但脚本下载完后会立刻执行，此时解析器会暂停
4.文档解析完成，document.readystate属性变成"interactive"
5.所有defer属性脚本，按在文档里出现的顺序执行。异步脚本也可能会在这个时间执行。
6.浏览器在Document对象上触发DOMContentLoaded事件。注意，这是可能还有异步脚本没有执行完成。
7.文档完全解析完成，但可能还在等待其他内容载入，如图片。当所有内容载入完成，异步脚本完成载入和执行。document.readystate属性为"complete"，浏览器触发load事件
<br>

### 7.脚本化文档
Doucment对象、Element对象和文档中表示文本的Text对象都是Node对象，定义了以下属性。
```
    parentNode 父节点， Document对象是null
    childNodes   子节点的实时表示。（NodeList对象）   document的第一个子节点是<!DOCTYPE html>, 第二个是html文档
    firstChild, lastChild 没有子节点为null
    nextSibling， previousSibling
    nodeType 
    nodeValue Text或Comment节点的文本内容
    nodeName 元素标签名，大写（document是特例）
    这些API对文档文本变化敏感，少用为好。
```





### 核心API
**Date**
##### *构造函数*
 new Date()
 new Date(milliseconds)
 new Date(datestring)
 new Date(year, month, day, hours, minutes, seconds, ms);

不带参数时，根据当前日期和时间创建一个Date对象。传入一个数字参数，返回一个相对于UNIX时间戳的Date对象，传入字符串参数，被当做日期的字符串表示形式，格式为Date.parse()可接受的格式。其他情况下，应传入2~7个数字参数，除了前两个，其余参数都是可选的。 
也可以不带new操作符调用，这是将忽略所有参数，返回当前日期和时间的一个字符串表示。

##### *静态方法*
Date.now() 返回当前时间，自纪元开始后的毫秒数，
Date.parse()  解析一个日期及时间的字符串表示，返回表示该日期的内部毫秒数。
Date.UTC()  返回指定的UTC日期及时间的毫秒表示

##### *实例方法*
```javascript
	Date.getDate()   月份中的日期值 1~31
	Date.getDay()    一周中的日期值 0~6(星期一)
	Date.getFullYear()   年份    4位数字
	Date.getHours()     小时 0~23
	Date.getMilliseconds()  毫秒
	Date.getMinutes()   分钟 0~59
	Date.getMonth()     月份 0~11
	Date.getSeconds()  秒钟 0~59
	Date.getTime()     毫秒形式返回
	Date.getTimezoneOffset()    取得时间差  GMT时间与本地时间的差，分钟表示
	Date.getYear()     年份值   年份值减去1900
```

**String**
```javascript
    charAt(n)   取得第n个字符  如果n不在 0~length-1 之间返回空串
    charCodeAt(n)  取得第n个字符编码     如果n不在 0~length-1 之间返回NaN
    concat(value,....)   字符串连接
    indexOf(substring, start)  搜索一个字符串
    slice(start, end)提取子串
    split(delimiter, limit)    将字符串切割为字符数组,limit指定数组的最大长度。所有分隔符的前方和后方断开。如果匹配开头内容，第一个是空串，最后一个也可能是。如果没有分隔符，就不切分，返回只有一个元素的数组。如果分隔符是空串，则在每个字符之间断开，返回的数组和字符串有一样的长度。（这对于前面的内容来说是个特例。）
    substr(start, length) 提取子串
    substring(from, to)
    trim() 去除开头结尾的空白字符
``` 