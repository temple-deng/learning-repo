# 权威指南

标签（空格分隔）： 未分类

---
    1.类型、值和变量
    2.表达式和运算符
    3.数组
    4.对象
    5.Window对象
---

### 1.类型、值和变量
以数字表示的字符串可以直接转换为数字，也允许在开头和结尾添加空格，但在开始和结尾处任意非空格字符都不会被当成数字直接量的一部分，进而造成字符串转换为数字的结果为NaN。（按理说在哪部分有了非空格字符都会出错吧。。。）

不通过new操作符调用 Number()、String()、Boolean()函数时只是简单的作为类型转换函数，但使用了new操作符便会生成包装对象。
```
    var S = new String('123');
    typeof S; //  "object"
    S == '123';   //true
    S === '123';  //false
```

对象到字符串的转换：
  1.如果有toString()方法，就调用方法，如果返回原始值，将原始值转换为字符串，并返回这个字符串结果。
  2.如果没有这个方法或者不返回原始值，就调用valueOf()方法，如果存在就调用，返回原始值就转换为字符串返回。
  3.抛出类型错误异常。
  
对象到数字的转换：类似于到字符串的转换，只是先调用valueOf方法再调用toString()方法，还有就是把原始值转换为数字而不是字符串。



### 2.表达式和运算符

原始表达式，即简单表达式有3种，变量，关键字(true,null等)、直接量。

in运算符希望左操作数是一个字符串或可以转换为字符串，右操作数是一个对象。（当右边是数组的时候，会有奇怪的表现，针对索引数组，左边的字符串被转换为对应的索引）
```
    var arr=[1,2,'3'];
    '3' in arr; //false
    3 in arr;   //false
```
当左操作数为假值时，整个表达式结果也是假值，因此运算符简单地返回左操作数的值。如果左操作数为真值时，‘&&’将计算右操作数的值并将其返回作为整个表达式的计算结果。

    
### 3、数组
所有的索引都是属性名，但只有在0~2的32次方-2 之间的整数属性名才是索引。所有的数组都是对象，可以任意创建任意名称的属性。但如果使用的属性是数组的索引，数组的特殊行为就是将根据需要更新它们的length值(可能还会填充undefin的属性值)。
```javascript
    Array.concat()   //衔接数组，得到新数组并返回，如果参数本身是一个一维数组，会将元素衔接进去。
                     //但是并不能递归扁平化一维以上的数组。
    var arr=[1,2];
    var a1=arr.concat([3,4],[[5,6],[7,8]]);  //a1=[1,2,3,4,[5,6],[7,8]];
    
    Array.every()    //测试断言函数是否对每个元素为真。如果又一次遍历返回false，会提前终止遍历并立刻返回false。 空数组会返回true。
    
    Array.filter()    //返回通过断言的数组元素组成的新数组。包含那些让断言函数返回真值的数组元素。
    
    Array.forEach()   //为每个元素调用函数，无返回值
    
    Array.map()       //返回一个新数组，由传入函数计算出的元素组成。 长度和原数组长度一样。
                      //filter会跳过稀疏数组空缺元素，而map不会。
    //forEach、map、filter、every、some 都接受可选的第二个参数，可以修改第一个函数参数体内的this指向。
    
    Array.join()     //省略参数时使用默认的逗号，传入" "和""不会使用默认的逗号。
    var arr = [1,2,3];
    arr.join();  // "1,2,3";
    arr.join(" ")  //"1 2 3";
    arr.join("")   //"123"
    
    Array.slice(start, end)         //返回从start到end之间的数组片段，包括start处的元素，但不包括end处的元素
    
    Array.splice(start, deleteCount, value,...)  //插入、删除或替换数组元素
    //deleteCount 要删除的元素个数，从start开始，并包含start处的元素，如果指定为0，表示插入，不用删除。
    //value，... 要插入的元素值，在start元素前面开始插入，注意这里不能扁平化数组。
    //如果删除了元素，就返回删除元素组成的新数组
    
    indexOf, lastIndexOf,pop, push, shift, unshift, reduce, reduceRight, reverse,sort, some, toString,
```
<br>
<br>
### 4、对象
**检测属性**
  in运算符、对象的hasOwnProperty()方法和对象的 propertyIsEnumerable()方法。
  in运算符， 对象的自有或者继承属性包含左边的属性返回true。
  hasOwnProperty()， 自有属性返回true，继承返回false
  propertyIsEnumerable() 自有且可枚举的属性返回true。

**枚举属性**
 for/in循环、Object.keys()、Object.getOwnPropertyNames()
 for/in循环可以遍历对象中所有可枚举的属性（包括自有的和继承的）（注意和in运算符的区别，这里只有可枚举的才能遍历，但in可以找出不可枚举的）
 Object.keys()返回一个数组，由对象可枚举的自有属性的名称组成。
 Object.getOwnPropertyNames()只返回自有属性的名称，不仅仅是可枚举的。
 

### 5.   Window对象

**Location对象**
window对象的location属性和document的location属性都引用了Location对象。但是`window.location=== Location // false`(Location 是一个构造函数可能)（等等，Location对象好像其实是location，这就能说通了`window.location===location`）；
`location === window.location === document.location`
```
Location的属性
http://www.oreilly.com:1234/catalog/search.html?q=JavaScript&m=10#results
string hash             #results
string host             http://www.oreilly.com:1234
string hostname         http://www.oreilly.com
string href             完整URL文本，赋值将跳转到新页面
string pathname         /catalog/search.html
string port             1234 注意是string不是number
string protocol         http: 包括冒号
string search           ?q=JavaScript&m=10  包括开头的问号

3个方法
assign(string url) 
replace(string url) 
加载指定的url的内容，不同的是replace会在历史中替换当前文档，所以后退按钮回不去了。url可以是相对路径
reload()重新加载当前页面
```
<br>
**History对象**
```
readonly long length 历史条数
back()      //回退一步
forward()   //前进一步
go(long)
接受整数参数，前进或后退几步，非整数也能转换为整数。如果参数为0或者没有参数，就重新加载当前文档（不能转化为整数的参数好像也是这个效果）
```

**window.open方法**
```
    Window open([string url], [string target], [string features], [string replace])
    url: 打开窗口的url地址，接受相对地址，没有指定就使用“about: blank”；
    target： 指定新打开窗口的名字，没有指定就使用“_blank”，如果target为"_blank"或不存在指定名字的已有窗口，就创建新窗口，否则将用新url的文档替换已有名字窗口文档的内容。
    features：打开窗口的特性设置，忽略。
    replace：指定是否替换历史记录。true会直接替换，false或未指定，会添加一条记录。（具体实践时无论true还是false都会新加一条历史记录，不清楚什么情况）
    返回值就是新打开页面window对象的引用，可以通过这个对象操作新窗口，但要注意同源策略的限制。
    在新打开的窗口中，opener属性引用的是打开它的窗口。
    注意这个方法可能被禁用
    window.close()关闭窗口
    注意，即使一个窗口关闭了，代表它的Window对象依然存在，有个值为true的closed属性。
```
在窗体中parent引用的是父窗口的window对象，top是祖先window对象。在最外层的window对象中`parent === top === self`