# 第 15 章 位操作

<!-- TOC -->

- [第 15 章 位操作](#第-15-章-位操作)
  - [15.3 C 按位运算符](#153-c-按位运算符)
    - [15.3.1 按位逻辑运算符](#1531-按位逻辑运算符)
    - [15.3.2 移位运算符](#1532-移位运算符)
  - [15.4 位字段](#154-位字段)
  - [15.5 对齐特型（C11）](#155-对齐特型c11)

<!-- /TOC -->

## 15.3 C 按位运算符

C 提供按位逻辑运算符和移位运算符。    

### 15.3.1 按位逻辑运算符

4 个按位逻辑运算符都用于整型数据。    

取反：`~`。   

```c
~(10011010)
01100101
```    

按位与：`&`。   

```c
(10010011)&(00111101)
00010001
```    

按位或：`|`。    

```c
(10010011)&(00111101)
10111111
```   

按位异或：`^`。    

```c
(10010011)^(00111101)
10101110
```    

### 15.3.2 移位运算符

左移：`<<`    

左侧运算对象移出左末端位的值丢失，⽤0填充空出的位置。    

```c
int stonk = 1;
int onkoo = stonk << 2;
```

右移：`>>`    

将其左侧运算对象每⼀位的值向右移动其右侧运算对象指定的位数。左侧运算对象移出右末端位的值丢。对于
⽆符号类型，⽤ 0 填充空出的位置；对于有符号类型，其结果取决于机器。空出的位置可⽤0填充，或者⽤
符号位（即，最左端的位）的副本填充。    

## 15.4 位字段

操控位的第2种方法是位字段。位字段是一个 `signed int` 或 `unsigned int` 类型变量中的一组相邻
的位。位字段通过一个结构声明来建立，该结构声明为每个字段提供标签，并确定该字段的宽度。   

```c
struct {
  unsigned int autfd:1;
  unsigned int bldfc:1;
  unsigned int undln:1;
  unsigned int itals:1;
} prnt;

prnt.itals = 0;
prnt.undln = 1;
```    

有时，某些设置也有多个选择，因此需要多位来表⽰。    

```c
struct {
  unsigned int code1:2;
  unsigned int code2:2;
  unsigned int code3:8;
} prcode;

prcode.code1 = 0;
prcode.code2 = 3;
prcode.code3 = 102;
```    

## 15.5 对齐特型（C11）

`_Alignof` 运算符给出⼀个类型的对齐要求，在关键字 `_Alignof` 后⾯的圆括号中写上类型名即可：   

```c
size_t d_align = _Alignof(float);
```    

假设 `d_align` 的值是4，意思是float类型对象的对齐要求是4。也就是说，4是储存该类型值相邻地址
的字节数。⼀般⽽⾔，对齐值都应该是2的⾮负整数次幂。较⼤的对齐值被称为stricter或stronger，
较⼩的对齐值被称为weaker。   

可以使⽤ `_Alignas` 说明符指定⼀个变量或类型的对齐值。但是，不应该要求该值⼩于基本对齐值。例如，
如果float类型的对齐要求是4，不要请求其对齐值是1或2。该说明符⽤作声明的⼀部分，说明符后⾯的圆
括号内包含对齐值或类型：    

```c
_Alignas(double) char c1;
_Alignas(8) char c2;
```   