# 第 4 章 字符串和格式化输入/输出



## 4.1 前导程序

```c
#include <stdio.h>
#include <string.h>    // 提供 strlen() 函数的原型

#define DENSITY 62.4

int main(void) {
  float weight, volume;
  int size, letters;
  char name[40];    // name 是一个可容纳 40 个字符的数组
  printf("Hi!What's your first name?\n");
  scanf("%s", name);
  printf("%s, what's your weight in pounds?\n", name);
  scanf("%f", &weight);
  size = sizeof name;
  letters = strlen(name);
  volume = weight / DENSITY;
  printf("Well, %s, your volume is %2.2f cubic feet.\n", name, volume);
  printf("Also, your first name has %d letters,\n", letters);
  printf("and we have %d bytes to store it\n", size);
  return 0;
}
```    

## 4.2 字符串简介

双引号用来告知编译器它括起来的是字符串，单引号用来告知是个字符。   

### 4.2.1 char 类型数组和 null 字符

C语⾔没有专门⽤于储存字符串的变量类型，字符串都被储存在 char 类型的数组中。    

注意数组末尾的字符 \0。这是空字符 null，C语言用它标记字符串的结束。空字符不是数字0，它是非打印
字符，其 ASCII 码值是（或等价于）0。C中的字符串一定以空字符结束，这意味着数组的容量必须至少比
待存储字符串中的字符数多 1。    

### 4.2.2 使用字符串

```c
#include <stdio.h>

#define PRAISE "You are an extraordinary being"

int main(void) {
  char name[40];
  printf("What's your name?\n");
  scanf("%s", name);
  printf("Hello, %s.%s\n", name, PRAISE);
  return 0;
}
```    

%s 告诉 `printf()` 打印一个字符串。   

我们不用把空字符主动放入字符串末尾，`scanf()` 在读取输入时就已完成这项工作。也不用在字符串常量
PRAISE 末尾添加空字符。编译器会在末尾加上空字符。   

注意，`scanf()` 在遇到第 1 个空白（空格、制表符或换行符）时就不再读取输入。⼀般⽽⾔，根据 %s
转换说明，`scanf()` 只会读取字符串中的⼀个单词，⽽不是⼀整句。   

字符串常量 "x" 和字符常量 'x' 不同。区别之一在于 'x' 是基本类型 char，而 "x" 是派生类型 char
数组；区别之二是 "x" 实际上由两个字符组成：'x' 和空字符\n。    

### 4.2.3 strlen() 函数

上面的 sizeof 运算符，以字节为单位给出对象的大小。`strlen()` 函数给出字符串中的字符长度。  

```c
#include <stdio.h>
#include <string.h>

#define PRAISE "You are an extraordinary being."

int main(void) {
  char name[40];
  printf("What's your name?\n");
  scanf("%s", name);
  printf("Hello, %s.%s\n", name, PRAISE);
  printf("Your name of %zd letters occupies %zd memory cells.\n", strlen(name), sizeof name);
  printf("The phrase of praise has %zd letters", strlen(PRAISE));
  printf("and occupies %zd memory cells.\n", sizeof PRAISE);
  return 0;
}
```   

一般而言，C 把函数库中相关的函数归为一类，并为每类函数提供了一个头文件。   

输出：   

```
What's your name?
dengbo
Hello, dengbo.You are an extraordinary being.
Your name of 6 letters occupies 40 memory cells.
The phrase of praise has 31 lettersand occupies 32 memory cells.
```    

对于 sizeof 的括号问题，如果运算对象是类型时，圆括号必不可少，但是对于特定量，可有可无。尽管如此，
还是建议所有情况下都使⽤圆括号。    

## 4.3 常量和 C 预处理器

C 预处理器除了可以使用 #include 包含其他文件的信息，还可以用来定义常量。   

```c
#define TAXRATE 0.015
```   

编译程序时，程序中所有的 TAXRATE 都会被替换成 0.015。这一过程被称为编译时替换。在运行程序时，
程序中所有的替换均已完成。通常，这样定义的常量也称明示常量。   

⼤写常量只是为了提⾼程序的可读性，即使全⽤⼩写来表⽰符号常量，程序也能照常运⾏。另外，还有⼀个不
常⽤的命名约定，即在名称前带 c_ 或 k_ 前缀来表⽰常量（如，c_level或k_line）。   

\#define指令还可定义字符和字符串常量。前者使⽤单引号，后者使⽤双引号。   

### 4.3.1 const 限定符

C90 新增了 const 关键字，用于限定一个变量为只读。   

```c
const int MONTHS = 12;
```    

这里仔细想一下上面的常量和这里 const 修饰后变量的区别。首先上面那种预定义的，叫符号常量，其实本质
上就是把一个字面常量起了一个名字，从而增加了语义，而且在编译预处理的时候就会把这些符号常量替换
为真正的字面常量。    

而这里其实是将一个变量声明为只读的。   

### 4.3.2 明示常量

C头⽂件 limits.h 和 float.h 分别提供了与整数类型和浮点类型⼤⼩限制相关的详细信息。每个头⽂件
都定义了⼀系列供实现使⽤的明⽰常量。下面列出了一部分：   

- CHAR_BIT: char类型的位数
- CHAR_MAX: char类型的最大值
- CHAR_MIN
- SCHAR_MAX: signed char 类型的最大值
- SCHAR_MIN: signed char 类型的最小值
- UCHAR_MAX: unsigned char 类型的最大值
- SHRT_MAX: short 类型的最大值
- SHRT_MIN
- USHRT_MAX: unsigned short 类型的最大值
- INT_MAX
- INT_MIN
- UINT_MAX
- LONG_MAX
- LONG_MIN
- ULONG_MAX
- LLONG_MAX
- LLONG_MIN
- ULLONG_MAX

类似地，float.h 头⽂件中也定义⼀些明⽰常量，如FLT_DIG和DBL_DIG，分别表⽰float类型和double
类型的有效数字位数。   

## 4.4 printf() 和 scanf()

### 4.4.1 printf() 函数

请求 `printf()` 函数打印数据的指令要与待打印数据的类型相匹配。例如，打印整数时使⽤%d，打印字符
时使⽤%c。这些符号被称为转换说明（conversion specification），它们指定了如何把数据转换成可
显⽰的形式。     

- %a: 浮点数、十六进制数和 p 计数法
- %A: 同上
- %c: 单个字符
- %d: 有符号十进制整数
- %e: 浮点数，e计数法
- %E: 同上
- %f: 浮点数，十进制计数法
- %g: 根据值的不同，自动选择 %f 或者 %e
- %G: 同上，%E
- %i: 有符号十进制整数（与 %d 相同）
- %o: 无符号八进制整数
- %p: 指针
- %s: 字符串
- %u: 无符号十进制整数
- %x
- %X
- %%: 打印一个百分号

### 4.4.2 printf() 的转换说明修饰符

在 % 和转换字符之间插入 **修饰符** 可修饰基本的转换说明，下面是合法的修饰符写法：   

- 标记：在后面会描述 5 种标记（-、+、空格、#和0），可以不使用标记或使用多个标记 "%-10d"
- 数字：最小字段宽度 "%4d"
- .数字：精度
  + 对于 %e, %E, %f 表示小数点后的位数
  + 对于 %g 和 %G，表示有效数字最大位数
  + 对于 %s，表示待打印字符的最大数量
  + 对于整型转换，表示待打印数字的最小位数
- h: 和整型转换说明一起用，表示 short int 或 unsigned short int 类型的值 %hu, %hx
- hh: 和整型转换说明一起用，表示 signed char 或 unsigned char 类型的值
- j: 和整型转换说明一起用，表示 intmax_t 或 uintmax_t 类型的值
- l: 和整型转换说明一起用，表示 long int 或 unsigned long int 类型的值
- ll: 和整型转换说明一起用，表示 long long int 或 unsigned long long int 类型的值
- L: 和浮点转换说明一起使用，使用 long double 类型的值
- t: 和整型转换说明一起用，表示 ptrdiff_t 类型的值，ptrdiff_t 是两个指针差值的类型
- z: 和整型转换说明一起用，表示 size_t 类型的值，size_t 是 sizeof 返回的类型    

标记：   

- -: 待打印项左对齐，从字段的左侧开始打印该项
- +: 有符号值若为正，则在值前面显示加号；若为负，则在值前面显示减号
- 空格: 有符号值若为正，则在值前面显示前导空格，若为负，则在值前面显示减号
- \#: 把结果转换为另一种形式，如果是 %o 格式，则以 0 开始，如果是 %x 或 %X，则以 0x 或 0X开始
- 0: 对于数值格式，用前导 0 代替空格填充字段宽度   

```c
#include <stdio.h>
#define PAGES 959

int main(void) {
  printf("*%d*\n", PAGES);
  printf("*%2d*\n", PAGES);
  printf("*%10d*\n", PAGES);
  printf("*%-10d*\n", PAGES);
  return 0;
}
```   

输出：   

```
*959*
*959*
*       959*
*959       *
```   

浮点型：   

```c
#include <stdio.h>

int main(void) {
  const double RENT = 3852.99;
  printf("*%f*\n", RENT);
  printf("*%e*\n", RENT);
  printf("*%4.2f*\n", RENT);
  printf("*%3.1f*\n", RENT);
  printf("*%10.3f*\n", RENT);
  printf("*%10.3E*\n", RENT);
  printf("*%+4.2f*\n", RENT);
  printf("*%010.2f*\n", RENT);
  return 0;
}
```

输出：   

```
*3852.990000*
*3.852990e+03*
*3852.99*
*3853.0*
*  3852.990*
* 3.853E+03*
*+3852.99*
*0003852.99*
```   

### 4.4.3 转换说明的意义

转换说明把以二进制格式储存在计算机中的值转换成一系列字符（字符串）以便于显示。例如，数字 76 在计算机
内部的存储格式是二进制数 01001100。%d 转换说明将其转换成字符 7 和 6，并显示为 76；%x 转换
说明把相同的值转换成十六进制计数法 4c，%c 转换说明把 01001100 转换成字符 L。   

转换可能会误导读者认为原始值被转替换成转换后的值。实际上，转换说明是翻译说明，%d 的意思是“把给定
的值翻译成十进制整数文本并打印出来”。   

**参数传递**    

参数传递机制因实现而异。下面以我们的系统为例，分析参数传递的原理。函数调用如下：   

```c
float n1 = 3.0;
double n2 = 3.0;
long n3 = 2000000000;
long n4 = 1234567890;
printf("%ld %ld %ld %ld\n", n1, n2, n3, n4);
```    

该调用告诉计算机把变量 n1, n2, n3, n4 的值传递给程序。这是一种常见的参数传递方式。计算机根据
变量类型把这些值放入栈中。因此，n1 占 8 字节（float 类型被转换成 double 类型），n2 占 8字节，
n3 和 n4 分别占 4 字节。然后，控制转到 `printf()`。该函数根据转换说明，从栈中读取值。%ld
转换说明表明 `printf()` 应该读取 4 字节，所以 `printf()` 读取栈中的前 4 字节作为第 1 个值，
这是 n1 的前半部分，将被解释成一个 long 类型的整数。根据下一个 %ld 的转换说明，`printf()`
再读取 4 字节，这是 n1 的后半部分，将被解释成第 2 个 long 类型的整数。类似地，根据第 3 个和
第4个 %ld，`printf()` 读取 n2 的前半部分和后半部分，并解释成两个 long 类型的整数。因此，
对于 n3 和 n4，虽然用对了转换说明，但 `printf()` 还是读错了字节。    

给字符串断行有 3 种方法：   

- 使用多个 printf() 语句
- 用反斜杠 `\` 和 Enter 键组合来断行。这使得光标移至下一行，而且字符串中不会包含换行符。其效果
是在下一行继续输出。但是，下一行代码从最左边开始。如果缩进该行，则前面的空格会成为字符串中的一部分。
- ANSI C 引入的字符串连接。在两个用双引号括起来的字符串之间用空白隔开，C编译器会把多个字符串看做
是一个字符串    

```c
printf("Here's the newest way to print a \
long string.\n");
printf("Hello, young"  "lovers" ", wherever you are");
```    

### 4.4.4 使用 scanf()

scanf() 把输入的字符串转换成整数、浮点数、字符或字符串。   

如果用 scanf() 读取基本变量类型的值，在变量名前加上一个 &。如果用 scanf() 把字符串读入字符
数组中，不要使用 &。   

```c
#include <stdio.h>

int main(void) {
  int age;
  float assets;
  char pet[30];
  printf("Enter your age, assets, and favorite pet.\n");
  scanf("%d %f", &age, &assets);
  scanf("%s", pet);
  printf("%d $%.2f %s\n", age, assets, pet);
  return 0;
}
```    

`scanf()` 函数使用空白（换行符、制表符和空格）把输入分成多个字段。在依次把转换说明和字段匹配时
跳过空白。    

唯一例外的是 %c 转换说明。根据 %c，scanf() 会读取每个字符，包括空白。    

scanf() 函数所用的转换说明与 printf() 函数几乎相同。主要的区别是，对于float类型和double类型，
printf() 都使用 %f、%e、%E、%g 和 %G 转换说明。而 scanf() 只把它们用于 float 类型，对于
double 类型时要使用 l 修饰符。    

同样，可以在转换说明中的百分号和转换字符之间使用修饰符：   

- *: 抑制赋值
- 数字: 最大字段宽度，输入达到最大字段宽度处，或第 1 次遇到空白字符时停止
- hh: 把整数作为 signed char 或 unsigned char 类型读取
- ll: 把整数作为 long long 或 unsigned long long 类型读取
- h, l, L
- j
- z
- t    

接下来，我们更详细地研究 scanf() 怎样读取输入。假设 scanf() 根据一个 %d 转换说明读取一个整数。
scanf() 函数每次读取一个字符，跳过所有的空白字符，直至遇到第1个非空白字符才开始读取。因为要读取
整数，所以 scanf() 希望发现一个数字字符或者一个符号（+或-）。如果找到一个数字或符号，它便保存
该字符，并读取下一个字符。如果下一个字符是数字，它便保存该数字并读取下一个字符。scanf() 不断地
读取和保存字符，直至遇到非数字字符。如果遇到一个非数字字符，它便认为读到了整数的末尾。然后，
scanf() 把非数字字符放回输入。这意味着程序在下一次读取输入时，首先读到的是上一次读取丢弃的
非数字字符。最后，scanf() 计算已读取数字(可能还有符号)相应的数值，并将计算后的值放入指定的变量中。   

如果使用字段宽度，scanf() 会在字段结尾或第1个空白字符处停止读取(满足两个条件之一便停止)。    

scanf() 函数允许把普通字符放在格式字符串中。除空格字符外的普通字符必须与输入字符串严格匹配。例如，
假设在两个转换说明中添加一个逗号：    

```c
scanf("%d,%d", &n, &m);
```    

scanf() 函数将其解释成：用户将输入一个数字、一个逗号，然后再输入一个数字。也就是说，用户必须像
下面这样进行输入两个整数：`88,121`。   

由于格式字符串中，%d 后面紧跟逗号，所以必须在输入88后再输入一个逗号。但是，由于 scanf() 会跳过
整数前面的空白，所以下面两种输入方式都可以：   

```
88, 121
88,
121
```   

除了 %c，其他转换说明都会自动跳过待输入值前面所有的空白。因此 `scanf("%d%d", &n, &m)` 与
`scanf("%d %d", &n, &m)` 的行为相同。对于 %c，在格式字符串中添加一个空格字符会有所不同。例如，
如果把%c放在格式字符串中的空格前面，`scanf()` 便会跳过空格，从第1个非空白字符开始读取。
也就是说，`scanf("%c", &ch);` 从输入中的第 1 个字符开始，而· `scanf("%c", &ch)` 则从
第 1 个非空白字符开始读取。   

scanf() 函数返回成功读取的项数。如果没有读取任何项，且需要读取一个数字而用户却输入一个非数值
字符串，scanf() 便返回0。当 scanf() 检测到“文件结尾”时，会返回EOF。    

### 4.4.5 printf() 和 scanf() 的*修饰符

printf() 和 scanf() 都可以使用*修饰符来修改转换说明的含义。但是，它们的用法不太一样。   

如果你不想预先指定字段宽度，希望通过程序来指定，那么可以用*修饰符代替字段宽度。但还是要用一个参数
告诉函数，字段宽度应该是多少。也就是说，如果转换说明是 %*d，那么参数列表中应包含\*和 d 对应的值。
这个技巧也可用于浮点值指定精度和字段宽度。   

scanf() 中 \* 的用法与此不同。把 * 放在 % 和转换字符之间时，会使得 scanf() 跳过相应的输出项。   

```c
#include <stdio.h>

int main(void) {
  int n;
  printf("Please enter three integers:\n");
  scanf("%*d %*d %d", &n);
  printf("The last integer was %d\n", n);
  return 0;
}
```    

运行示例：   

```
Please enter three integers:
2013 2014 2015
The last integer was 2015
```    

# 第 5 章 运算符、表达式和语句

## 5.1 基本运算符

### 5.1.1 赋值运算符

赋值运算符左侧必须引用一个存储位置。最简单的方法就是使用变量名。不过，后面章节还会介绍“指针”，可
用于指向一个存储位置。概括地说，C使用可修改的左值标记那些可赋值的实体。难理解。。。。    

也许“可修改的左值”不太好懂，我们再来看一些定义。    

赋值表达式语句的目的是把值储存到内存位置上。用于储存值的数据存储区域统称为数据对象。C标准只有在
提到这个概念时才会用到对象这个术语。使用变量名是标识对象的一种方法。除此之外，还有其他方法。例如，
可以指定数组的元素、结构的成员，或者使用指针表达式。因此，对象指的是实际的数据存储，而左值是用于
标识或定位存储位置的标签。    

对于早期的C语言，提到左值意味值：   

1. 它指定一个对象，所以引用内存中的地址
2. 它可用在赋值运算符的左侧    

但是后来，标准中新增了const限定符。用const创建的变量不可修改。因此,const标识符满足上面的第1项，
但是不满足第2项。一方面C继续把标识对象的表达式定义为左值，一方面某些左值却不能放在赋值运算符的左侧。
有些左值不能用于赋值运算符的左侧。此时，标准对左值的定义已经不能满足当前的状况。   

为此，C标准新增了一个术语：可修改的左值，用于标识可修改的对象。所以，赋值运算符的左侧应该是可修改
的左值。当前标准建议，使用术语对象定位值（object locator value）更好。    

右值指的是能赋值给可修改左值的量，且本身不是左值。   

算了，也别想那么复杂。   

### 5.1.2 除法运算符：/

整数除法和浮点数除法不同。浮点数除法的结果是浮点数，而整数除法的结果是整数。   

```c
#include <stdio.h>

int main(void) {
  printf("integer division: 5/4 is %d \n", 5 / 4);
  printf("integer division: 6/3 is %d \n", 6 / 3);
  printf("integer division: 7/4 is %d \n", 7 / 4);
  printf("floating division: 7./4. is %1.2f \n", 7. / 4.);
  printf("mixed division: 7./4 is %1.2f \n", 7. / 4);
  return 0;
}
```   

输出为：   

```
integer division: 5/4 is 1 
integer division: 6/3 is 2 
integer division: 7/4 is 1 
floating division: 7./4. is 1.75 
mixed division: 7./4 is 1.75 
```    

上例包含一个“混合类型”的示例，即浮点值除以在整型值。C 相对其他一些语言而言，在类型管理上比较宽容。
在本例中，在进行除法运算前，整数会被转换成浮点数。       

注意，整数除法会截断计算结果的小数部分，不会四舍五入结果。    

C99标准以前，C语言给语言的实现者留有一些空间，让他们来决定如何进行负数的整数除法。一种方法是，
舍入过程采用小于或等于浮点数的最大整数。当然，对于3.8而言，处理后的3符合这一描述。但是-3.8
会怎样?该方法建议四舍五入为-4，因为-4 小于-3.8。但是，另一种舍入方法是直接丢弃小数部分。这种
方法被称为“趋零截断”，即把-3.8转换成-3。在C99以前，不同的实现采用不同的方法。但是C99规定使用
趋零截断。所以，应把-3.8转换成-3。    

## 5.2 其他运算符

C语言大约有 40 个运算符。    

### 5.2.1 sizeof 运算符和 size_t 类型

sizeof 运算符以字节为单位返回运算对象的大小（在 C 中，1字节定义为 char 类型占用的空间大小）。
运算对象可以是类型或具体的数据对象。如果运算对象是类型，则必须用括号括起来。   

C语言规定，sizeof 返回 size_t 类型的值。这是一个无符号整数类型，但它不是新类型。size_t 是语言
定义的标准类型。C有一个 typedef 机制，允许程序员为现有类型创建别名：   

```c
typedef double real;
```    

类似地，C头文件系统可以使用 typedef 把 size_t 作为 unsigned int 或 unsigned long 的别名。   

### 5.2.2 求模运算符：%

求模运算符用于整数运算。只能用于整数，不能用于浮点数。   

负数求模如何进行？C99规定“趋零截断”在之前，该问题的处理方法很多。但自从有了规则之后，如果第一个
运算对象是负数，那么求模的结果为负数；如果第一个运算对象是正数，那么求模的结果也是正数。    

### 5.2.3 递增运算符：++

```c
#include <stdio.h>

int main(void) {
  int a = 1, b = 1;
  int a_post, pre_b;
  
  a_post = a++;
  pre_b = ++b;
  printf("a a_post b pre_b \n");
  printf("%1d  %5d  %5d  %5d\n", a, a_post, b, pre_b);
  return 0;
}
```    

输出 2 1 2 2。   

a 和 b 都递增了1，但是，a_post 是 a 递增之前的值，而 pre_b 是 b 递增之后的值。   

```c
q = 2 *++a;   // 首先a递增1，然后2*a，并将结果赋给q
q = 2 *a++;   // 首先，2*a，并将结果赋给q,然后 a 递增1
```   

这第二种有点令人出人意料啊。  

### 5.2.4 优先级

递增运算符和递减运算符都有很高的结合优先级，只有圆括号的优先级比它们高。因此，`x*y++`表示的是
`(x)*(y++)`，而不是(x*y)++。不过后者无效，因为递增和递减运算符只能影响一个变量（或者,更普遍地
说,只能影响一个可修改的左值），而组合x*y本身不是可修改的左值。   

不要混淆这两个运算符的优先级和它们的求值顺序。假设有如下语句：    

```c
y = 2;
n = 3;
nextnum = (y + n++) * 6;
```    

最终计算是 (2+3)*6 = 30; n 的值只有在被使用之后采会递增为 4，根据优先级的规定，++只作用于 n；
不作用于 y + n。根据优先级可以判断何时使用 n 的值对表达式求值，而递增运算符的性质决定了何时递增
n 的值。   

那其实可以这样理解，首先我们可以判断递增运算符结合优先级最高，那就是与 n 结合，知道和n结合之后，
那就算 y + n 即 2+3，得出值后，这时候应该进行 n 的递增，但是其实这时候已经和 n 的值无关了。   

比如说下面的这个：    

```c
int y = 2;
int n = 3;
int nextnum = (y + n++) * 6 + (y + n++) * 6;
```    

最后值是 66，但是不太确定会不会和编译器有关。   

比如说书上这样的一个例子：    


```c
int ans = num/2 + 5 *(1 + num++);
```    

书上说，编译器可能不会按预想的顺序来执行，我们可能认为，先计算第 1 项（num/2），接着计算第2项
（5*(1+num++)。但是，编译器可能先计算第2项，递增 num，然后在 num/2 中使用num递增后的新值。
因此，无法保证编译器到底先计算哪一项。   

## 5.3 表达式和语句

在前几章中，我们已经多次使用了术语表达式(expression)和语句(statement)。现在，我们来进一步
学习它们。C的基本程序步骤由语句组成，而大多数语句都由表达式构成。因此，我们先学习表达式。    

### 5.3.1 表达式

表达式由运算符和运算对象组成。最简单的表达式是一个单独的运算对象，以此为基础可以建立复杂的表达式。    

**每个表达式都有一个值**。   

C 表达式的一个最重要的特性是，每个表达式都有一个值。要获得这个值，必须根据运算符优先级规定的顺序
来执行操作。    

`6 + (c = 3 + 8)` 虽然看起来很奇怪，但在 C 中完全合法。   

### 5.3.2 语句

语句(statement)是C程序的基本构建块。一条语句相当于一条完整的计算机指令。在C中，大部分语句都以
分号结尾。因此，`legs = 4` 只是一个表达式，而 `legs = 4;` 则是一条语句。最简单的语句是空语句：   

```c
;  // 空语句
```   

C 把末尾加上一个分号的表达式都看作是一条语句，因此，像下面这样写也没问题：   

```c
8;
3 + 4;
```    

声明创建了名称和类型，并为其分配内存位置。但是，声明不是表达式语句。也就是说，如果删除声明后面的
分号，剩下的部分不是一个表达式，也没有值：   

```c
int port  // 不是表达式，没有值
```    

### 5.3.3 复合语句（块）

复合语句是用花括号括起来的一条或多条语句，复合语句也称为块。    

## 5.4 类型转换

通常，在语句和表达式中应使用类型相同的变量和常量。但是，如果使用混合类型，C 不会像 Pascal那样
停在那里死掉，而是采用一套规则进行自动类型转换。    

下面是一些类型转换的规则：    

1. 当类型转换出现在表达式时，无论是 unsigned 还是 signed 的 char 和 short 都会被自动转换
程 int，如有必要会被转换程 unsigned int。
2. 涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别。
3. 类型的级别从高至低依次是 long double, double, float, unsigned long long, long long,
unsigned long, long, unsigned int, int。之所以 short 和 char 没有列出，是因为它已经被
升级到 int 或 unsigned int。
4. 在赋值表达式语句中，计算的最终结果会被转换被赋值变量的类型。这个过程可能导致类型升级或降级。
5. 当作为函数参数传递时，char 和 short 被转换成 int，float 被转换成 double.    

类型降级时如果待转换的值与目标类型不匹配怎么办?这取决于转换涉及的类型。待赋值的值与目标类型不匹
配时，规则如下：   

1. 目标类型是无符号整型，且待赋的值是整数时，额外的位将被忽略。例如，如果目标类型是 8 位 unsigned
char，待赋的值是原值求模 256
2. 如果目标类型是一个有符号整型，且待赋的值是整数，结果因实现而异
3. 如果目标类型是一个整型，且待赋的值是浮点数，该行为是未定义的    

```c
#include <stdio.h>

int main(void) {
  char ch;
  int i;
  float fl;
  fl = i = ch = 'C';        // 9
  printf("ch = %c, i = %d, fl = %2.2f\n", ch, i, fl);   // 10
  ch = ch + 1;      // 11
  i = fl + 2 * ch;    // 12
  fl = 2.0 * ch + i;    // 13
  printf("ch = %c, i = %d, fl = %2.2f\n", ch, i, fl);   // 14
  ch = 1107;      // 这一步本地报常量转换溢出  15
  printf("Now ch = %c\n", ch);    // 16
  ch = 80.89;   // 17
  printf("Now ch = %c\n", ch);  // 18
  return 0;
}
```   

第 9 行和第 10 行：字符 'C' 被作为 1 字节的 ASCII 值储存在 ch 中。整数 i 接受由 'C' 转换的
整数，即按 4 字节存储 67。最后，fl 接受由 67 转换的浮点数 67.00。   

第11 行和第 14 行：字符变量 'C' 被转换成整数 67，然后加 1。计算结果是 4 字节整数 68，被截断
成 1 字节存储在 ch 中。   

第 12 行和第 14 行：ch 的值被转换成 4 字节的整数68，然后 2 乘以 ch。为了和 fl 相加，乘积整数
136 被转换成浮点数。计算结果 203.00f 被转换成 int 类型，并储存在 i 中。   

第 13 行和第 14 行：ch 的值被转换成浮点数，然后 2 乘以 ch。为了做加法，i 的值 203 被转换成
浮点类型。    

第 15 行和第 16 行：演示了类型降级的示例。把 ch 设置为一个超出其类型范围的值，忽略额外的位后，
最终 ch 的值是字符S的ASCII码。或者，更确切地说，ch的值是1107 % 265，即83。   

### 5.4.1 强制类型转换运算符

强制类型转换（cast），即在某个量的前面放置用圆括号括起来的类型名，该类型名即是希望转换成的目标
类型。圆括号和它括起来的类型名构成了强制类型转换运算符（cast operator），其通用形式是:   

```
(type)
```   

## 5.5 带参数的函数

```c
#include <stdio.h>

void pound(int n);

int main(void) {
  int times = 5;
  char ch = '!';
  float f = 6.0f;
  pound(times);
  pound(ch);
  pound(f);

  return 0;
}

void pound(int n) {
  while(n-- > 0) {
    printf("#");
  }
  printf("\n");
}
```    

如果函数不接受任何参数，函数头的圆括号中应该写上关键字 void。    

当编译器执行到 pound(ch) 表达式时，会把参数 ch 自动转换成 int 类型。   

在ANSI C之前，C使用的是函数声明，而不是函数原型。函数声明只指明了函数名和返回类型，没有指明参数
类型。   

