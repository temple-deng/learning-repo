# 第 13 章 文件输入/输出

## 13.1 与文件进行通信

### 13.1.1 文本模式和二进制模式

C提供两种文件模式：文件模式和二进制模式。   

首先，要区分文本内容和二进制内容、文本文件格式和二进制文件格式，以及文件的文本模式和二进制模式。   

所有文件的内容都以二进制形式（0或1）储存。但是，如果文件最初使用二进制编码的字符（例如，ASCII或
Unicode）表示文本（就像C字符串那样），该文件就是文本文件，其中包含文本内容。如果文件中的二进制值
代表机器语言代码或数值数据（使用相同的内部表示，假设，用于long或double类型的值）或图片或音乐编
码，该文件就是二进制文件，其中包含二进制内容。    

UNIX 用同一种文件格式处理文本文件和二进制文件的内容。    

为了规范文本文件的处理，C提供两种访问文件的途径：二进制模式和文本模式。在二进制模式中，程序可以
访问文件的每个字节。而在文本模式中，程序所见的内容和文件的实际内容不同。程序以文本模式读取文件时，
把本地环境表示的行末尾或文件结尾映射为C模式。例如，C程序在旧式Macintosh中以文本模式读取文件时，
把文件中的\r转换成\n；以文本模式写入文件时，把\n转换成\r。或者，C文本模式程序在MS-DOS平台读取
文件时，把\r\n转换成\n；写入文件时，把\n转换成\r\n。   

除了以文本模式读写文本文件，还能以二进制模式读写文本文件。如果读写一个旧式MS-DOS文本文件，程序
会看到文件中的\r 和 \n 字符，不会发生映射。如果要编写旧式 Mac格式、MS-DOS格式或UNIX/Linux
格式的文件模式程序，应该使用二进制模式，这样程序才能确定实际的文件内容并执行相应的动作。   

虽然C提供了二进制模式和文本模式，但是这两种模式的实现可以相同。前面提到过，因为UNIX使用一种文件
格式，这两种模式对于UNIX实现而言完全相同。Linux也是如此。    

### 13.1.2 IO的级别

除了选择文件的模式，大多数情况下，还可以选择 IO 的两个级别（即处理文件访问的两个级别）。底层IO
使用操作系统提供的基本 IO 服务。标准高级 IO 使用 C 库的标准包和 stdio.h 头文件定义。因为无法
保证所有的操作系统都使用相同的底层 IO 模型，C标准只支持标准 IO 包。有些实现会提供底层库，但是C
标准建立了可移植的IO模型。    

### 13.1.3 标准文件

C程序会自动打开3个文件，它们被称为标准输入（standard input）、标准输出（standard output）和
标准错误输出（standard error output）。在默认情况下，标准输入是系统的普通输入设备，通常为
键盘；标准输出和标准错误输出是系统的普通输出设备，通常为显示屏。    

## 13.2 标准 IO

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char * argv[]) {
  int ch;
  FILE *fp;  // "文件指针"
  unsigned long count = 0;

  if (argc != 2) {
    printf("Usage: %s filename\n", argv[0]);
    exit(EXIT_FAILURE);
  }

  if ((fp = fopen(argv[1], "r")) == NULL) {
    printf("Can't open %s\n", argv[1]);
    exit(EXIT_FAILURE);
  }

  while ((ch = getc(fp)) != EOF) {
    putc(ch, stdout);
    count++;
  }

  fclose(fp);
  printf("File %s has %lu characters\n", argv[1], count);
  return 0;
}
```   

### 13.2.1 检查命令行参数

exit() 函数关闭所有打开的文件并结束程序。exit() 的参数被传递给一些操作系统。通常的惯例是：
正常结束的程序传递0，异常结束的程序传递非零值。    

并不是所有的操作系统都能识别相同范围内的返回值。因此，C标准规定了一个最小的限制范围。尤其是，标准
要求0或宏EXIT_SUCCESS用于表明成功结束程序，宏EXIT_FAILURE用于表明结束程序失败。这些宏和exit()
原型都位于stdlib.h头文件中。    

