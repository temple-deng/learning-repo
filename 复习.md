# 复习




## JS权威指南

1. `onclick`之类的事件监听是注册事件处理程序最简单的方法，把JS函数赋值给目标对象的属性，因此在JS中并没有用驼峰式的命令。  

2. \u0009 水平制表符， \u000A 换行符， \u000B 垂直制表符， \u000D 回车符， \u0020 空白符。  

3. `_`, `$`, 字母可以做标识符的开头，后续可以有`_`, `$`, 数字，字母。  

4. `return`, `break`, `continue`后面紧跟的换行符的话，JS会自动补全分号。  

5. 后缀表达式应该写在同一行，否则会被解析成前缀表达式    
   x  
   ++  
   y  
被解析成 `x;++y` 而不是 `x++;y`  

6. 通常来讲，如果一条语句以"(", "[", "/", "+"或"-"开始，那么它极有可能和前一条语句在一起解析(指的是前一条语句末尾没加;的情形)。  

7. 全局对象上的`isNaN`, `isFinite`方法会先用 Number() 方法转换参数，ES6中绑定在 Number 对象上的这两个方法则不会进行转换， 而是直接进行比较。  

8. `==` 运算符将原始值和其包装对象视为相等。  

9. 不带`new`调用`Object`函数可以将原始值参数转为其包装对象，就像调用对应的包装函数作显示类型装换一样。  

10. `toFixed()`参数指定小数点后的位数， `toExponential()`将转换为指数形式表示，参数也是指定小数点后的位数，不同的是其小数点前只有一位。`toPrecision()`参数则是指定整个数字的位数，如果参数指定的位数小于数字现有位数，则换成指数形式，否则可以填0。 注意3种方法都是将数字转换为字符串。  

11. "+", "==", "!=" 和众多的关系运算符对非日期对象来说，当执行对象到原始值的转换时使用的是特殊的转换规则: 首先尝试调用`valueOf()`方法，然后调用`toString()`， 不管得到的原始值是否能直接使用，都不会进一步转换为字符串或数字。  

12. 日期对象的减法是计算时间间隔的毫秒数，Month是从0开始，Date是日期，从1开始，Day是星期几，值为0~6，星期日为0，星期六为6.  

13. 使用`var`声明的全局变量作为全局对象的属性是不可配置和不可删除的，但在非严格模式中，未使用`var`声明的全局变量作为全局对象的属性是可配置和可删除的。  

14. "<=" 和 ">=" 运算符在判断相等的时候，并不依赖于相等运算符和严格相等运算符的比较规则。相反，小于等于只是简单的"不大于"，大于等于只是简单的"不小于",只有在一个操作数是(或转换后是)NaN时例外，此时4个运算符均返回false。  

15. eval()只有一个参数，如果传入的参数不是字符串，它直接返回这个参数，如果参数是字符串，它会把字符串当成JS代码进行编译，如果编译失败，则抛出一个语法错误。如果编译成功，则开始执行这段代码，并返回字符串中最后一个表达式或语句的值，如果最后一个表达式会语句没有值，则最终返回undefined。  

16. 当直接使用非限定的"eval"名称来调用eval函数，它总是在调用它的上下文作用域内执行。其他的间接调用则使用全局对象作为其上下文作用域，并且无法读，写，定义局部变量和函数。在严格模式下，局部eval()可查询或更改局部变量，但不能在局部作用域内定义新的变量和函数。  

17. 严格模式。
    + 在严格模式中禁止使用with语句。
    + 在严格模式中，所有的变量都要先声明，如果给一个未声明的变量，函数，函数参数，catch从句参数或全局对象的属性赋值，将会抛出一个引用错误异常。
    + 在严格模式中，调用的函数(不是方法)中的一个`ythis`值是`undefined`。
    + 在严格模式中，当通过`call()`或`apply()`来调用函数时，其中的this值就是通过`call()`或`apply()`传入的第一个参数。(在非严格模式中，null和undefined值被全局对象和转换为对象的非对象值所代替)
    + 给只读属性赋值和给不可扩展的对象创建新成员都将抛出一个类型错误异常。
    + 传入`eval()`的代码不能在调用程序所在的上下文中声明变量或定义函数。相反，变量和函数的定义是在`eval()`创建的新作用域中，这个作用域在`eval()`返回时就弃用了。
    + 函数里的arguments对象拥有传入函数值的静态副本。
    + 当`delete`运算符后跟随非法的标识符(比如变量、函数、函数参数)时，将会抛出一个语法错误异常。
    + 试图删除一个不可配置的属性将抛出一个类型错误异常。
    + 在一个对象直接量中定义两个或多个同名属性将产生一个语法错误。
    + 函数声明中存在两个或多个同名的参数将产生一个语法错误。
    + 不允许八进制直接量（以0为前缀）
    + 标识符`eval`和`arguments`当做关键字，他们的值是不能更改的。不能给这些标识符赋值。也不能把它们声明为变量、用作函数名、用作函数参数或用作catch块的标识符。
    + arguments.caller和arguments.callee都会抛出一个类型错误异常。  

18. try/catch/finally语句
```javascript
try {
	// 通常来讲，这里的代码会从头执行到尾而不会产生任何问题
	// 但有时会抛出一个异常，要么是有throw语句直接抛出异常
	// 要么是通过调用一个方法间接抛出异常
}
catch(e){
	// 当且仅当try语句块抛出了异常，才会执行这里的代码
	// 这里可以通过局部变量e来获得对Error对象或者抛出的其他值的引用
	// 这里的代码块可以基于某种原因处理这个异常，也可以忽略这个异常
	// 还可以通过throw语句重新抛出异常
}
finally {
	// 不管try语句块是否抛出了异常，这里的逻辑总是会执行，终止try语句块的方式有：
	// 1) 正常终止，执行完语句块的最后一条语句
	// 2) 通过break,continue或return语句终止
	// 3) 抛出一个异常，异常被catch从句捕获
	// 4) 抛出一个异常，异常未被捕获，继续向上传播
}
```    

19. 任何对`Object.defineProperty()`或`Object.defineProperties()`违反规则的使用都会抛出类型错误异常：  
   + 如果对象是不可扩展的，则可以编辑已有的自有属性，但不能给它添加新属性
   + 如果属性是不可配置的，则不能修改它的可配置性和可枚举性
   + 如果存取器属性是不可配置的，则不能修改其 getter 和 setter 方法，也不能将它转换为数据属性。
   + 如果数据属性是不可配置的，则不能将其转换为存取器属性
   + 如果数据属性是不可配置的，则不能将其可写性从 false 转换为 true ，但可以从 true 修改为 false。
   + 如果数据属性是不可配置且不可写的，则不能修改它的值，然而可配置但不可写属性的值是可以修改的。

20. JSON的语法是JS语法的子集，它并不能表示JS里的所有值。支持对象、数组、字符串、无穷大数字、布尔值和null， 并且他们可以序列化和还原。 NaN、Infinity和 -Infinity序列化的结果是null， 日期对象序列化的结果是ISO格式的日期字符串，JSON.parse()依然保留它们的字符串形态，而不能将它们还原为原始日期对象。函数、RegExp、Error对象和 undefined 值不能序列化和还原。JSON.stringify()只能序列化对象可枚举的自有属性。对于一个不能序列化的属性来说，在序列化后的输出字符串中会将这个属性省略掉。  

21. 数组方法： `sort()`——如果数组包含 `undefined` 元素，会排到数组尾部。 `splice()`返回一个由删除元素组成的数组。 `push()`是在尾部添加一个或多个元素。 `unshift()`的参数是一次性插入的，就像 `splice()` 方法， 而非一次一个地插入。 ES5中的数组方法，对稀疏数组中的不存在元素不调用传递的函数参数。  

22. 尽管有时候构造函数看起来像一个方法调用，但它依然会使用这个新对象作为调用上下文。也就是说，在表达式`new o.m()`中，调用上下文并不是o.

23. 正则表达式中园括号的用途： 把单独的项组合成子表达式，在完整的模式中定义子模式，允许在同一正则表达式的后部引用前面的子表达式。  

24. 对正则表达式前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是与那个模式相匹配的文本的引用。  

25. 不能在字符类中使用 \n 这种对子表达式的引用，所以下面的写法是非法的: `/(['"])[^'"]*\1/`  

26. 用 "(?:" 和 ")" 对子表达式分组，但不创建带数字的引用。  

27. 锚字符： `\b` 匹配一个单词的边界，就是位于字符 `\w`和 `\W`之间的位置，或位于字符 `\w`和字符串的开头或结尾之间的位置。 `\B`匹配非单词边界的位置。 `(?=P)` 零宽正向先行断言，要求接下来的字符都与P匹配，但不能包括匹配P的那些字符. `(?!P)`零宽负向先行断言，要求接下来的字符都不与P匹配。  

28. 正则对象的属性： `global`, `ignoreCase`, `multiline`, `lastIndex`, `source`。 `exec()`方法，如果找到一个匹配项，它将返回一个由匹配结果组成的数组，否则将返回 `null`。返回数组的元素0是匹配的文本，元素1是匹配RegExp中第一个带圆括号的子表达式文本，如果存在这样的子表达式的话。元素2匹配第二个子表达式文本，依次类推，数组的 `index`属性指定匹配的文本的第一个字符的位置，`input`指代string.  

29. source的值为该 RegExp 模式的文本内容，这个文本不包括正则表达式直接量中的分隔斜杠，也不包括"g","i","m"属性。  

30. `Date()`也可以不带 new 操作符，像一个函数一样调用，以这种方式调用`Date()`将忽略掉所有传入的参数，并返回当前日期和时间的一个字符串表示。  

31. `Date.now()`返回当前时间自纪元开始后的毫秒数。  

32. String实例的 `subString()`方法，如果 from 等于 to， 则这个方法将返回一个空字符串，如果 from 比 to大，这个将先交换两个参数的值，然后返回它们之间的子串。这个方法不接受负数参数。  

33. 开始加载文档，`document.readyState == 'loading'` => 非 `defer`和 `async` 脚本加载并执行， `defer` 和 `async` 脚本加载， `async`脚本加载完成后立即执行 =>  文档解析完成，`document.readyState == 'interactive'` => `defer` 脚本开始执行 => 所有 `defer`脚本执行完成后触发 DOMContentLoaded 事件，程序进入异步事件驱动阶段 => 等待图片等内容的加载以及未执行完的 `async` 脚本的执行 => 所有外部资源加载完成，脚本执行完毕。`document.readyState == 'complete'`， window对象上触发 load 事件。

34. Location对象  
    http://www.oreilly.com:1234/catalog/search.html?q=JavaScript&m=10#results  
    hash: #results  
    host: http://www.oreilly.com:1234  
    hostname: http://www.oreilly.com  
    port: 1234  
    pathname: /catalog/search.html  
    protocol: http:   
    search: ?q=JavaScript&m=10  
    href: http://www.oreilly.com:1234/catalog/search.html?q=JavaScript&m=10#results  

35. 如果窗口包含多个子窗口(比如&lt;iframe&gt;元素)，子窗口的浏览历史会按时间顺序穿插在主窗口的历史中。这意味着在主窗口调用 `history.back()` 可能会导致其中一个子窗口往回跳转到前一个显示的文档，但主窗口保留当前状态不变。  

36. 作为 Window 对象属性的文档元素： 如果在 html 文档中用 id 属性来为元素命名， 并且如果 Window对象没有此名字的属性， Window对象会赋予属性，它的名字是 id 属性的值，而它们的值指向表示文档元素的 HTMLElement 对象，以下元素如果有name属性的话也会这样表现：`<a> <applet> <area> <embed> <form> <frame> <iframe> <img> <object>`。有 name 或 id 属性的 `<iframe>` 元素，这个变量会引用表示当前 `<iframe>` 元素创建的嵌套的浏览器窗体的 Window 对象。  

37. Window 对象如果有 name 属性，就用它保存名字。该属性是可写的，并且脚本可以随意设置它。如果传递给 `window.open()`一个除 `_blank`之外的名字，通过该调用创建的窗口将以该名字作为 name 属性的初始值。 如果 `<iframe>`  元素有 name 属性，表示该 iframe 的 Window 对象会用它作为 name 属性的初始值。  

38. 窗口名字可以用来允许 `open()` 方法引用已存在的窗口，并同时可以作为 `<a>` 和 `<form>` 元素上 HTML target 属性的值， 用来表示引用的问题或表单提交结果应该显示在命名的窗口中。  

39. `<iframe>` 元素有 contentWindow 属性，引用该窗体的 Window 对象，也可以进行反向操作——从表示窗体的 Window 对象来获取该窗体的`<iframe>`元素——用 Window对象的 frameElement 属性。表示顶级窗口的 Window 对象的 frameElement 属性为 null, 窗体的 Window 对象的 frameElement 属性不为 null。  

40. 每个 Window 对象都有一个 frames 属性，它引用自身包含的窗口或窗体的子窗体。frames 属性引用的是类数组对象，并可以通过数字或窗体名索引。注意，frames[] 数组里的元素是 Window 对象，而不是 `<iframe>` 元素。  

41. 表示 HTML 属性的值通常是字符串。当属性为布尔值或数值，属性也是布尔值或数值，而不是字符串。事件处理程序属性总是为 Function对象(或 null)。任何 HTML 元素的 style 属性值是 CSSStyleDeclartion 对象而不是字符串。  

42. 查询窗口滚动条位置  
```javascript
  // 以一个对象的x和y属性的方式返回滚动条的偏移量  
  function getScrollOffsets(w) {
	var w = w || window;
	if(w.pageXOffset != null) 
	  return { x: w.pageXOffset, y: w.PageYOffset };

	var d = w.document;
	if(d.compatMode == 'CSS1Compat')
	  return { x: d.documentElement.scrollLeft, y: d.documentElement.scrollTop };

	return { x: d.body.scrollLeft, y: d.body.scrollTop };
}
```     



43. 查询窗口的视口尺寸  
```javascript
  // 作为一个对象的w和h属性返回视口的尺寸
  function getViewportSize(w) {
	var w = w || window;
	if(w.innerWidth != null) 
	  return { w: w.innerWidth, h: w.innerHeight };

	var d = w.document;
	if(d.compatMode == 'CSS1Compat')
	  return { w: d.documentElement.clientWidth, h: d.documentElement.clientHeight };

	return { w: d.body.clientWidth, h: d.body.clientHeight };
}
```  

44. 如果想查询内联元素每个独立的矩形，调用 `getClientRects()` 方法来获得一个只读的类数组对象，它的每个元素类似于 `getBoundingClientRect()` 返回的矩形对象。  

45. Window 对象的 `scrollTo()` (和其同义词`scroll()`)接受一个点的x 和 y 坐标(文档坐标)并作为滚动条的偏移量设置它们。 `scrollBy()`的参数是相对的，并在当前滚动条的偏移量上增加。  

46. 在 HTML 元素上有 `scrollIntoView()` 方法，该方法保证了元素能在视口中可见，默认情况下它试图将元素的上边缘放在尽量接近视口的上边缘，如果只传递 false 作为参数，它将试图将元素的下边缘放在尽量接近视口的下边缘。  

47. 用浏览器窗口对象的 `getComputedStyle()`方法来获得一个元素的计算样式，此方法的第一个参数就是要获取其计算样式的元素，第二个参数也是必须的，通常是 null 或空字符串，但它也可以是命名CSS伪对象的字符串，如':before'.  

48.

   
