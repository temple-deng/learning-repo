# 配置
<!-- TOC -->

- [Configuration Types 配置类型](#configuration-types-配置类型)
  - [导出一个接收 `--env` 参数的函数](#导出一个接收---env-参数的函数)
  - [导出一个 Promise](#导出一个-promise)
  - [导出多个配置](#导出多个配置)
- [Entry and Context](#entry-and-context)
  - [`context`](#context)
  - [`entry`](#entry)
- [Output](#output)
  - [`output.chunkFilename`](#outputchunkfilename)
  - [`output.crossOriginLoading`](#outputcrossoriginloading)
  - [`output.hashFunction`](#outputhashfunction)
  - [`output.hashDigest`（哈希摘要）](#outputhashdigest哈希摘要)
  - [`output.hashDigestLength`](#outputhashdigestlength)
  - [`output.filename`](#outputfilename)
  - [`output.hotUpdateChunkFilename`](#outputhotupdatechunkfilename)
  - [`output.hotUpdateFunction`](#outputhotupdatefunction)
  - [`output.hotUpdateMainFilename`](#outputhotupdatemainfilename)
  - [`output.jsonpFunction`](#outputjsonpfunction)
  - [`output.library`](#outputlibrary)
  - [`output.libraryTarget`](#outputlibrarytarget)
  - [`output.publicPath`](#outputpublicpath)
  - [output.sourceMapFilename](#outputsourcemapfilename)
- [Module](#module)
  - [`module.noParse`](#modulenoparse)
  - [`module.rules`](#modulerules)
  - [Rule](#rule)
    - [Rule Conditions](#rule-conditions)
    - [Rule results](#rule-results)
  - [`Rule.enforce`](#ruleenforce)
  - [`Rule.exclude`](#ruleexclude)
  - [`Rule.include`](#ruleinclude)
  - [`Rule.issuer`](#ruleissuer)
  - [`Rule.loader`](#ruleloader)
  - [`Rule.loaders`](#ruleloaders)
  - [`Rule.oneOf`](#ruleoneof)
  - [`Rule.options / Rule.query`](#ruleoptions--rulequery)
  - [`Rule.parser`](#ruleparser)
  - [`Rule.resource`](#ruleresource)
  - [`Rule.resourceQuery`](#ruleresourcequery)
  - [`Rule.rules`](#rulerules)
  - [`Rule.test`](#ruletest)
  - [`Rule.use`](#ruleuse)
  - [`Condition`](#condition)
  - [`UseEntry`](#useentry)
- [Resolve](#resolve)
  - [`resolve`](#resolve)
  - [`resolve.alias`](#resolvealias)
  - [`resolve.aliasFields`](#resolvealiasfields)
  - [`resolve.descriptionFiles`](#resolvedescriptionfiles)
  - [`resolve.enforceExtension`](#resolveenforceextension)
  - [`resolve.enforceModuleExtension`](#resolveenforcemoduleextension)
  - [`resolve.extensions`](#resolveextensions)
  - [`resolve.mainFields`](#resolvemainfields)
  - [`resolve.mainFile`](#resolvemainfile)
  - [`resolve.modules`](#resolvemodules)
  - [`resolveLoader`](#resolveloader)
- [DevServer](#devserver)
  - [`devServer`](#devserver)
  - [`devServer.clientLogLevel`](#devserverclientloglevel)
  - [`devServer.compress`](#devservercompress)
  - [`devServer.contentBase`](#devservercontentbase)
  - [`devServer.filename`](#devserverfilename)
  - [`devServer.headers`](#devserverheaders)
  - [`devServer.historyApiFallback`](#devserverhistoryapifallback)
  - [`devServer.hot`](#devserverhot)
  - [`devServer.hotOnly` - CLI only](#devserverhotonly---cli-only)
  - [`devServer.https`](#devserverhttps)
  - [`devServer.inline`  - CLI only](#devserverinline----cli-only)
  - [`devServer.lazy`](#devserverlazy)
  - [`devServer.port` - CLI only](#devserverport---cli-only)
  - [`devServer.public`  - CLI only](#devserverpublic----cli-only)
  - [`devServer.publicPath`](#devserverpublicpath)
- [Externals](#externals)
  - [`externals`](#externals)
- [devtool](#devtool)
  - [`devtool`](#devtool)
  - [对于开发环境](#对于开发环境)
  - [生产环境](#生产环境)

<!-- /TOC -->

## Configuration Types 配置类型

除了直接导出一个配置对象，还有其他的方式去满足别的需要。  


### 导出一个接收 `--env` 参数的函数  

有时需要在 webpack 的配置文件中切换开发环境以及生产环境。  

我们可以返回一个接收环境变量作参数的函数。当执行 webpack 时，就可以通过 `--env` 来切换构建环境，例如 `--env.production` or `--env.platform=web`.  


### 导出一个 Promise

webpack 会执行配置文件导出的函数并且等待返回一个 Promise. 在需要异步加载配置变量时会很方便。  

```javascript
module.exports = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve({
        entry: './app.js',
        /* ... */
      })
    }, 5000)
  })
}
```  


### 导出多个配置  

```javascript
module.exports = [{
  output: {
    filename: './dist-amd.js',
    libraryTarget: 'amd'
  },
  entry: './app.js',
}, {
  output: {
    filename: './dist-commonjs.js',
    libraryTarget: 'commonjs'
  },
  entry: './app.js',
}]
```



## Entry and Context

entry 对象是 webpack 开始构建打包文件的起点。 context 是一个包含入口文件所在目录绝对路径的字符串。  


### `context`  

`string`  

webpack 解析 entry points 和 loaders 路径的基础目录，是一个绝对路径。

` context: path.resolve(__dirname, 'app')`   

默认使用当前目录。  


### `entry`  

` string | [string] | object { <key>: string | [string] } | function: () => string | [string] | object { <key>: string | [string] })`  

## Output  

顶层的 `output` 键包含了 webpack 如何处理并且在哪里放置输出打包文件，静态资源以及其他任何打包的东西。  


### `output.chunkFilename`  

`string`  

这个选项决定了按需加载的分块文件的名字，参考 `output.filename` 属性关于可能的值的细节。  

这些文件名会在运行时动态生成来发送对分块的请求。因此，像 `[name]` 和 `[chunkhash]` 这样的占位符需要在 webpack 运行时在输出的打包文件中添加从分块 id 到占位符值的映射，
这会增加打包文件的大小并且可能由于分块的变化导致占位符值失效。

默认是 `[id].js` （实际上好像是 `[id].bundle.js` 吧）或者是一个根据 `output.filename` 推断的值。  


### `output.crossOriginLoading`  

`boolean` `string`  

只有当 `target` 属性时 web 时使用， 用来使用 JSONP 加载按需加载的分块，并在页面添加 script tags.  

允许跨域加载分块。有下面几种合法值：  
`crossOriginLoading: false` - 拒绝跨域加载(默认值)。  

`crossOriginLoading: "anonymous"` - 允许跨域加载但不添加验证内容。  

`crossOriginLoading: "use-credentials"` - 允许跨域且添加验证内容。  

### `output.hashFunction`  

使用的哈希算法，默认是 `md5`。 所有 Node.JS  `crypto.createHash` 中的都被支持。  

### `output.hashDigest`（哈希摘要）

在生成 hash 时使用的编码方式，默认是 `'hex'`。 所有 Node.JS 中 `hash.digest` 都被支持。   


### `output.hashDigestLength`  

使用的哈希摘要的首部长度，默认是 20。  



### `output.filename`  

`string`  

默认值是 `"[name].js"`  

这个选项虽然叫做 filename, 但是仍然可以赋值如 `"js/[name].bundle.js"` 来创建一个文件夹结构。  

注意这个选项不影响按需加载分块文件。对于这些文件使用 `output.chunkFilename`。 同样也不影响 loaders 生成的文件。  

可选的替换值有下面几个：  


模板 | 描述 |
---------|---------- |
[hash] | 模块标识符的 hash |
[chunkhash] | chunk 内容的 hash |
[name] | 模块名称，这个应该指的是在对象 entry 中入口点的键名 |
[id] | 模块标识符，这模块标识符就是模块的ID吧 |
[file] | 模块文件名称 | 
[filebase] | 模块的 basename，然而实验时file和 filebase 都报错，可能是不能在 filename 配置中使用吧 |
[query] | 模块query，例如，文件名 `?` 后面的字符串 |   


`[hash]` 和 `[chunkhash]` 的长度可以通过 `[hash:16]`的写法指定（默认是20）。也可以通过 `output.hashDigestLength` 属性来全局配置。  

当使用 `ExtractTextWebpackPlugin` 时。 使用 `[contenthash]` 获取导出文件的 hash 值。  


### `output.hotUpdateChunkFilename`  

`string`  

定制热更新分块的文件名。参考 `output.filename` 可能值。  

唯一允许的替换值是 `[id]` 和 `[hash]`, 默认是：  

`hotUpdateChunkFilename: "[id].[hash].hot-update.js"`  


### `output.hotUpdateFunction`  

`function`  

只有当 `target` 是web时使用，这时使用 JSONP 来热更新。  

一个用来异步加载热更新分块的 JSONP 函数。  


### `output.hotUpdateMainFilename`  

`string`  

指定主热更新文件的文件名。 `[hash]` 是唯一可使用的替换值。默认为：

`hotUpdateMainFilename: "[hash].hot-update.json"`  


### `output.jsonpFunction`

`string`  

只有当 `target` 为 web 时使用，这时使用 JSONP 来加载按需加载的分块。  

用来异步加载分块的 JSONP 函数名。  


### `output.library`  

`string`  

编写库文件时库的名字。  


### `output.libraryTarget`  

`string` 默认是 `"var"`  

配置库文件应该导出什么形式的内容。

可取值有：`"var"` `"this"` `"window"` `"global"` `commonjs` `"commonjs2"` `"amd"` `"umd"` .   


### `output.publicPath`  

`string`  

当使用按需加载或加载外部资源如图片等资源时的一个重要的参数。   

这个选项指明了一个输出目录的公开 URL在浏览器中。 一个相对 URL 会相对于 HTML 页面解决。服务器相对 URLs，协议相对 URLs，绝对 URLs 也可能。

这个值会前缀到运行时创建的每个 URL 前或者 loaders 创建的每个 URL 前。因此这个值大部分情况下都要用 `/` 结尾。

默认是空字符串 `""`。

```javascript
publicPath: "https://cdn.example.com/assets/", // CDN (always HTTPS)
publicPath: "//cdn.example.com/assets/", // CDN (same protocol)
publicPath: "/assets/", // server-relative
publicPath: "assets/", // relative to HTML page
publicPath: "../assets/", // relative to HTML page
publicPath: "", // relative to HTML page (same directory)
```   

### output.sourceMapFilename

此选项会向硬盘写入一个输出文件，只在 devtool 启用了 SourceMap 选项时才使用。   

配置 source map 的命名方式。默认使用 `"[file].map"`。    

技术上看，对于 chunk 生成的 SourceMap，可以使用 `[name]`, `[id]`, `[hash]` 和 `[chunkhash]` 占位符(placeholder)。除了替换这些占位符，`[file]` 占位符还可以被替换为原始文件(original file)的文件名。建议只使用 `[file]` 占位符，因为其他占位符在非 chunk 文件生成的 SourceMap 时不起作用。最好保持默认。     



## Module  
---  

### `module.noParse`  

`RegExp | [RegExp]`  

阻止 webpack 解析与给定正则表达式匹配的任何文件。 被忽视的文件不应该有调用 `import` `require` `define` 或者其他导入机制。  


### `module.rules`  

`array`  Rules 的数组  


### Rule  

一条 Rule 可以分成3个部分—— Conditions, Results 和 嵌套 Rules.  

#### Rule Conditions  

Conditions有两种输入值情况：  

  1. 资源： 文件的绝对路径。已经根据 `resolve` 规则分解。  
  2. issuer: 请求资源的模块的文件的绝对路径。是 import 定位的地址。  

例如： 当我们 `import "./style.css"` 从 `app.js`文件中，资源是 `/path/to/style.css` , issuer 是 `/path/to/app.js`.  

`test`, `include`, `exclude`, `resource` 是与资源匹配的。 `issuer` 属性是和 issuer 匹配的。  


#### Rule results  

只有当 Rule Condition 匹配值才应用 Rule results。  

Rule 有两种输出值：

  1. 应用的 loaders：对资源应用的 loaders 数组。  
  2. 解析器选项: 用来为这个模块创建解析器的选项对象。  

`loader` `options` `use` 影响 loaders.  

出于兼容性考虑 `query` `loaders` 也可以使用。  

`enforce` 影响 loader 的分类。 如 normal, pre- 或者 post-loader.  

`parser` 影响解析器选项。  


### `Rule.enforce`  

可选的值：`"pre" | "post"`.  

声明 loader 的类型。 没有值时意味着是常规的 loader 。

还有一种 “内联 loader”，即内联使用或者在 import/require 使用的 loader。  

所有的 loaders 按照 `post, inline, normal, pre` 的顺序排列且按照顺序使用。  

所有常规(normal) loader 可能被忽视（或者叫覆盖）通过在请求中前缀 `!`。  

所有的 normal 和 pre loader可能被忽视通过在请求中前缀 `-!`。

所有的 normal, post 和 pre loaders 可能被忽视通过在请求中前缀 `!!`。  




### `Rule.exclude`  

`Rule.resource.exclude` 的缩写。

### `Rule.include`  

`Rule.resource.include` 的缩写。  

### `Rule.issuer`  

匹配 issuer 的规则。  


### `Rule.loader`  

`Rule.use: [ { loader} ]` 的缩写。  


### `Rule.loaders`  

`Rule.use` 的别名。 为了兼容性的产物。


### `Rule.oneOf`  

当 Rule 匹配时只有第一匹配的 Rule 使用的规则数组。  


### `Rule.options / Rule.query`  

这两个均是 `Rule.use: [ { options } ]` 的缩写。 `Rule.query` 是兼容性的产物。  


### `Rule.parser`  


###　`Rule.resource`  

匹配资源的规则。  


### `Rule.resourceQuery`  


### `Rule.rules`  

当规则匹配时同时使用的规则数组。  


### `Rule.test`  

`Rule.resource.test` 的缩写。  


### `Rule.use`  

应用到模块上的 UseEntries 列表。 每个 entry 指明了一个使用的loader。  

传入一个字符串（如 `use: [ "style-loader" ]`）是 loader 属性的缩写(如: `use: [ { loader: "style-loader" } ]`)。  

loaders 可以链式调用， 最终应用时是从右到左应用。  


### `Condition`  

Conditions 可以是以下之一：  

  + 一个字符串： 匹配开头必须与字符串匹配的输入。例如，一个绝对目录路径，或一个文件的绝对路径。  
  + 一个正则表达式：会与输入值校验。
  + 一个函数：会用输入值做参数调用，必须返回一个用于匹配的真值。  
  + 一个Conditions的数组：至少其中之一的Condition要匹配。  
  + 一个对象：所有的属性都必须匹配。每个属性定义了行为。  

`{ test: Condition }` Condition必须匹配。一般是传入一个正则表达式或正则的数组，但不是强制的。  

`{ include: Condition }` Condition 必须匹配。一般是一个字符串或字符串数组，但不是强制的。  

`{ exclude: Condition }` Condition 必须不能匹配。一般是字符串或字符串数组，不是强制的。  

`{ and: [Condition] }` 所有 Condition 必须匹配。  

`{ or: [Condition] }` 任何一个 Condition 匹配即可。  

`{ not: Condition }` Condition 必须不能匹配。  


### `UseEntry`  

`object`

必须有一个字符串的 `loader` 属性。是根据 loader 寻址路径配置参数 resolveLoader 对象中的 `context` 属性进行相对寻址。

可以有一个字符串或对象形式的 `option` 选项。 这个值会传递给 loader 作为 loader 的选项。  




## Resolve  

这些选项改变了模块的解决方式。  

### `resolve`  

`object`

配置如何解决模块。例如，当我们调用 `import "lodash"`, `resolve` 选项可以改变 webpack 寻找 `"lodash"` 的位置。  


### `resolve.alias`  

`object`  

为 `import` 或者 `require` 加载的模块创建别名。例如，为共用的 `src/` 文件夹起别名：  

```javascript
alias: {
  Utilities: path.resolve(__dirname, 'src/utilities/'),
  Templates: path.resolve(__dirname, 'src/templates/')
}
```

现在，可以不使用下面的写法：

`import Utility from '../../utilities/utility'`  

转而使用别名：  

`import utility from 'Utilities/utility'`;  

键名的最后一部分加 `$` 表示精准匹配，意思 `import` 时的东西结尾部分必须完全和键名一致吧，后面不能再出现别的东西，
如果出现，那就无法匹配，使用常规的寻址方式吧。    


### `resolve.aliasFields`  

`string`  


### `resolve.descriptionFiles`  

`array`

描述性的 JSON 文件，默认 `descriptionFiles: ["package.json"]`  


### `resolve.enforceExtension`  

`boolean`  

如果为 `true`, 就不允许缺少扩展名的文件。所以默认情况时 `require('./foo')` 可以正常引用当 `./foo` 有 `.js` 扩展名一样。  默认为 false.  


### `resolve.enforceModuleExtension`  

`boolean`  

是否要求模块有扩展名（例如 loaders）.默认为 false.  



### `resolve.extensions`  

`array`  

自动处理指定的扩展名。 默认值：  

`extensions: [".js", ".json"]`  

这个属性允许用户导入模块时省略扩展名.    

### `resolve.mainFields`  

`array`  

当从一个 npm 包导入内容时，这个选项会决定检查其 `package.json` 的哪个域。默认值基于 `target` 配置。  

当 `target` 值为 `webworker`，`web` 或者没有指定时：   

`mainFields: ["browser", "module", "main"] // 按优先级排列`    

其他任意值：  

`mainFilds: ["module", "main"]`  


### `resolve.mainFile`  

`array`  

当处理目录时使用的文件名。 默认值 `mainFiles: ["index"]`  


### `resolve.modules`

`array`  

告诉 webpack 当处理模块时应该搜寻哪个目录。  

可以使用绝对路径或者相对路径， 但是两者行为不同。  

扫描相对路径时和 Node 扫描 `node_modules` 时相似， 查找当前目录以及祖先目录。  

如果是绝对路径，就只会搜查给定的目录。

默认值： `modules: ["node_modules"]`  

如果想要添加一个目录并且优先于 `node_modules/` :

`module: [path.resolve(__dirname, "src"), "node_modules"]`


### `resolveLoader`  

`object`  

这个属性的设置和上面的 `resolve` 是一致的，但是只用来解决 loader 包的问题。  




## DevServer  


### `devServer`

`object`  

这个选项会被 webpack-dev-server 处理， 用来用多种方式修改它的行为。下面的例子提供了 `dist/`目录下的所有东西并且提供 gzips 压缩。  

```javascript
  devServer: {
    contentBase: path.join(__dirname, "dist"),
    compresss: true,  
    port: 9000
  }
```  

如果我们通过 Node.js API 使用 dev-server, `devServer` 中的选项会被忽略。  


### `devServer.clientLogLevel`

`string`  

当使用 *内联模式* 时，控制台可能会展示很多信息，可能会很繁琐。  

可以使用下面的选项禁止展示这些信息：

`clientLogLevel: "none"`

可选的值有 `none`, `error`, `warning`或者 `info`（默认值）。  


### `devServer.compress`  

`boolean`  

对提供的资源启动 gzip 压缩。  


### `devServer.contentBase`  

`boolean` `string` `array`  

告诉服务器提供的资源在哪里。 `devServer.publicPath` 用来决定打包文件在哪里。  

默认使用当前工作目录提供服务。


### `devServer.filename`

`string`


### `devServer.headers`  

`object`

为所有请求添加响应首部：  

```javascript
  headers: {
    "X-Custom-Foo": "bar"
  }
```


### `devServer.historyApiFallback`  

`boolean` `object`


### `devServer.hot`  

`boolean`

启用 webpack 模块热更新能力。  `hot: true`  


### `devServer.hotOnly` - CLI only

`boolean`  

Enables Hot Module Replacement (see devServer.hot) without page refresh as fallback in case of build failures.  


### `devServer.https`  

`boolean` `object`  

选择 HTTP/2 及 HTTPS 协议  `https: true`.  


### `devServer.inline`  - CLI only

`boolean`  

在 dev-server 的两种模式间切换。默认启用 *内联模式*。  


### `devServer.lazy`  

`boolean`  

当启用 `lazy` 选项时， dev-server只会在请求打包文件的时候重新编译。意味着 webpack 没必要监控任何文件的变更。这就是 **lazy mode**.   


### `devServer.port` - CLI only  

`number`  

指定监听的端口:   `port: 8080`  


### `devServer.public`  - CLI only  

`string`  

当使用 *内联模式*， 并且代理 dev-server时， 内联客户端脚本不总是知道连接到何处。 它总是假设 URL 基于 `window.location`， 但如果失败了我们就需要使用这个选项。  


### `devServer.publicPath`  

`string`  

打包文件在这个目录下可用。  

假设服务器跑在 `http://localhost:8080` 并且 `output.filename` 为 `bundle.js`. 默认属性值时 `"/"`, 所有打包文件默认在 `http://localhost:8080/bundle.js`.  

`publicPath: "/assets/"`  

此时打包文件在 `http://localhost:8080/assets/bundle.js`  

确保这个属性前后都有一个 `"/"`.  

也可以使用完整的 URL.  



## Externals  

`externals` 配置提供了一种在打包文件中不包含依赖的方式。相反，打包文件依赖这个依赖在客户环境可用。  


### `externals`  

`string` `regex` `function` `array` `object`  

阻止将指定的导出文件打包，相反将其恢复成外部包。  

## devtool

### `devtool`

`string` `false`   

选择一种 source map 来增强调试过程。注意，以下选项能够可能会很明显地影响构建(build)和重构建(rebuild)的速度。    


devtool | 构建 | 重构建 | 生产环境 | 特性
---------|----------|--------- |--------- |--------- 
eval| +++ | +++ | no | 生成后的代码 
eval-source-map | -- | + | no | 原始源码
cheap-eval-source-map | + | ++ | no | 转换过的代码（仅限行） 
cheap-source-map | + | o | yes | 转换过的代码（仅限行）
cheap-module-eval-source-map | o | ++ | no | 原始源码（仅限行）
cheap-module-source-map | o | - | yes | 原始源码（仅限行）
source-map | -- | -- | yes | 原始源码
inline-source-map | -- | -- | no | 原始源码
hidden-source-map | -- | -- | yes | 原始源码
nosources-source-map | -- | -- | yes | 无源码内容   

`+` 表示较快，`-` 表示较慢，`o` 表示时间相同。   

其中一些值适用于开发环境，一些适用于生产环境。对于开发环境，通常希望更快速的 Source Map，需要添加到 bundle 中以增加体积为代价，但是对于生产环境，则希望更精准的 Source Map，需要从 bundle 中分离并独立存在。    

### 对于开发环境

`eval` - 每个模块都使用 `eval()` 执行，并且都有 `//@ sourceURL`。选项会相当快地构建。主要缺点是，由于会映射到转换后的代码，而不是映射到原始代码，所以不能正确的显示显示行数。（这里的转换好像是指对模块 `import, export` 之类的转换）注意后面的 `//@ sourceURL` 并不是什么 source map 的内容，反而像是对转换后代码地址的映射，但是老是说我也不知道这转换后的文件时在哪找的的。   

`eval-source-map` - - 每个模块使用 `eval()` 执行，并且 SourceMap 转换为 DataUrl 后添加到 `eval()` 中。初始化 SourceMap 时比较慢，但是会在重构建时提供很快的速度，并且生成实际的文件。行数能够正确映射，因为会映射到原始代码中。这个的话同时还会指出转换后代码的映射位置。      

`inline-source-map` - SourceMap 转换为 DataUrl 后添加到 bundle 中。    

`cheap-eval-source-map` - 和 `eval-source-map` 类似，但是只映射到行。   

`cheap-module-eval-source-map` - 和 `cheap-eval-source-map` 类似，然而，在这种情况下，loader 能够处理映射以获得更好的结果。    

### 生产环境

`source-map` - 生产完整的 source map，输出为独立文件。   

`hidden-source-map` -  和 `source-map` 相同，但是没有在 bundle 中添加引用注释。   

`cheap-source-map` - 不带列映射的 source map。    

`cheap-module-source-map` - 不带列映射的 source map。    

`nosources-source-map` - 创建一个没有 `sourcesContent` 的 source map。户端（译者注：指浏览器）上的堆栈跟踪，而不会暴露所有的源码。    




