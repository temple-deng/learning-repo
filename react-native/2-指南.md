# 指南


## 1. 处理触摸行为

用户与移动app交互的主要方式是通过触摸，可能使用手势操作的结合，如敲击按钮，滚动列表或者放大地图。  

### 1.1 可点击组件

当想要捕获敲击手势可以使用 "Touchable" 组件。其可以通过 `onPress` 属性接收一个函数，函数会在触摸
行为在组件的范围内开始和结束时调用。  

```javascript
class MyButton extends Component {
  _onPressButton() {
    console.log("You tapped the button!");
  }

  render() {
    return (
      <TouchableHighlight onPress={this._onPressButton}>
        <Text>Button</Text>
      </TouchableHighlight>
    );
  }
}
```

可点击的组件应当可以提供反馈给用户，如用户在触碰什么东西，或者当其抬起手指时会发生什么。  

我们想要提供的反馈类型决定了最终要使用的组件：  

+ 一般来说，当使用一个 button 或者以网络 link 时可以使用 `TouchableHighlight`。当用户按
在 button 上时视图的背景会变暗。
+ 可以考虑在Android上使用 `TouchableNativeFeedback`显示在用户手指按下时形成类似墨水涟漪的视觉效果。
+ `TouchableOpacity`可用于通过减少按钮的不透明度来提供反馈，从而允许在用户按下时看到背景。  
+ 如果需要处理轻拍手势，但不希望显示任何反馈，请使用`TouchableWithoutFeedback`。  


在某些情况下，可能想要检测用户何时按住并保持视图一段时间。 这些长按可以通过将函数传递给上述任何可触摸组件的 `onLongPress`属性来处理。    

### 1.2 滚动列表和在视图上左右滑动

`ScrollView` 可以在垂直或水平方向滚动，还可以配置 `pagingEnabled` 属性来让用户整屏整屏的滑动。此外，水平方向的滑动还可以使用Android上的 `ViewPagerAndroid` 组件。  

`ListView` 则是一种特殊的 `ScrollView`，用于显示比较长的垂直列表。它还可以显示分区块的头部和尾部，类似iOS上的 `UITableView` 控件。  

如果在 `ScrollView` 中只放置一个组件，则可以用来实现缩放操作。设置 `maximumZoomScale` 和 `minimumZoomScale` 属性即可以使用户能够缩放其中的内容。  





## 2. 动画

React Native提供了两个互补的动画系统：用于精细的粒度和交互动画的 Animated，以及用于全局布局事务的LayoutAnimation。  

### 2.1 Animated

Animated 旨在以声明的形式来定义动画的输入与输出，在其中建立一个可配置的变化函数，然后使用简单的 `start/stop` 方法来控制动画按顺序执行。 Animated 仅封装了四个可以动画化的组件：`View`、`Text`、`Image`和`ScrollView`，不过你也可以使用`Animated.createAnimatedComponent()`来封装你自己的组件。  

```javascript
// FadeInView.js
import React, { Component } from 'react';
import {
  Animated,
} from 'react-native';

export default class FadeInView extends Component {
  constructor(props) {
    super(props);
    this.state = {
      fadeAnim: new Animated.Value(0),          // 透明度初始值设为0
    };
  }
  componentDidMount() {
    Animated.timing(                            // 随时间变化而执行的动画类型
      this.state.fadeAnim,                      // 动画中的变量值
      {
        toValue: 1,                             // 透明度最终变为1，即完全不透明
      }
    ).start();                                  // 开始执行动画
  }
  render() {
    return (
      <Animated.View                            // 可动画化的视图组件
        style={{
          ...this.props.style,
          opacity: this.state.fadeAnim,          // 将透明度指定为动画变量值
        }}
      >
        {this.props.children}
      </Animated.View>
    );
  }
}
```  

#### 配置动画

动画可配置的内容非常广泛，定制和预定义缓动函数，延迟时间，持续时间，衰减因子（decay factors），弹性常量（spring constants）等等都可以根据动画的类型进行调整。  

`Animated` 提供了多种动画类型，最常用的是 `Animated.timing()`。该类型支持让一个值随时间按照多种预定义缓动函数之一函数进行动画，也可以使用自定义的动画函数。缓动函数通常用来表达动画对象的渐进加速与减速。  

默认情况下， `timing` 会使用 easeInOut 曲线：逐步加速到全速，并逐渐减速停止。  

#### 组合动画

动画可以组合起来按序执行或者并行执行。按序执行的动画会在之前的动画结束后立即开始执行，或者在规定的延迟后开始执行。`Animated` API 提供了多种方法，如 `sequence()`, `delay()`，每一个都简单地接受一个动画数组来调用，并且在需要的时候自动调用 `start()/stop()` 函数。  

```javascript
Animated.sequence([            // 首先执行decay动画，结束后同时执行spring和twirl动画
  Animated.decay(position, {   // 滑行一段距离后停止
    velocity: {x: gestureState.vx, y: gestureState.vy}, // 根据用户的手势设置速度
    deceleration: 0.997,
  }),
  Animated.parallel([          // 在decay之后并行执行：
    Animated.spring(position, {
      toValue: {x: 0, y: 0}    // 返回到起始点开始
    }),
    Animated.timing(twirl, {   // 同时开始旋转
      toValue: 360,
    }),
  ]),
]).start();                    // 执行这一整套动画序列
```  

如果有一个动画停止或者中断了，那其他的动画也会停止。 `Animated.parallel` 可能设置 `stopTogether` 选项为 `false`来禁止这种行为。  


#### 插值 Interpolation

每个属性在使用前都可以先执行插值操作。每个插值操作会将输入值的范围映射到一个输出值的范围，通过使用线性插值，不过也支持缓动函数。默认会根据给定的范围推断出曲线，但也可以强制设定输出值。  

例如，我们可以将 `Animated.Value` 值限定在0到1之间，但动画的位置属性是从150px到0px，不透明度是从0到1。  

```javascript
style = {{
  opacity: this.state.fadeAnim,
  transform: [{
    translateY: this.state.fadeAnim.interpolate({
      inputRange: [0, 1],
      outputRange: [150, 0]   // 0: 150, 0.5: 75, 1: 0
    }),
  }],
}}
```  


#### 追踪手势

手势，比如平移或者滚动，以及其他的事件都可以使用 `Animated.event` 直接与动画值映射起来。这是通过结构化的映射语法完成的，以便可以从复杂事件对象中提取值。第一层是一个数组允许跨多个参数映射，并且该数组包含嵌套的对象。  

#### 响应当前动画值

目前还没有明确的方式在动画过程中去读取当前值。这是由于处于优化的角度考虑，一些值只有在原生代码运行时才能知道。如果需要使用JS对当前的值做出响应的话，有两种方法：

+ `spring.stopAnimation(callback)` 会停止动画然后使用最终值调用回调函数。当处理手势动画时很有用。
+ `spring.addListener(callback)` 会在动画运行过程中异步调用回调函数，传入一个最近的值。这在触发state改变时有用，譬如当用户拖拽一个东西靠近的时候弹出一个新的气泡选项。不过这个状态切换可能并不会十分灵敏，因为它不像许多连续手势操作（如旋转）那样在60fps下运行。  

`Animated` 是设计成完全序列化的，以便动画都在一种高性能的方式下运行，独立于JS的 event loop 机制。这对 API 有影响，所以相比于完全同步的系统来说，有时实现一些效果时可能会有些棘手。  

#### 使用原生驱动(driver)

通过使用原生驱动程序，我们会在动画开始前将动画所需的所有内容发送给原生代码，这就可以让原生代码在 UI 线程中执行动画，而不用在每帧中跨桥通信。一旦动画开始执行，JS线程就会阻塞，不能再对动画产生影响。  

普通动画使用原生驱动程序非常容易。只要设置 `useNativeDriver` 为 `true`就可以了。  

```javascript
Animated.timing(this.state.animatedValue, {
  toValue: 1,
  duration: 500,
  useNativeDriver: true, // <-- Add this
}).start();
```  

**注意点**  

不是 `Animated` 中所有的东西当前都支持原生驱动。主要的限制是仅仅能动画非布局属性：比如 `transform`
, `opacity`, `backgroundColor`。但是弹性盒以及位置属性就不行。当使用 `Animated.event` 时，只会在
直接的事件上工作，在冒泡的事件上就不行。  



### 2.2 LayoutAnimation API

`LayoutAnimation` 允许你在全局范围内创建和更新动画，这些动画会在下一次渲染或布局周期运行。它常用来更新flexbox布局，因为它可以无需测量或者计算特定属性就能直接产生动画。尤其是当布局变化可能影响到父节点（譬如“查看更多”展开动画既增加父节点的尺寸又会将位于本行之下的所有行向下推动）时，如果不使用`LayoutAnimation`，可能就需要显式声明组件的坐标，才能使得所有受影响的组件能够同步运行动画。  

注意尽管`LayoutAnimation`非常强大且有用，但它对动画本身的控制没有`Animated`或者其它动画库那样方便，所以如果你使用`LayoutAnimation`无法实现一个效果，那可能还是要考虑其他的方案。  


## 3. 导航 Navigation

### 3.1 React Navigation

社区今后主推的方案是一个单独的导航库`react-navigation`，它的使用十分简单。  

首先安装 `npm install --save react-navigation`  

然后你就可以快速创建一个有两个页面（Main和Profile）的应用了：  

```javascript
import {
  StackNavigator,
} from 'react-navigation';

const App = StackNavigator({
  Main: {screen: MainScreen},
  Profile: {screen: ProfileScreen},
});
```  

其中每一个screen组件都可以单独设置导航选项，例如导航头的标题。还可以使用navigation属性中的方法去跳转到别的页面：  

```javascript
class MainScreen extends React.Component {
  static navigationOptions = {
    title: 'Welcome',
  };
  render() {
    const { navigate } = this.props.navigation;
    return (
      <Button
        title="Go to Jane's profile"
        onPress={() =>
          navigate('Profile', { name: 'Jane' });
        }
      />
    );
  }
}
```  

React Navigation的路由写法使其非常容易扩展导航逻辑，或是整合到redux中。由于路由可以嵌套使用，因而开发者可以根据不同页面编写不同的导航逻辑，且彼此互不影响。  

React Navigation中的视图是原生组件，同时用到了运行在原生线程上的`Animated`动画库，因而性能表现十分流畅。此外其动画形式和手势都非常便于定制。  

### 3.2 NavigatorIOS

如果你只针对iOS平台开发，那么可以考虑使用`NavigatorIOS`。它是基于 `UINavigationController`封装的，所以看起来很像。  

用法与其他导航系统类似，`NavigatorIOS`也使用路由对象来描述场景，但有一些重要区别。其中要渲染的组件在路由对象的`component`字段中指定，要给目标组件传递的参数则写在`passProps`中。被渲染的`component`都会自动接受到一个名为`navigator`的属性，你可以直接调用此对象(`this.props.navigator`)的`push`和`pop`方法。

由于`NavigatorIOS`使用的是原生的UIKit导航，所以它会自动渲染一个带有返回按钮和标题的导航栏。  


## 4. 图片

### 4.1 静态图片资源

React Native提供了一种统一的方式来管理IOS和Android app中的图片和其他媒体资源。如果想在app中添加
一个静态图片，直接像下面的方式引用即可：  

`<Image source={require('./my-icon.png')} />`  

图片文件的查找会和JS模块的查找方式一样。在上面的例子中，是哪个组件引用了这个图片，Packager就会去这个组件所在的文件夹下查找`my-icon.png`。如果你有`my-icon.ios.png`和`my-icon.android.png`，Packager就会根据平台而选择不同的文件。  

你还可以使用`@2x`，`@3x`这样的文件名后缀，来为不同的屏幕精度提供图片。比如下面这样的代码结构：  

```
.
├── button.js
└── img
    ├── check@2x.png
    └── check@3x.png
```  

并且`button.js`里有这样的代码：  

`<Image source={require('./img/check.png')} />`  

Packager会打包所有的图片并且依据屏幕精度提供对应的资源。譬如说，iPhone 7会使用`check@2x.png`，而Nexus 5上则会使用`check@3x.png`。如果没有图片恰好满足屏幕分辨率，则会自动选中最接近的一个图片。  

为了使新的图片资源机制正常工作，`require`中的图片名字必须是一个静态字符串。  

通过这种方式引用的图片资源包含图片的尺寸（宽度，高度）信息，如果你需要动态缩放图片（例如，通过flex），你可能必须手动在`style`属性设置`{ width: undefined, height: undefined }`。  

### 4.2 静态非图片资源

上面描述的`require`语法也可以用来静态地加载你项目中的音频、视频或者文档文件。大多数的文件类型包括`.mp3`, `.wav`, `.mp4`, `.mov`, `.html` 和 `.pdf`。  

需要注意的是视频必须使用绝对定位而不是`flexGrow`，因为非图片资源尺寸信息当前不会传递。这个限制对于直接链接到Xcode或者Android资源文件夹的视频不会出现。  


### 4.3 Hybrid App中的图片

如果你在编写一个 Hybird App（一部分UI使用React Native，而另一部分使用平台原生代码），也可以使用已经打包到App中的图片资源（通过Xcode的asset类目或者Android的drawable文件夹打包）：   

`<Image source={{uri: 'app_icon'}} style={{width: 40, height: 40}} />`    

这一做法并没有任何安全检查。你需要自己确保图片在应用中确实存在，而且还需要指定尺寸。  


### 4.4 网络图片

与静态资源不同的是，网络图片需要手动指定图片的尺寸。同时我们强烈建议你使用https以满足iOS App Transport Security 的要求。  

```javascript
// GOOD
<Image source={{uri: 'https://facebook.github.io/react/img/logo_og.png'}}
       style={{width: 400, height: 400}} />

// BAD
<Image source={{uri: 'https://facebook.github.io/react/img/logo_og.png'}} />
```   

#### 缓存控制（Only IOS）

一些情况下我们可能会想只有在本地有缓存的时候才展示图片，比如，在高分辨率图片还没加载完成
时先使用一张低分辨率图片作占位符。还有一些情况时当我们不在意图片是否过期并且也愿意展示过期的图片来
节省带宽。`cache`属性可以让我们来控制网络层如何与缓存交互。  

+ `default`: 使用原生平台的默认缓存策略。
+ `reload`: URL的数据将从原始地址加载。不使用现有的缓存数据。
+ `force-cache`: 使用已缓存的数据提供给对应的请求，不管数据是否过期。如果不存在对应的数据缓存，就从数据源加载。  
+ `only-if-cached`: 使用已缓存的数据提供给对应的请求，不管数据是否过期。如果不存在对应的数据缓存，不会尝试
从数据源缓存数据，所以对应的加载会被认为失败了。  

```javascript
<Image source={{uri: 'https://facebook.github.io/react/img/logo_og.png', cache: 'only-if-cached'}}
       style={{width: 400, height: 400}} />
```   

### 4.5 本地文件系统的图片

#### 最合适的相册图片

iOS会为同一张图片在相册中保存多个不同尺寸的副本。为了性能考虑，从这些副本中挑出最合适的尺寸显得尤为重要。
对于一处200x200大小的缩略图，显然不应该选择最高质量的3264x2448大小的图片。如果恰好有匹配的尺寸，那么React Native
会自动为你选好。如果没有，则会选择最接近的尺寸进行缩放，但也至少缩放到比所需尺寸大出50%，以使图片看
起来仍然足够清晰。这一切过程都是自动完成的，所以你不用操心自己去完成这些繁琐且易错的代码。  


### 4.6 通过嵌套来实现背景图片

开发者们常面对的一种需求就是类似web中的背景图（background-image）。要实现这一用例，只需简单地创建一个`<Image>`组件，然后把需要背景图的子组件嵌入其中即可。  

```javascript
return (
  <Image source={...}>
    <Text>Inside</Text>
  </Image>
);
```

### 4.7 iOS边框圆角的注意事项

请注意下列边框圆角样式目前在iOS的图片组件上还不支持：

+ `borderTopLeftRadius`
+ `borderTopRightRadius`
+ `borderBottomLeftRadius`
+ `borderBottomRightRadius`


## 5. 颜色

React Native 支持 `rgb()` , `rgba()`, `hsl()`, `hsla()`以及 `transparent`。  

+ `'#f0f'`
+ `'#ff00ff'`
+ `'rgb(255, 0, 255)'`
+ `'rgba(255, 255, 255, 1.0)'`
+ `'#f0ff'`(#rgba)
+ `'#ff00ff00'`(#rrggbbaa)
+ `'hsl(360, 100%, 100%)'`
+ `'hsla(360, 100%, 100%, 1.0)'`
+ `'transparent'`


## 6. 平台特定的代码

通常在构建跨平台app时，都会尽可能的重用代码。但是有时使用不同的代码也是有必要的，比如
有时我们可能想为IOS和Android实现独立的不同的视觉组件。  

React Native 提供了两种简单的方式来组织代码并根据不同的平台分离代码：  

+ 使用 `Platform` 模块
+ 使用平台特定的文件扩展名

某些组件的一些属性可能只在特定的平台上有效果。这些属性都会使用 `@platform` 注释。   

### 6.1 Platform 模块

React Native 提供了一个用于检测app运行平台的模块。可以使用这种检测逻辑来实现平台特定的代码。  

```javascript
import { Platform, StyleSheet } from 'react-native';

const styles = StyleSheet.create({
  height: (Platform.OS === 'ios') ? 200 : 100,
});
```  

```javascript
import { Platform, StyleSheet } from 'react-native';

const styles = StyleSheet.create({
  container: {
    flex: 1,
    ...Platform.select({
      ios: {
        backgroundColor: 'red',
      },
      android: {
        backgroundColor: 'blue',
      },
    }),
  },
});
```   

还可以用来检测Android的版本：  

```javascript
import { Platform } from 'react-native';

if(Platform.Version === 21){
  console.log('Running on Lollipop!');
}
```   

### 6.2 平台特定的扩展名

当平台特定的代码越来越复杂时，就应当考虑将代码分离在不同的文件中了。
React Native会检测文件名是否有 `.ios` 或者 `.android`的扩展名，在其他
组件引用这些文件时会加载相对应平台的文件。  


例如现在项目有如下的文件：  

```
BigButton.ios.js
BigButton.android.js
```

就可以按照下面的形式加载组件：  

`const BigButton = require('./BigButton');





