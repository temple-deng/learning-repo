# 0310

## mediaDevices    

返回 `navigator.mediaDevices` 返回一个 `MediaDevices` 对象，提供了对媒体输入设备
比如说摄像头、麦克风及屏幕共享的访问。    

MediaDevices 对象，继承自 EventTarget。   

- 事件：
  + devicechange: 当用户设置有输入输出设备变动
- 方法
  + `enumerateDevices()`: 返回一个 Promise, resolved 为一个 `MediaDeviceInfo` 数组，表示当前系统可用的输入输出设备。
  + `getSupportedConstraints()`: 返回一个基于 `MediaTrackSupportedConstraints` 字典的对象，因为只有浏览器支持的才会包含在对象中，所以所有属性值都是 true。
  + `getDisplayMedia(constraints)`: 貌似是用来屏幕共享的功能，提示用户选择并授权，将显示内容或其部分捕获为 MediaStream。类似下面的样子，也是返回一个 Stream 的 Promise。
  + `selectAudioOuput(options)`: 提示用户选择一个音频输出设备，返回选择设备 MediaDeviceInfo 的 Promise
  + `getUserMedia(constraints)`: 提示用户申请对媒体设备的使用，生成一个 MediaStream，包含请求的设备类型的 track。一般来说 stream 可以包含一个 video track, 一个 audio track，及其他 track 类型。返回一个 Stream Promise。
    - constraints 只有两个成员 video, audio。

![getDisplayMedia](https://cdn.jsdelivr.net/gh/temple-deng/learning-repo/imgs/getDisplayMedia.png)



## MediaDeviceInfo

- deviceId: 设备 id，一般在不同会话间是一致的，但注意是会话间，不是持久化，清空 cookie 就会重置
- groupId: 返回组 id，如果两个 device 属于同一个物理设备，就用一个组 id
- kind: 枚举值，`videoinput`, `audioinput`, `audiooutput`
- label


### MediaTrackSupportedConstraints    

字典属性值：   

- `autoGainControl`
- `width`
- `height`
- `aspectRatio`
- `frameRate`
- `facingMode`
- `resizeMode`
- `volume`
- `sampleRate`
- `sampleSize`
- `echoCancellation`
- `latency`
- `noiseSuppression`
- `channelCount`
- `deviceId`
- `groupId`    


## MediaStream    

表示一个媒体内容流，包含了多个 tracks。每个 track 都是一个 `MediaStreamTrack` 实例。    

通过下面的方式可以获取流：   

- `MediaDevices.getUserMedia()`
- `MediaDevices.getDisplayMedia()`
- `HTMLCanvasElement.captureStream()`    

+ 属性：
  - active: 只要其中的 track 有一个不是 ended 状态，就可以认为是 active
  - id
+ 方法：
  - `addTrack(track)`
  - `clone()`
  - `getAudioTracks()`
  - `getTrackById()`
  - `getTracks()`
  - `getVideoTracks()`
  - `removeTrack()`
+ 事件：
  - addtrack
  - removetrack
  - active
  - inactive

## MediaStreamTrack

属性：   

- contentHint: 就是个提示的字符串，用来告诉 app 这个 track 的内容是什么类型的
- enabled
- id
- kine: audio, video
- label
- muted
- readyState: live, ended
- remote

方法：   

- `applyConstraints()`
- `clone()`
- `getCapabilities()`
- `getConstraints()`
- `getSettings()`
- `stop()`     



## WebRTC API

由于 WebRTC 仍在进化过程中，而且各家浏览器对编码器和 WebRTC 功能的支持度也不同，
推荐使用 G 家的 Adapter.js（https://github.com/webrtcHacks/adapter）作为 polyfill。    

两个端点间的连接使用 `RTCPeerConnection` 接口表示。一旦建立了连接，并且使用
`RTCPeerConnection` 打开，就可以将 streams 或者 data channels(`RTCDataChannels`) 添加到连接中去。    

所以 RTC 不仅仅能用来传输流，还可以用来传递任意的二进制数据。   

### 连接建立和管理    

接口：   

- `RTCPeerConnection`: 表示本地到远程对等方的一个 WebRTC 连接。用来高效的处理流的数据
- `RTCDataChannel`: 代表一个连接两个对等方之间的双向数据通道
- `RTCDataChannelEvent`: 将 `RTCDataChannel` attach 到 `RTCPeerConnection` 上发生的事件
- `RTCSessionDescription`: 代表一个会话的参数。每个 `RTCSessionDescription` 包含一个 type 表示其描述了 offer/answer 协商过程中的哪一部分，以及属于会话 SDP 描述符的哪一部分
- `RTCStatsReport`: 提供对于连接信息细节的数据
- `RTCIceCandidate`: 代表一个用于建立 `RTCPeerConnection` 的 candidate Interactive Connectivity Establishment(ICE) 服务器
- `RTCIceTransport`: 表示一个 ICE transport 的信息
- `RTCPeerConnectionIceEvent`


算了太多了，先跳过这一部分。    

## WebRTC 协议

Interactive Connectivity Establishment(ICE) 交互式连接建立是一个允许浏览器和对等方连接的框架。可以提供给我们一个唯一的地址，在路由器不准直连对等方的时候，提供一个中转
数据的服务器。ICE 使用 STUN、TURN 服务器完成这些工作。    

Session Traversal Utilities for NAT(STUN) 是一种协议，用于发现您的公共地址，并确定路由器中阻止与对等方直接连接的任何限制。   

C 端会给 STUN 服务器发送请求，然后 STUN 会回复 C 的公开地址，以及是否能访问到 NAT 后的 C 端。    

Traversal Using Relays around NAT(TURN) 可以绕过路由器的限制，做法就是通过一个 TURN 服务器中转所有数据。这时候双方就是先和 TURN 服务器交流，再转发到另一方。   

Session Description Protocol(SDP) 是一个标准，描述连接中的多媒体内容，比如说分辨率、
格式、编解码器、加密等。以便在数据传输后，两个对等方能互相理解。本质上，这是描述内容的元数据，而不是媒体内容本身。    

本质上，SDP 不是一个协议，而是一种用来交换信息的格式。   

SDP 包括了多行 UTF-8 文本，每行以一个字符类型开头，后跟一个等号 "="，后面是由值或描述组成的结构化文本，其格式
取决于类型。以给定字母开头的文本化通常称为"字母行"。    

## Signaling and video calling

连接建立时的发现及沟通过程称为 signaling。   

### 信令服务器

WebRTC 并没有指定信令信息的传输机制。所以本质上我们可以自己选择，websocket, xhr 都是对等方可以选择的方式。   

很重要的一点是，服务器并不需要理解或解释信令数据的内容。也就是说信令服务器本质上并不关系数据的内容，它要做的就
只是传输数据。   

当我们开始信令的处理流程时，用户初始化调用的时候会创建一个 offer。这个 offer 是 SDP 格式，包含了会话的描述信息。
需要传递给对等方。对等方会使用一个 answer message 响应我们的 offer，同样也是 SDP 格式的消息。    

这个时候，双方就交换好了一些数据，比如编解码器等等，但是目前还不知道如何传递媒体数据本身，这时候就需要 ICE 了。   

两个对等方需要交换 ICE 来协商数据连接的情况。每个 ICE candidate 描述了发送方用来交流的方法。每个对等方
会在被发现的时候发送 candidate。    

icecandidate 事件会发送给 RTCPeerConnection，以完成使用 `pc.setLocalDescription(offer)` 添加本地描述的
过程。这一个没看懂啥意思。    

每个 ICE candidate 会发送一个 type 为 new-ice-candidate 的 json 消息给对等方，通过信令服务器，每个
candidate 消息包括以下字段:   

- type: new-ice-candidate
- target: 正在与之协商的人的用户名；服务器会仅将消息定向到此用户
- candidate: SDP candidate 字符串，描述提议的连接方法。   

ice message 会提议交流协议（tcp or udp），ip地址，端口号，连接类型（直连还是中转）。   

我们代码在唯一需要负责的事