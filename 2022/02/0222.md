# 0222

<!-- TOC -->

- [0222](#0222)
    - [博弈型动态规划](#博弈型动态规划)
    - [背包型动态规划](#背包型动态规划)
    - [区间型动态规划](#区间型动态规划)
    - [双序列型动态规划](#双序列型动态规划)

<!-- /TOC -->

## 博弈型动态规划

- 博弈动态规划通常从第一步分析，而不是最后一步
- 只要有一步能让对手败，那我就是必胜的
- 只要我操作了一步后，能让剩下的局面的先手必败，则我先手就是必胜的，因为我一定会让他进入先手必败的局面
- 反之，如果我走了后，剩下的局面都是必胜的，那我必败

## 背包型动态规划

任意多的时候，反而问题可能会简化。    

## 区间型动态规划

- 给定一个序列/字符串，进行一些操作
- 最后一步会将序列/字符串去头/去尾
- 剩下的会是一个区间[i, j]
- 状态自然定义为 f[i][j]，表示面对子序列[i,...,j] 时的最优性质
- 初始条件按照最短的长度来处理
  + f[0][0] = f[1][1] = f[2][2] = f[n-1][n-1] = 1
- 不能按照 i 的顺序算
- 按照长度 j - i 从小到大的顺序去算

## 双序列型动态规划

LCS 问题，最长公共子串。这是看最后一个字从哪个序列取。