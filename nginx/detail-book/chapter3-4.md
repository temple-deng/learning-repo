# 第 3 章 Nginx 服务器架构初探

<!-- TOC -->

- [第 3 章 Nginx 服务器架构初探](#第-3-章-nginx-服务器架构初探)
  - [3.1 Nginx 模块化结构](#31-nginx-模块化结构)
  - [3.2 Nginx 服务器的 Web 请求处理机制](#32-nginx-服务器的-web-请求处理机制)
    - [3.2.1 多进程方式](#321-多进程方式)
    - [3.2.2 多线程方式](#322-多线程方式)
    - [3.2.3 异步方式](#323-异步方式)
    - [3.2.4 Nginx 服务器如何处理请求](#324-nginx-服务器如何处理请求)
    - [3.2.5 Nginx 服务器的事件处理机制](#325-nginx-服务器的事件处理机制)
  - [3.3 Nginx 服务器的事件驱动模型](#33-nginx-服务器的事件驱动模型)
    - [3.3.1 事件驱动模型概述](#331-事件驱动模型概述)
    - [3.3.2 Nginx 的事件驱动模型](#332-nginx-的事件驱动模型)
    - [3.3.3 select 库](#333-select-库)
    - [3.3.4 poll 库](#334-poll-库)
    - [3.3.5 epoll 库](#335-epoll-库)
  - [3.4 设计架构概览](#34-设计架构概览)
    - [3.4.2 Nginx 服务器的进程](#342-nginx-服务器的进程)
    - [3.4.3 进程交互](#343-进程交互)
- [第 4 章 Nginx 服务器的高级配置](#第-4-章-nginx-服务器的高级配置)
  - [4.1 针对 IPv4 的内核 7 个参数的配置优化](#41-针对-ipv4-的内核-7-个参数的配置优化)
  - [4.2 针对 CPU 的配置指令](#42-针对-cpu-的配置指令)
  - [4.3 与网络连接相关的配置的 4 个指令](#43-与网络连接相关的配置的-4-个指令)

<!-- /TOC -->

## 3.1 Nginx 模块化结构

习惯上将 Nginx 涉及到的模块分为核心模块、标准 HTTP 模块、可选 HTTP 模块、邮件服务模块以及第三方
模块等五大类。   

核心模块和标准 HTTP 模块在 Nginx 快速编译后就包含在 Nginx 中。查看 nginx 安装包解压后的目录，
有一个 objs 目录，包含了以下内容：   

```
-rw-r--r-- 1 root root   40859 Feb  2 07:55 Makefile
-rw-r--r-- 1 root root   17529 Feb  2 07:55 autoconf.err
-rwxr-xr-x 1 root root 5241168 Feb  2 07:56 nginx*
-rw-r--r-- 1 root root    5341 Feb  2 07:56 nginx.8
-rw-r--r-- 1 root root    7279 Feb  2 07:55 ngx_auto_config.h
-rw-r--r-- 1 root root     657 Feb  2 07:55 ngx_auto_headers.h
-rw-r--r-- 1 root root    5957 Feb  2 07:55 ngx_modules.c
-rw-r--r-- 1 root root   53936 Feb  2 07:56 ngx_modules.o
drwxr-xr-x 9 root root    4096 Feb  2 05:19 src/
```    

在此目录中的 ngx_modules.c 文件中包含了此版本 Nginx 快速编译后包括的所有固有模块的声明。    

所有固有模块的源码放在编译目录下的 src 目录中，在 src 目录中，可以看到一共分成了 core, event,
http, mail, misc, os 和 stream 等目录。源码中包括了邮件服务的模块，但在编译时不会编译到 Nginx 中。   

1. **核心模块**

核心模块主要包含对两类功能的支持，一类是主体功能，包括进程管理、权限控制、错误日志记录、配置解析
等，另一类是用于响应请求事件必需的功能，包括事件驱动机制、正则表达式解析等。   

2. **标准 HTTP 模块**

- ngx_http_core: 配置端口、URI 分析、服务器响应错误处理、别名控制以及其他 HTTP 核心事务
- ngx_http_access_module: 基于 IP 地址的访问控制
- ngx_http_auth_basic_module: 基于 HTTP 的身份认证
- ngx_htto_autoindex_module: 处理以 / 结尾的请求并自动生成目录列表
- ngx_http_browser_module: 解析 HTTP 请求头中的 User-Agent 域的值
- ngx_http_charset_module: 指定网页编码
- ngx_http_empty_gif_module: 从内存创建一个 1*1 的透明 gif 图片，可以快速调用
- ngx_http_fastcgi_module: 对 FastCGI 的支持
- ngx_http_geo_module: 将客户端请求中的参数转化为键值对变量
- ngx_http_gzip_module: 压缩请求响应
- ngx_http_headers_filter_module: 设置 HTTP 响应头
- ngx_http_index_module: 处理以 / 结尾的请求，如果没有找到该目录下的 index 页，就将请求转给
ngx_http_autoindex_module 模块处理；如果 Nginx 服务器开启了 ngx_http_random_index_module，
则随机选择 index 页
- ngx_http_limit_req_module: 限制来自客户端的请求的响应和处理速率
- ngx_http_limit_conn_module: 限制来自客户端的连接的响应和处理速率
- ngx_http_log_module: 自定义 access 日志
- ngx_http_map_module: 创建任意键值对变量
- ngx_http_memcached_module: 对 Memcached 支持
- ngx_http_proxy_module: 支持代理服务
- ngx_http_referer_module: 过滤 HTTP 头中 Referer 域值为空的 HTTP 请求
- ngx_http_rewrite_module: 通过正则表达式重定向请求
- ngx_http_scgi_module: 对 SCGI 的支持
- ngx_http_ssl_module

3. **可选 HTTP 模块**   

可选 HTTP 模块在目前的 Nginx 发行版本中只提供源码，但在快速编译时默认不编译。   

4. **邮件服务模块**   

同上。    

## 3.2 Nginx 服务器的 Web 请求处理机制

一般来说，完成并行处理请求工作有三种方式可供选择：多进程方式、多线程方式和异步方式。   

### 3.2.1 多进程方式

多进程方式是指，服务器每当接收到一个客户端时2，就由服务器主进程生成一个子进程出来和该客户端建立
连接进行交互，直到连接断开，该子进程就结束了。   

多进程方式的优点在于，设计和实现相对简单，各个子进程之间相互独立，处理客户端请求的过程彼此不受干扰，
当一个子进程出现问题时，不容易将影响漫延到其他进程中，这保证了提供服务的稳定性。当子进程退出时，
其占用资源会被操作系统回收，也不会留下任何垃圾。而其缺点也是很明显的。操作系统生成一个子进程需要
进行内存复制等操作，在资源和时间上会产生一定的额外开销，因此，如果 Web 服务器接收大量并发请求，
就会对系统资源造成压力。    

初期的 Apache 服务器就是采用这种方式对外提供服务器的。为了应对大量并发请求，Apache 服务器采用
“预生成进程” 的机制对多进程方式进行了改进。它将子进程生成的时间提前，在客户端请求还没有到来之前
就预先生成好，当请求到来时，主进程分配一个子进程和该客户端进行交互，交互完成之后，该进程也不结束，
而被主进程管理起来等待下一个客户端请求的到来。改进的多进程方式在一定程度上缓解了大量并发请求情形
下 Web 服务器对系统资源造成的压力。但是由于 Apache 服务器在最初的架构设计上才赢了多进程方式，
因此这不能从根本上解决问题。   

### 3.2.2 多线程方式

由于操作系统产生一个线程的开销远远小于产生一个进程的开销，所以多线程方式在很大程度上减轻了 Web
服务器对系统资源的要求。该方式使用线程进行任务调度，开发方面可以遵循一定的标准，这相对来说比较规范
和有利于写作。但在线程管理方面，该方式有一定的不足。多个线程位于同一个进程内，可以访问同样的内存
空间，彼此之间相互影响；同时，在开发过程中不可避免地要由开发者自己对内存进行管理，增加了出错的
风险。服务器系统需要长时间连续不停地运转，错误的逐渐积累可能最终对整个服务器产生重大影响。   

IIS 服务器使用了多线程方式对外提供服务。   

### 3.2.3 异步方式

网络通信中的同步机制和异步机制是描述通信模式的概念。同步机制，是指发送方发送请求后，需要等待接收
到接收方发回的响应后，才接着发送下一个请求；异步机制，和同步机制正好相反，在异步机制中，发送方发出
一个请求后，不等待接收方响应这个请求，就继续发送下个请求。    

阻塞和非阻塞用来描述进程处理调用的方式，在网络通信中，主要指 socket 的阻塞和非阻塞方式。阻塞调用
方式为，调用结果返回之前，当前线程从运行状态被挂起，一直等到调用结果返回之后，才进入就绪状态，获取
CPU 后继续执行；非阻塞调用方式为，如果调用结果不能马上返回，当前线程也不会被挂起，而是立即返回执行
下一个调用。   

两对概念的组合，产生四个新的概念，同步阻塞、异步阻塞、同步非阻塞、异步非阻塞。   

- 同步阻塞：发送方向接收方发送请求后，一直等待响应；接收方处理请求时进行的 IO 操作如果不能马上
得到结果，就一直等到返回结果后，才响应发送方，期间不能进行其他工作。
- 同步非阻塞：发送方向接收方发送请求后，一直等待响应；接收方处理请求时进行的 IO 操作如果不能马上
得到结果，就立即返回，去做其他事情。
- 异步阻塞：发送方向接收方发送请求后，不用等待响应，可以接着进行其他工作；接收方处理请求时 IO 操作
如果不能马上得到结果，就一直等到返回结果后，才响应发送方，期间不能进行其他工作。
- 异步非阻塞方式：发送方向接收方发送请求后，不用等待响应；接收方处理请求时进行的 IO 操作如果不能
马上得到结果，也不等待，而是马上返回去做其他事情。     

### 3.2.4 Nginx 服务器如何处理请求

Nginx 服务器结合多进程机制和异步机制对外提供服务。异步机制使用的是异步非阻塞方式。   

Nginx 服务器启动后，可以产生一个主进程和多个工作进程 worker process。Nginx 服务器的所有工作
进程都用于接收和处理客户端的请求。这类似于 Apache 使用的改进的多进程机制，预先生成多个工作进程，
等待处理客户端请求。   

每个工作进程使用了异步非阻塞方式，可以处理多个客户端请求。当某个工作进程接收到客户端的请求以后，
调用 IO 进行处理，如果不能立即得到结果，就去处理其他的请求；当 IO 调用返回结果时，就会通知此工作
进程，该进程得到通知，暂时挂起当前处理的事务，去响应客户端请求。    

### 3.2.5 Nginx 服务器的事件处理机制

select/poll/epoll/kqueue 等这样的系统调用，也常被称为事件驱动模型，它们提供了一种机制，让进程
可以同时处理多个并发请求，不用关心 IO 调用的具体状态，IO 调用完全由事件驱动模型来管理，事件准备
好之后就通知工作进程事件已经就绪。   

## 3.3 Nginx 服务器的事件驱动模型

### 3.3.1 事件驱动模型概述

事件驱动模型一般是由事件收集器、事件发送器和事件处理器三部分基本单元组成。   

事件收集器专门负责收集所有的事件，包括来自用户的（如鼠标单击、键盘输入等）、来自硬件的（如时钟事件等）
和来自软件的（如操作系统等）。事件发送器负责将收集器收集到的事件分发到目标对象中。目标对象就是事件
处理器所处的位置。事件处理器主要负责具体事件的响应工作。   

### 3.3.2 Nginx 的事件驱动模型

通常，我们在编写服务器处理模型的程序时，基于事件驱动模型，“目标对象”中的“事件处理器”可以有以下
几种实现办法：   

- 事件发送器每传递过来一个请求，目标对象就创建一个新的进程，调用事件处理器来处理该请求
- 事件发送器每传递过来一个请求，目标对象就创建一个新的线程，调用事件处理器来处理该请求
- 事件发送器每传递过来一个请求，目标对象就将其放入一个待处理事件的列表，使用非阻塞 IO 方式调用
事件处理器来处理该请求    

大多数网络服务器采用了第三种方式，逐渐形成了所谓的“事件驱动处理库”。    

事件驱动处理库又被称为多路 IO 复用方法，最常见的包括以下三种：select 模型、poll 模型和 epoll
模型。    

### 3.3.3 select 库

select 库，是各个版本的 Linux 和 Windows 平台都支持的基本事件驱动模型库，并且在接口的定义
上也基本相同，只是部分参数的含义略有差异。使用 select 库的步骤一般是：   

首先，创建所关注事件的描述符集合。对于一个描述符，可以关注其上面的读事件、写事件以及异常发生事件，
所以要创建三类事件描述符集合。   

其次，调用底层提供的 `select()` 函数，等待事件发生。然后，轮询所有事件描述符集合中的每一个事件
描述符，检查是否有响应的事件发生，如果有，就进行处理。   

### 3.3.4 poll 库

poll 库仅支持 Linux 系统。    

poll 与 select 的基本工作方式是相同的，都是先创建一个关注事件的描述符集合，再去等待这些事件发生，
然后再轮询描述符集合，检查有没有事件发生，如果有，就进行处理。    

poll 库与 select 库的主要区别在于，select 库需要为读、写和异常事件分别创建一个描述符集合，因此
在最后轮询的时候，需要分别轮询这三个集合。而 poll 库只需要创建一个集合，在每个描述符对应的结构
上分别设置读、写或者异常事件，最后轮询的时候，可以同时检查这些事件是否发生。可以说，poll 是
select 的优化。   

### 3.3.5 epoll 库

epoll 是 poll 的变种，仅支持 Linux。    

一种比较好的做法是，把描述符列表的管理交给内核负责，一旦有某种事件发生，内核把发生事件的描述符列表
通知给进程，这样就避免了轮询整个描述符列表。epoll 就是这种模型。   

首先，epoll 通过相关调用通知内核创建一个有 N 个描述符的事件列表；然后，给这些描述符设置所关注的
事件，并把它添加到内核的事件列表中去。   

完成设置之后，epoll 库就开始等待内核通知事件发生了。某一事件发生后，内核将发生事件描述符列表
上报给 epoll。得到事件列表的 epoll 库，就可以进行事件处理了。   

## 3.4 设计架构概览

Nginx 服务器启动后，产生一个主进程，主进程执行一系列工作后产生一个或者多个工作进程。主进程主要
进行 Nginx 配置文件解析、数据结构初始化、模块配置和注册、信号处理、网络监听生成、工作进程生成和
管理等工作；工作进程主要进行进程初始化、模块调用和请求处理等工作，是 Nginx 服务器提供服务的主体。   

在客户端请求动态站点的过程中，Nginx 服务器还涉及和后端服务器的通信。Nginx 服务器将接收到的 Web
请求通过代理转发到后端服务器，由后端服务器进行数据处理和页面组织，然后将结果返回。   

另外，Nginx 服务器为了提高对请求的响应效率，进一步降低网络压力，采用了缓存机制，将历史应答数据
缓存到本地。在每次 Nginx 服务器启动后的一段时间内，会启动专门的进程对本地缓存的内容重建索引，保证
对缓存文件的快速访问。   

### 3.4.2 Nginx 服务器的进程

到目前为止，我们一共提到 Nginx 服务器的三大类进程：一类是主进程，另一类是由主进程生成的工作进程，
还有用于为缓存文件建立索引的进程。   

1. **主进程**    

- 读取 Nginx 配置文件并验证其有效性和正确性
- 建立、绑定和关闭 socket
- 按照配置生成、管理和结束工作进程
- 接收外界指令，比如重启、升级及退出服务器等指令
- 不中断服务，实现平滑重启，应用新配置
- 不中断服务，实现平滑升级，升级失败进行回滚处理
- 开启日志文件，获取文件描述符
- 编译和处理 Perl 脚本

2. **工作进程**    

由主进程生成，生成数量可以通过 Nginx 配置文件指定，正常情况下生存于主进程的整个生命周期：   

- 接收客户端请求
- 将请求依次送入各个功能模块进行过滤处理
- IO 调用，获取响应数据
- 与后端服务器通信，接收后端服务器处理结果
- 数据缓存，访问缓存索引、查询和调用缓存数据
- 发送请求结果，响应客户端请求
- 接收主程序指令，比如重启、升级和退出等指令    

3. **缓存索引重建及管理进程**   

Cache 模块主要由缓存索引重建（Cache Loader）和缓存索引管理（Cache Manager）两类进程完成工作。
缓存索引重建进程是在 Nginx 服务启动一段时间之后（默认是 1 分钟）由主进程生成，在缓存元数据重建
完成后就自动退出；缓存索引管理进程一般存在于主进程的整个生命周期，负责对缓存索引进行管理。   

缓存索引重建进程完成的主要工作是，根据本地磁盘上的缓存文件在内存中建立索引元数据库。该进程启动后，
对本地磁盘上存放缓存文件的目录结构进行扫描，检查内存中已有的缓存元数据是否正确，并更新索引元数据库。   

缓存索引管理进程主要负责在索引元数据更新完成后，对元数据是否过期做出判断。   

### 3.4.3 进程交互

Nginx 服务器在使用 Master-Worker 模型时，会涉及主进程与工作进程之间的交互以及工作进程之间的
交互。这两类交互都依赖于管道（channel）机制，交互的准备工作都是在工作进程生成时完成的。   

1. **Master-Worker交互**    

在主进程生成工作进程后，将新生成的工作进程加入到工作进程表中，并建立一个单向管道并将其传递给该工作
进程。该管道与普通的管道不同，它是由主进程指向工作进程的单向管道，包含了主进程向工作进程发出的指令、
工作进程PID、工作进程在工作进程表中的索引和必要的文件描述符等信息。   

主进程与外界通过信号机制进行通信，当接收到需要处理的信号时，它通过管道向相关的工作进程发送正确的
指令。每个工作进程都有能力捕获管道中可读事件，当管道中有可读事件时，工作进程从管道读取并解析指令。   

2. **Worker-Worker交互**    

原理与上面的类似，只有工作进程之间能够得到彼此的信息，建立管道，即可通信。由于工作进程之间是相互
隔离的，因此一个进程要想知道另一个进程的信息，只能通过主进程来设置了。   

为了达到工作进程之间交互的目的，主进程在生成工作进程后，在工作进程表中进行遍历，将该新进程的 ID
以及针对该进程建立的管道句柄传递给工作进程表中的其他进程，为工作进程之间的交互做准备。   

# 第 4 章 Nginx 服务器的高级配置

## 4.1 针对 IPv4 的内核 7 个参数的配置优化

我们可以将这些内核参数的值追加到 Linux 系统的 /etc/sysctl.conf 文件中，然后使用如下命令使
修改生效：   

```
#/sbin/sysctl -p
```   

这些常用的参数包括：    

1. net.core.netdev_max_backlog    

表示当每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许发送到队列的数据包的最大数目。
一般默认值为 128，Nginx 服务器中定义的 NGX_LISTEN_BACKLOG=511，我们可以将它调整一下：  

```
net.core.netdev_max_backlog = 262144
```   

2. net.core.somaxconn

调节系统同时发起的 TCP 连接数，一般默认值为 128：   

```
net.core.somaxconn = 262144
```   

3. net.ipv4.tcp_max_orphans

用于设定系统中最多允许存在多少 TCP 套接字不被关联到任何一个用户文件句柄上。如果超过这个数字，没有
与用户文件句柄关联的 TCP 套接字将立即被复位，同时给出警告信息。这个限制只是为了防止简单的 Dos 攻击：   

```
net.ipv4.tcp_max_orphans = 262144
```   

4. net.ipv4.tcp_max_syn_backlog

用于记录尚未收到的客户端确认信息的连接请求的最大值。   

```
net.ipv4.tcp_max_syn_backlog = 262144
```   

5. net.ipv4.tcp_timestamps

用于设置时间戳，避免序列号的卷绕。在一个 1Gb/s 的链路上，遇到以前用过的序列号的概率很大。当此值
赋值为 0 时，禁用对于 TCP 时间戳的设置。    

```
net.ipv4.tcp_timestamps = 0
```   

6. net.ipv4.tcp_sycack_retries

用于设置内核放弃 TCP 连接之前向客户端发送 SYN + ACK 包的数量。    

```
net.ipv4.tcp_synack_retries = 1
```   

7. net.ipv4.tcp_syn_retries

与上一个参数类似，设置内核放弃建立连接之前发送 SYN 包的数量，它的赋值和上个参数一样即可：   

```
net.ipv4.tcp_syn_retries = 1
```   

## 4.2 针对 CPU 的配置指令

在 Nginx 配置文件中，worker_processes 和 worker_cpu_affinity 可以针对多核 CPU 进行配置
优化。    

worker_cpu_affinity 用来为每个进程分配 CPU 的工作内核。指令的值是由几组二进制值表示的。其中，
每一组代表一个进程，每组中的每一位表示该进程使用 CPU 的情况，1 代表使用，0 代表不使用。二进制
位排列顺序和 CPU 的顺序是相反的。   

```
worker_cpu_affinity  0001 0100 1000 0010
```

## 4.3 与网络连接相关的配置的 4 个指令

1. **keepalive_timeout**    

用于设置 Nginx 服务器与客户端保持连接的超时时间。   

支持两个选项，中间用空格隔开。第一个选项指定客户端连接活动的超时时间，在这个时间之后，服务器会关闭
此连接。第二个选项可选，其指定了使用 Keep-Alive 消息头保持活动的有效时间，超过设置的时间后，
客户端就可以关闭连接，而不需要服务器关闭了。   

2. **send_timeout**    

设置服务器响应客户端的超时时间，这个超时时间仅针对两个客户端和服务器之间建立连接后，某次活动之间的
时间。如果这个时间后客户端没有任何活动，Nginx 会关闭连接。    

3. **client_header_buffer_size**    

服务器允许的客户端请求头部的缓冲区大小，默认 1KB，可根据系统分页大小来设置，分页大小可以根据以下
命令取得：   

```
#getconf PAGESIZE
```    

一般将大小设置为 4K：   

```
client_header_buffer_size 4K;
```   

4. **multi_accept**   

配置 Nginx 服务器是否尽可能多地接收客户端的网络连接请求，默认 off。   

