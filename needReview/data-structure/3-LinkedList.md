# 第 3 章 线性表

## 3.2 线性表的定义

线性表（List）：零个或多个数据元素的有序序列。     

若将线性表记为（a<sub>1</sub>, ..., a<sub>i - 1</sub>, a<sub>i</sub>, a<sub>i + 1</sub>,
..., a<sub>n</sub>），，则表中 a<sub>i - 1</sub> 领先 a<sub>i</sub>，a<sub>i</sub> 领先于
a<sub>i + 1</sub>，称a<sub> i - 1</sub> 是 a<sub>i</sub> 的直接前驱元素，a<sub>i + 1</sub> 是
a<sub>i</sub> 的直接后继元素。当 i=1,2,....,n-1 时，a<sub>i</sub>有且仅有一个直接后继，
当 i = 2,3,....,n 时，a<sub>i</sub>有且仅有一个直接前驱。     

线性表元素的个数 n 定义为线性表的长度，当 n = 0，称为空表。称 i 为数据元素 a<sub>i</sub> 在线性表
中的位序。      

## 3.3 线性表的抽象数据类型

```
ADT 线性表（List）

Data
  每个元素的类型均为 DataType

Operation
  InitList (* L): 初始化操作，建立一个空的线性表
  ListEmpty (L): 若线性表为空，返回 true, 否则返回 false
  ClearList (* L): 将线性表清空
  GetElem (L, i, * e): 将线性表 L 中的第 i 个位置元素值返回给 e
  LocateElem (L, e): 在线性表 L 中查找与给定值 e 相等的元素，如果查找成功，返回该元素在表中的
                     序号，否则返回 0 表示失败（感觉这里有问题，理论上第一个下标就是0，我觉得这里
                     改成 -1 比较好）
  ListInsert (* L, i, e): 在线性表中的第 i 个位置插入新元素 e
  ListDelete (* L, i, * e):  删除线性表 L 中的第 i 个位置元素，并用 e 返回其值
  ListLength (L): 返回线性表 L 的元素个数

endADT   
```     

## 3.4 线性表的顺序存储结构

### 3.4.1 顺序存储定义

线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。    

描述顺序存储结构需要三个属性：    

1. 存储空间的起始位置：即数组 data 的存储位置
2. 线性表的最大存储容量：数组长度 MaxSize
3. 线性表的当前长度：length     

## 3.5 顺序存储结构的插入与删除

### 3.5.1 获得元素操作

获取元素需要注意的错误情况是传入的元素位置不合法，或者表为空表。      

### 3.5.2 插入操作

插入算法的思路：    

+ 如果插入位置不合理，抛出一次
+ 如果线性表长度大于数组长度，则抛出异常或动态增加容量
+ 从最后一个元素开始向前变量到第 i 个位置，分别将它们都向后移动一个位置
+ 将要插入元素填入位置 i 处
+ 表长加1    

### 3.5.3 删除操作

删除算法的思路：    

+ 如果删除位置不合理，抛出异常
+ 取出删除元素
+ 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置
+ 表长减1     

### 3.5.4 线性表顺序存储结构的优缺点

优点：   

+ 无须为表示表中元素之间的逻辑关系增加额外的存储空间
+ 可以快速地存取表中任一位置的元素     

缺点：    

+ 插入和删除操作需要移动大量元素
+ 当线性表长度变化较大时，难以确定存储空间的容量
+ 造成存储空间的“碎片”      

## 3.6 线性表的链式存储结构

为了表示每个数据元素 a<sub>i</sub> 与其直接后继数据元素a<sub>i + 1</sub>之间的逻辑关系，对数据
元素a<sub>i</sub>来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息。我们把存储数据元素
信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称为指针或链。这两部分信息组成
数据元素a<sub>i</sub>的存储映像，称为结点。     

n个结点链结成一个链表，即为线性表的链式存储结构，因为此链表的每个结点中只包含一个指针域，所有叫做单链表。    

链表中的第一个结点的存储位置叫做头指针。也就是说指向链表第一个元素的那个指针。    

在单链表的第一个结点前附设一个结点，称为头结点，头结点的数据域可以不存储任何信息，也可以存储如线性表的
长度等附加信息，头结点的指针域存储指向第一个结点的指针。注意这时候头指针是指向头结点的。     



## 3.7 单链表的读取

获得链表的第 i 个数据的算法思路：    

1. 声明一个指针 p 指向链表的头结点，初始化j 从0开始；
2. 如果 i 的位置 小于等于 0，说明位置不合法，报错退出
2. 当 j< i 时，就遍历链表，让 p 的指针向后移动，不断指向下一个结点，j自增
3. 若到链表末尾还没找到元素，则i结点不存在，报错退出
4. 否则查找成功，返回结点 p 的数据      

## 3.13 循环链表

将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为
单循环链表，简称循环链表。     

循环链表解决了一个很麻烦的问题，即如何从当中一个结点出发，访问到链表的全部结点。      

在单链表中，我们有了头结点时，我们可以用 O(1) 的时间访问第一个结点，但对于要访问到最后一个结点，
却需要 O(n) 时间。    

如果我们改造一个单链表，不用头指针而用指向尾端结点的尾指针来表示循环链表，这时查找终端结点和头结点的
时间复杂度都为 O(1)。而且两个循环链表在用尾指针合并成一个表时也非常方便。     

双向链表和双向循环链表就不说了。      

