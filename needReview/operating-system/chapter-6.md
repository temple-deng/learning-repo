# 第6章 死锁

在计算机系统中有很多独占性的资源，在任一时刻它们都只能被一个进程使用。正因为如此，操作系统都具有授权
一个进程（临时）排他地访问一种资源的能力。    

在进程对设备、文件等取得了排他性访问权时，有可能会出现死锁。软硬件资源都有可能出现死锁。    


## 6.1 资源

我们把需要排他性使用的对象称为**资源**。资源可以是硬件设备（如蓝光驱动器）或是一组信息（如数据库中一个
加锁的记录）。简单来说，资源就是随着时间的推移，必须能获得、使用以及释放的任何东西。    

### 6.1.1 可抢占资源和不可抢占资源

资源分为两类：可抢占的和不可抢占的。**可抢占资源**可以从拥有它的进程中抢占而不产生任何副作用，存储器就是
一类可抢占的资源。    

**不可抢占资源**是指在不引起相关的计算失败的情况下，无法把它从占用它的进程处抢占过来。   

死锁与不可抢占资源有关，有关可抢占资源的潜在死锁通常可以通过在进程之间重新分配资源而化解。    

### 6.1.2 资源获取

以下面的代码为例，当进程 A 获取了资源1，进程 B 获取了资源2，两者都想要获取另外另一个资源，这时就产生
了死锁。    

```c
typeof int semaphore;
semaphore resource_1;
semaphore resource_2;

void process_A(void) {
  down(&resource_1);
  down(&resource_2);
  use_both_resource();
  up(&resource_2);
  up(&resource_1);
}

void process_B(void) {
  down(&resource_2);
  down(&resource_1);
  use_both_resource();
  up(&resource_1);
  up(&resource_2);
}
```     

## 6.2 死锁简介

死锁的规范定义如下：如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的时间，那么，
该进程集合就是死锁的。   

由于所有的进程都在等待，所有没有一个进程能引发可以唤醒该进程集合中其他进程的事件，这样，所有的进程
都只好无限期等待下去。在大多数情况下，每个进程所等待的事件是释放进程集合中其他进程所占有的资源，这种死锁
称为**资源死锁**，这是最常见的类型，但不是唯一的类型。    

### 6.2.1 资源死锁的条件

发生（资源）死锁的四个必要条件：    

1. 互斥条件。每个资源要么已经分配给了一个进程，要么就是可用的。
2. 占有和等待条件。已经得到了某个资源的进程可以再请求新的资源。
3. 不可抢占条件。已经分配给一个进程的资源不能强制性地被抢占，它只能被占用它的进程显式地释放。
4. 环路等待条件。死锁发生时，系统中一定有两个或两个以上的进程组成的一条环路，该环路中的每个进程都在
等待下一个进程所占有的资源。   

死锁发生时，以上四个条件一定是同时满足的。如果其中一个不成立，死锁就不会发生。   

那么问题就简单，只要破坏其中任意一个条件就可以解决死锁。    

### 6.2.2 死锁建模

有四种处理死锁的策略：   

1. 忽略该问题。很明显这种策略没什么卵用。
2. 检测死锁并恢复。显然这是最现实的选项。
3. 仔细对资源进行分配，动态地避免死锁。
4. 通过破坏引起死锁的四个必要条件之一，防止死锁的发生。这个也不错。     

## 6.3 鸵鸟算法

这个算法就是当死锁没发生，该干什么继续干什么。这明显会出问题。    

## 6.4 死锁检测和死锁恢复   

死锁检测的算法就不说了，看书吧。   

### 6.4.3 从死锁中恢复

+ **利用抢占恢复**    

略，就是直接抢咯，甚至可以人工干预。缺点很明显吧，可能会造成进程严重的错误，在解决死锁后如何恢复进程的
状态是个难题。    

+ **利用回滚恢复**     

如果系统设计人员按以及主机操作员了解到死锁有可能发生，他们就可以周期性地对进程进行**检查点检查**。
进程检查点检查就是将进程的状态写入一个文件以备以后重启。该检查点不仅包括存储映像，还包括了资源状态，即哪些资源分配给了该进程。     

一旦检测到死锁，就很容易发现需要哪些资源。为了进行恢复，要从一个较早的检查点上开始，这样拥有所需要
资源的进程会回滚到一个时间点，实际上，是将进程复位到一个更早的状态，那时它还没有取得所需的资源，接着
就把这个资源分配给一个死锁进程。如果复位后的进程试图重新获得对该资源的控制，它就必须一直等待该资源可用时为止。    

+ **通过杀死进程恢复**    

尴尬，这方法更过分。    

## 6.5 死锁避免

### 6.5.2 安全状态和不安全状态

安全状态和不安全状态的区别是：从安全状态出发，系统能够保证所有进程都能完成，而从不安全状态出发，就没有这样的保证。    

### 6.5.3 单个资源的银行家算法

银行家算法就是对每一个请求进行检查，检查如果满足这一请求是否会到达安全状态，若是则满足该请求，否则就
推迟这一请求。    

### 6.5.4 多个资源的银行家算法

略。    

## 6.6 死锁预防

死锁避免从本质上来说是不可能的，因为它需要获知未来的请求，而这些请求是不可知的。    

### 6.6.1 破坏互斥条件

破坏互斥条件的话就是假设资源不被一个进程所独占，这个的话倒是可能实现但比较难。    

### 6.6.2 破坏占用等待条件

禁止已持有资源的进程再等待其他资源。一种实现方法是规定所有进程在开始执行前请求所需的全部资源，如果全部
资源可用就将它们分配给这个进程，于是这个进程肯定能运行结束。如果有资源正被使用，那么就不进行分配，进程等待。     

这个方法的问题是很多进程直到运行时才知道它需要多少资源。实际上如果进程能够知道它需要多少资源，就可以使用
银行家算法。另外，这个方法对资源的利用率不是最优的。    

### 6.6.3 破坏不可抢占条件

略。这个方法也是可能的。   

### 6.6.4 破坏环路等待条件

略。    

## 6.7 其他问题

### 6.7.1 两阶段枷锁

虽然在一般情况下避免死锁和预防死锁并不是很有希望，但是在一些特殊的应用方面，有很多卓越的专用算法。   

常用的方法是**两阶段加锁**。在第一阶段，进程试图对所有所需的记录记性加锁，一次锁一个记录。如果第一阶段
加锁成功，就开始第二阶段，完成更新后释放锁。在第一阶段并没有做实际的工作。    

如果在第一阶段某个进程需要的记录已经被加锁，那么该进程释放它所有加锁的记录，然后重新开始第一阶段。   

这个方法有点类似前面破坏占用等待条件的情况，尽量先说明我要多少资源，如果资源不够，我就等会再执行，
不过这个的话只是重新执行第一阶段。在某些情况下这种重新执行也不可容忍的。    

### 6.7.2 通信死锁

另一种死锁发生在通信系统中（比如说网络），即两个或两个以上进程利用发送信息来通信时，一种普遍的
情形是进程 A 向进程 B 发送请求信息，然后阻塞直到 B 回复。假设请求信息丢失，A 将阻塞以等待回复，
而 B会阻塞等待一个向其发送命令的请求，因此发生死锁。    

这不是一个经典的资源死锁，A 没有占用 B 所需的资源，反之亦然。这种情况叫做**通信死锁**。通信死锁
是**协同同步**的异常情况。    

通信死锁不能通过对资源排序（因为没有）或者通过仔细地安排调度来避免。不过可以使用另外一种技术来中断通信
死锁：超时。这种方式其实也适用于资源死锁。     

### 6.7.3 活锁

在某些情况下，当进程意识到它不能获取到它所需的资源时，可能会礼貌地释放已经获取的资源，然后等待一会再次尝试。
理论上这是一种避免死锁的好方法，不过，如果有另外一个进程也这样做，双方还是可能同时陷入循环中，这种情况叫活锁。   

### 6.7.4 饥饿

这个好理解，假如有一些不合理的调度算法，导致某些进程迟迟不能获取到自己需要的资源，永远无法获得服务。    

