# 第10章 实例研究1：UNIX、Linux 和 Android

## 10.2 Linux 简介

### 10.2.2 到 Linux 的接口

操作系统的作用是控制硬件并且为其他程序提供系统调用接口。这些系统调用允许用户程序创立并管理进程、文件和
其他资源。   

程序通过把参数放入寄存器（有时是栈）来调用系统调用，并发出陷入指令从用户模式来切换到内核模式。由于
不能用 C 语言写一条陷入指令，因此系统提供了一个库，每个函数对应一个系统调用。这些函数是用汇编语言写的，
不过可以从 C 中调用。每一个函数首先将参数放到合适的地方，然后执行陷阱命令。由 POSIX 指定的是库接口，而不是
系统调用接口。    

Linux 系统具有三种不同的接口：真正的系统调用接口，库函数接口和由标准应用程序构成的接口。   

### 10.2.3 shell

当 shell 被启动时，它初始化自己，然后在屏幕上输出一个**提示符**，通常是一个百分号或者美元符号，并等待
用户输入命令行。    

等用户输入一个命令后，shell 提取其中的第一个字，这里的字指的是被空格或制表符分隔开的一连串字符。假定
这个字是将要运行程序小的程序名，搜索这个程序，如果找到了这个程序就运行它。然后，shell 会将自己
挂起直到该程序运行完毕，之后再尝试读入下一条命令。    

负责控制一个命令的操作或者指定一个可选值的参数称为**标志**（flag），习惯上由一个破折号标记。    

像 shell 这样的程序不一定非要通过终端（键盘和显示器）进行输入输出。当它启动时，它自动获得了对**标准输入**、
**标准输出**和**标准错误**文件进行访问的能力。正常情况下，上述三个文件都指向终端，因此标准的输入
是从键盘输入的，而标准输出或者标准错误是输出到显示器的。    

也可以对标准输入和输出进行重定向。对标准输入进行重定向的语法使用一个小于号（<）加上紧接的一个输入文件名。
类似的，标准输出可以通过一个大于号（>）进行重定向。    

可以把一系列 shell 命令放到一个文件中，然后将此文件作为shell 的输入来运行。第二个 shell 按照顺序
处理这些命令，和处理从键盘输入的命令一样。包含 shell 命令的文件为**shell脚本**。    

## 10.3 Linux 中的进程

由于 Linux是一个多道程序设计系统，因此系统中可能会有多个彼此之间相互独立的进程在同时运行。而且，
每一个用户可以同时开启多个进程。因此，在一个庞大的系统里，可能有成百个甚至上千个进程在同时运行。
事实上，在大多数单用户的工作站里，即使用户已经退出登录，仍然有很多后台进程，即**守护进程**在运行。
在系统启动的时候，这些守护进程就已经被 shell 脚本开启。    

**计划任务**（cron daemon）是一个典型的守护进程。它每分钟运行一次来检查是否有工作需要它完成。如果有
工作要做，它就会将之完成，然后进入休眠状态，知道下一次检查时刻来到。    

Linux 系统中的进程可以通过一种消息传递的方式进行通信。在两个进程之间，可以建立一个通道，一个进程向这个
通道里写入字节流，另一个进程从这个通道中读取字节流。这些通道称为**管道**。管道是同步的，因为如果
一个进程试图从一个空的管道中读取数据，这个进程就会被挂起直到管道中有可用的数据。    

除了管道这种方式，进程还可以通过另一种方式通信：软中断。一个进程可以给另一个进程发送**信号**。进程
可以告诉操作系统当信号到来时它们希望发生什么事件。相关的选择有忽略这个信号、抓取这个信号或者被信号杀死，终止
进程是处理信号的默认操作。如果一个进程希望获取所有发送给它的信号，它就必须指定一个信号处理函数。当信号
到达时，控制立即切换到信号处理函数。当信号处理函数结束并返回之后，控制像硬件 I/O 中断一样返回到陷入点处。
一个进程只可以给它所在**进程组**中的其他进程发送信号，这个进程组包括它的父进程（以及远祖进程）、兄弟
进程和子进程（以及后裔进程）。同时，一个进程可以利用系统调用给它所在的进程组中所有的成员发送信号。    

POSIX系统定义的信号见下表：    


信号 | 原因 
---------|----------
 SIGABRT | 进程中止且强迫核心转储 
 SIGALRM | 定时器超时
 SIGFPE | 出现浮点错误（比如，除0）
 SIGHUP | 进程所使用的电话线被挂断
 SIGILL | 用户按了 DEL 键中断了进程
 SIGQUIT | 用户按键要求核心转储
 SIGKILL | 杀死进程（不能被捕捉或忽略）
 SIGPIPE | 进程写入了无读者的管道
 SIGSEGV | 进程引用了非法的内存地址
 SIGTERM | 用户要求进程正常终止
 SIGUSR1 | 用于应用程序定义的目的
 SIGUSR2 | 用于应用程序定义的目的    

### 10.3.2 Linux 中进程管理相关的系统调用

Linux 主要的系统调用如表所示：   


系统调用 | 描述
----------|---------
 pid=fork() | 创建一个与父进程一样的子进程
 pid=waitpid(pid, &statloc, opts) | 等待子进程终止
 s=execve(name,argv,envp) | 替换进程的核心映像（就是进程的地址空间）
 exit(status) | 终止进程运行并返回状态值
 s=sigaction(sig, &act, &oldact) | 定义信号处理的动作
 s=sigreturn(&context) | 从信号返回
 s=sigprocmask(how, &set, &old) | 检查或更换信号掩码
 s=sigpending(set) | 获得阻塞信号集合
 s=sigsuspend(sigmask) | 替换信号掩码或挂起进程
 s=kill(pid, sig) | 发送信号到进程
 residual=alarm(seconds) | 设置定时器
 s=pause() | 挂起调用程序直到下一个信号出现   

exit 函数，进程在结束运行时会调用这个函数（这是自己调用吧）。它有一个参数，即退出状态（从0到255），
这个参数的值最后会传递给父进程调用 waitpid 函数的第二个参数——状态参数。状态参数的低字节部分包含
着结束状态，0意味着正常结束，其他值代表各种不同的错误。状态参数的高字节部分包含着子进程的退出状态。
低字节部分与信号有关。   

如果一个进程退出但是它的父进程并没有在等待它，这个进程进入**僵死状态**（zombie state）。最后当
父进程等待它时，这个进程才会结束。    

为了表明关心的信号有哪些，进程可以调用系统调用 sigaction。这个函数的第一个参数是希望捕获的信号。第二个
参数是一个指向结构的指针，在这个结构中包括一个指向信号处理函数的指针以及一些其他的位和标志。第三个参数
也是一个指向结构的指针，这个结构接收系统返回的当前正在进行的信号处理的相关信息，有可能以后这些信息需要恢复。    

当信号处理完毕之后，控制返回到断点处继续进行。    

sigaction 系统调用也可以用来忽略一个信号，或者恢复为一个杀死进程的缺省操作。    

系统调用 kill 允许一个进程给它相关的进程发送信号。kill 名字并不是很贴切，因为大多数进程发送信号给
别的进程只是为了信号能够被捕捉到。然而，如果一个信号没有被接收者捕获，那么接收者将被信号杀死。    

对于很多实时应用程序，在一段特定的时间间隔之后，一个进程必须被打断，系统会转去做一些其他的事情，比如说
在一个不可信信道上重新发送一个可能丢失的数据包。为了处理这种情况，系统提供了 alarm 系统调用。这个系统
调用的参数规定了一个以秒为单位的时间间隔，这个时间间隔过后，一个名为 SIGALRM 的信号会被发送给进程。
一个进程在某一个特定的时刻只能有唯一一个未处理的警报。如果 alarm 系统调用的参数为0，任何即将
发生的警报信号都会被取消。    

有时会发生这样的情况，在信号到来之前，进程无事可做。使用 pause 系统调用，它会通知 Linux 系统将本进程
挂起直到下一个信号到来。    

### 10.3.3 Linux 中进程与线程的实现

Linux 中每一个进程都有一个运行用户程序的用户模式，但是当它的某一个线程调用系统调用之后，进程会陷入内核模式
并且运行在内核上下文中，它将使用不同的内存映射并且拥有对所有机器资源的访问权。它还是同一个线程，但是现在
拥有更高的权限，同时拥有自己的内核堆栈以及内核程序计数器。这几点非常重要，因为一个系统调用可能会因为某些原因
陷入阻塞态，比如说，等待一个磁盘操作的完成。这时程序计数器和寄存器内容会被保存下来使得不久之后的线程可以在
内核模式下继续运行。    

在 Linux 系统内核中，进程通过数据结构 task_struct 被表示成**任务**。不像其他的操作系统会区分进程、
轻量级进程和线程，Linux 系统用任务的数据结构来表示所有的执行上下文。所以，一个单线程的进程只有一个
任务数据结构，而一个多线程的进程将为每一个用户级线程分配一个任务数据结构。    

对于每一个进程，一个类型为 task_struct 的**进程描述符**是始终存在于内存当中的。它包含了内核管理进程
所需的重要信息，如调度参数、已打开的文件描述符列表等。进程描述符从进程被创建开始就一直存在于内核堆栈当中。    

Linux 还用过**进程标识符**（PID）来区分进程。内核将所有进程的任务数据结构组织成一个双向链表。不需要遍历这个
链表来访问进程描述符，PID 可以直接被映射成进程任务数据结构所在的地址，从而立即访问进程的信息。   

进程描述符的信息可以大致归纳为以下几大类：   

1. **调度参数**。进程优先级，最近消耗的CPU时间，最近睡眠的时间。上面几项内容结合在一起决定了下一个要运行的进程
是哪一个。
2. **内存映射**。指向代码、数据、堆栈段或页表的指针。当进程不在内存当中，关于如何在磁盘上找到这些数据的信息也
被保存在这里。
3. **信号**。掩码显示了哪些信号被忽略、哪些信号需要被捕捉、哪些信号被暂时阻塞以及哪些信号在传递当中。
4. **机器寄存器**。当内核陷阱发生时，机器寄存器的内容会被保存。
5. **系统调用状态**。关于当前系统调用的信息，包括参数和返回值。
6. **文件描述符表**。当一个与文件描述符有关的系统调用被调用的时候，文件描述符作为索引在文件描述符表中定位相关
文件的 i 节点数据结构。
7. **统计数据**。指向记录用户、进程占用系统 CPU 时间的表的指针。一些系统还保存一个进程最多可以
占用CPU 的时间、进程可以拥有的最大堆栈空间、进程可以消耗的页面数。
8. **内核堆栈**。进程的内核部分可以使用的固定堆栈。
9. **其他**。当前进程状态。如果有的话，包括正在等待的事件、距离警报时钟超时的事件、PID、父进程的
PID 以及其他用户标识符、组标识符。    

创建一个新进程的机制非常简单。为子进程创建一个新的进程描述符和用户空间，然后从父进程复制大量的内容。
这个子进程被赋予一个 PID，并建立它的内存映射，同时它也被赋予了访问属于父进程文件的权限。     

当系统调用 fork 执行的时候，调用 fork 函数的进程陷入内核并且创建一个任务数据结构和其他相关的数据结构，
如内核堆栈和 thread_info 结构。这个结构位于进程堆栈栈底固定偏移量的地方，包含一些进程参数，以及进程描述符
的地址。注意个人感觉这个结构指的不是任务结构，而是一个用来保存相关数据指针和一些参数的一个数据结构。

进程描述符的主要内容根据父进程的进程描述符的值来填充。Linux 系统寻找一个可用的 PID，且该 PID 此刻未
被任何进程使用。更新进程标识符散列表的表项使之指向新的任务数据结构即可。    

理论上，现在就应该为子进程的数据段、堆栈段分配内存，并且对父进程的段进行复制，因为 fork 函数意味着父、子
进程之间不共享内存。其中如果代码段是只读的，可以复制也可以共享。然后，子进程就可以运行了。    

但是，复制内存的代价相当昂贵，所以现代 Linux 系统都使用了“欺骗”的手段来代替。它们赋予子进程属于它的页表，
但是这些页表都指向父进程的页面，同时把这些页面标记为只读。当进程（可以是父进程或子进程）试图向某一个页面
中写入数据的时候，它会收到写保护的错误。内核发现进程的写入行为之后，会为进程分配一个该页面的副本，并将
这个副本标记为可读，可写。通过这种方式，使得只有需要写入数据的页面才会被复制。    

### 10.3.4 Linux 中的调度

Linux 系统的线程是内核线程，所以 Linux 系统的调度是基于线程的，而不是基于进程的。    

为了进行调度，Linux 系统将进程区分为3类：    

1. 实时先入先出
2. 实时轮转进程
3. 分时    

实时先入先出线程具有最高优先级，它不会被其他线程抢占，除非那个一个刚刚准备好的、拥有更高优先级的实时先入先出进程。
实时轮转线程与实时先入先出线程基本相同，只是每个实时轮转线程都有一个时间量，时间到了之后就可以被抢占。
如果多个实时轮转线程都准备好了，每一个线程运行它的时间量所规定的时间，然后插入到实时轮转线程列表的
末尾。在系统内部，实时线程的优先级从0到99,0是实时线程的最高优先级，99是实时线程的最低优先级。    

传统的非实时线程形成单独的类（这个是不是就是分时进程啊，也没说清楚）并由单独的算法进行调度，这样可以使
非实时线程不与实时线程竞争资源。在系统内部，这些线程的优先级从100到139，也就是说，Linux 系统包含140
个不同的优先级（包括实时和非实时任务）。    

像大多数 UNIX 系统一样，Linux 系统给每个线程分配一个 nice 值（即优先级调节值）。默认值是0，但是可以通过
nice 系统调用来修改，修改值的范围从-20到+19,。这个值决定了线程的静态优先级。只有系统管理员可以要求
比普通服务更好的服务（意味着nice 函数参数值的范围从-20到-1）。    

接下来将讨论Linux 系统的两个调度算法。它们的内部与调度队列的设计密切相关，该调度队列是一个关键的数据结构，
可以通过调度器来跟踪系统中所有可运行的任务。    

**Linux O(1) 调度器**是历史上一个流行的 Linux 系统调度程序。命名这个名字是因为它能够在常数时间内
执行任务调度，例如从执行队列中选择一个任务或将一个任务加入到执行队列。在 O(1) 调度器里，调度队列被组织
成两个数组，一个是任务**正在活动**的数组，一个是任务**过期失效**的数组。每个数组都包含了140个链表头（那应该
是一个散列表吧），每个
链表具有不同优先级。链表头指向给定优先级的双向进程链表。调度的基本操作如下所述。   

调度器从正在活动数组中选择一个优先级最高的任务。如果这个任务的时间片（时间量）过期失效（个人感觉所谓的过期
失效，应该就是执行过了），就把它移入过期失效数组中（相当于把一个执行完时间片的进程放到过期数组中吧）。如果
这个任务阻塞了，比如说正在等待I/O事件，那么在它的时间片过期失效之前，一旦所等待的事发生，任务就可以
继续运行（那在它被阻塞的阶段，应该会换别的进程执行把），它将被放回到之前正在活动的数组中（难道阻塞的这段
时间，进程会被移到别处?），时间片根据它所消耗的 CPU 时间相应的减少。一旦它的时间片消耗殆尽，它也会放到过期失效数组中。当正在活动
数组中没有其他任务的了，调度器交换指针，使得正在活动数组变为过期失效数组，过期失效数组变为正在活动数组。    

不同的优先级被赋予不同的时间片长度，高优先级的进程拥有较长的时间片，例如，优先级100的任务可以得到800ms
的时间片，而优先级为139的任务只能得到5ms 的时间片。    

由于Linux 系统事先不知道一个任务究竟是 I/O 密集型还是 CPU 密集的，它只是依赖于连续保持的交互启发式方法。通过这种方法，
Linux 系统区分静态优先级和动态优先级。线程的动态优先级不断地被重新计算，其目的在于：（1）奖励互动进程，
（2）惩罚占用 CPU 的进程。在 Linux O(1) 调度器中，最高的优先级奖励是 -5，最高的优先级惩罚是 +5。    

还有一种调度器是**完全公平调度器**（Completely Fair Scheduler, CFS）。它是处理非实时任务的默认调度器。   

CFS 的主要思想是使用一颗红黑树作为调度队列的数据结构。根据任务在 CPU 上运行的时间长短而将其有序地排列在树中，
这种时间被称为虚拟运行时间。树中的每个节点对应于一个任务。左侧的子节点对应于在 CPU 上运行时间更少的
任务，因此左侧的任务会更早地被调度，右侧的子节点是那些迄今消耗 CPU 时间较多的任务，叶子节点在调度器不起任何作用。   

CFS 调度算法可以总结如下，该算法总是优先调度那些使用 CPU 时间最少的任务。通常是在树中最左边节点上的任务。
CFS 会周期性地根据任务已经运行的时间，递增它的虚拟运行时间值，并将这个值与树中当前最左节点的值进行比较，
如果正在运行的任务仍具有较小虚拟运行时间值，那么它将继续运行，否则，它将被插入红黑树的适当位置，并且
CPU 将执行新的最左边节点上的任务。    

考虑到任务有优先级的差异和“友好程度”，因而当一个任务在 CPU 上运行时，CFS 会改变该任务的虚拟运行
时间流逝的有效速率。对于优先级较低的任务，时间流逝更快，它的虚拟运行时间值也将增加的更快。    

调度器只考虑可以运行的任务，这些任务被放到适当的调度队列中。不可运行的任务和正在等待各种I/O 操作
或内核时间的任务被放到另一个数据结构当中，即**等待队列**。    

### 10.3.5 启动 Linux 系统

当计算机启动时，BIOS 加电自检（POST），并对硬件进行检测和初始化，这是因为操作系统的启动过程可能会依赖于
磁盘访问、屏幕、键盘等。接下来，启动磁盘的第一个扇区，即**主引导记录**（MBR），被读入到一个固定的
内存区域并执行。这个分区中含有一个很小的根程序（只有512字节），这个程序从启动设备中，比如 SATA 磁盘
或 SCSI 磁盘，调入一个名为**boot**的独立程序。boot将自身复制到高位地址的内存当中从而为操作系统
释放低地址的内存。    

复制完成后，boot 程序读取启动设备的根目录。为了达到这个目的，boot 程序必须能够理解文件系统和目录格式，
这个工作通常由引导程序，如**GRUB**（多系统启动管理器），来完成。其他流行的引导程序，如Inter 的LILO，
不依赖与任何特定的文件系统。相反，它们需要一个块映射图和低层地址，它们描述了物理扇区、磁头和磁道，可以
帮助找到相应的需要被加载的扇区。（所以这些找到的扇区中是存放的操作系统呢，还是文件系统）    

然后，boot 程序读入操作系统内核，并把控制交给内核。从这里开始，boot 程序完成了它的任务，系统内核开始运行。   

内核的启动代码使用汇编语言写成的，具有较高的机器依赖性。主要的工作包括创建内核堆栈、识别CPU类型、计算可用内存、禁用中断、
启用内存管理单元，最后调用 C语言写成的main 函数开始执行操作系统的主要部分。    

C 语言的代码也有相当多的初始化工作要做，但是这些工作更逻辑化。C语言代码开始的时候会分配一个消息缓冲区来
帮助调试启动出现的问题。随着初始化的工作进行，信息被写入消息缓冲区，这些信息与当前正在发生的事件相关，所以，
如果出现启动失败的情况，这些信息可以通过一个特殊的诊断程序调出来。可以把它看做是飞机的“黑匣子”。    

接下来，内核数据结构得到分配。大部分内核数据的大小是固定的，但是一少部分，如页面缓存和特殊的页表结构，
依赖于可用内存的大小。   

从这里开始，系统进行自动配置。使用描述何种设备可能存在配置文件，系统开始探测哪些设备是确实存在的。如果一个被
探测的设备给出了响应，这个设备就被加入到已连接设备表中。如果它没有响应，就假设它未连接或者直接忽略它。     

一旦所有的硬件都配置好了，接下来要做的事情就是细心地手动运行进程0，建立它的堆栈，运行它。进程0继续进行
初始化，做如下的工作：配置实时时钟，挂载根文件系统，创建 init 进程（进程1）和页面守护进程（进程2）。    

init 进程检测它的标志以确定它应该为单用户还是多用户服务。前一种情况，它调用 fork 函数创建一个shell 进程，
并且等待这个进程结束。后一种情况，它调用fork 函数创建一个运行系统初始化 shell脚本（即 /etc/rc）的进程，
这个进程可以进行文件系统一致性检测、挂载附加文件系统、开启守护进程等。然后这个进程从 /etc/ttys 中读取
数据，其中 /etc/ttys 列出了所有的终端和它们的属性。对于每一个启用的终端，这个进程调用 fork 函数创建一个
自身的副本，进行内部处理并运行一个名为 getty 的程序。   

getty 程序为每条连线设置传输速率和其他属性，然后在终端的屏幕上输出：   `login: `。等待用户从键盘键入用户名。
当提供了一个用户名后，getty 程序就结束了，登录程序 /bin/login 开始运行。login 程序要求输入密码，给密码
加密，并与保存在密码文件 /etc/passwd 中的加密密码进行对比。如果是正确的，login 程序以用户 shell 程序
替换自身，等待第一个命令。      

## 10.4 Linux 中的内存管理

### 10.4.1 基本概念

每个Linux 进程都有一个地址空间，逻辑上有三段组成：代码、数据和堆栈段。**代码段**包含了形成程序可执行
代码的机器指令。它是由编译器和汇编器把 C、C++ 或者其他程序源码转换成机器代码而产生的。通常，代码段
是只读的，代码段既不增长也不减少，总之不会发生改变。    

**数据段**包含了所有程序变量、字符串、数字和其他数据的存储。它有两部分，初始化数据和未初始化数据。
由于历史的原因，后者就是我们所知道的**BSS**（历史上称作符号起始块）。数据段的初始化部分包括编译器
常量和那些在程序启动时就需要一个初始值的变量。所有BSS部分中的变量在加载后被初始化为0。    


