# 第 4 章 文件系统

<!-- TOC -->

- [4.1 文件](#41-文件)
  - [4.1.1 文件命名](#411-文件命名)
  - [4.1.4 文件访问](#414-文件访问)
  - [4.1.5 文件属性](#415-文件属性)
- [4.2 目录](#42-目录)
  - [4.2.4 目录操作](#424-目录操作)
- [4.3 文件系统的实现](#43-文件系统的实现)
  - [4.3.1 文件系统布局](#431-文件系统布局)
  - [4.3.2 文件的实现](#432-文件的实现)
  - [4.3.3 目录的实现](#433-目录的实现)
  - [4.3.5 日志结构文件系统](#435-日志结构文件系统)
  - [4.3.6 日志文件系统](#436-日志文件系统)
  - [4.3.7 虚拟文件系统](#437-虚拟文件系统)
  - [4.4 文件系统管理和优化](#44-文件系统管理和优化)

<!-- /TOC -->

## 4.1 文件

### 4.1.1 文件命名

有些文件系统区分大小写，有点不区分，UNIX 属于前者，而MS-DOS 上使用的老的文件系统则不区分。老的
MS-DOS 使用的 FAT-16以及其扩展版的 FAT-32 应该都是不区分的。    

Windows 为文件的扩展名赋予了含义。用（或进程）可以在操作系统中注册扩展名，并且规定哪个程序“拥有”
该扩展名。当用户双击某个文件名时，“拥有”该文件扩展名的程序就启动并运行该文件。     

### 4.1.4 文件访问

早期操作系统只有一种文件访问方式：顺序访问。    

当用磁盘来存储文件时，可以不按顺序地读取文件中的字节或记录，或者按照关键字而不是位置来访问记录。这种能
够以任何次序读取其中字节或记录的文件称作随机访问文件。    

有两种方法可以指示从何处开始读取文件。一种是每次read操作都给出开始读文件的位置。另一种是用一个特殊的
seek 操作设置当前位置，在 seek 操作后，从这个当前位置顺序地开始读文件。UNIX 和 Windows 使用的是
后一种方法。     

### 4.1.5 文件属性

文件都有文件名和数据。另外所有操作系统还会保存其他与文件相关的信息，如文件创建的日期和时间、文件大小等。
这些附加信息称之为文件**属性**，或者叫**元数据**。文件的属性在不同系统中差别很大。    

## 4.2 目录

### 4.2.4 目录操作

不同系统中管理目录的系统调用的差别比管理文件的系统调用差别大，下面以 UNIX 为例给出一组调用的操作：    

1. create。创建目录
2. delete。删除目录，只有空目录可删除。只包含目录项"." 和 ".." 的目录被认为是空目录，这两个目录项
通常不能删除。
3. opendir。目录内容可被读取，与打开和读文件相同，在读目录前，必须打开目录。
4. closedir。关闭目录。
5. readdir。系统调用 readdir 返回打开目录的下一个目录项。
6. rename。
7. link。链接技术允许在多个目录中出现同一个文件。这个系统调用指定一个存在的文件和一个路径名，并建立
从该文件到路径所指名字的链接。这样，可以在多个目录中出现同一个文件。这种类型的链接增加了该文件 i-node
计数器的计数，称为硬链接。
8. unlink。删除目录项。如果被解决连接的文件只出现在一个目录中，则将它从文件系统中删除。如果它出现在多个目录
中，则只删除指定路径名的连接，依然保留其他路径名的链接。    

## 4.3 文件系统的实现

### 4.3.1 文件系统布局

文件系统存放在磁盘上。多数磁盘划分为一个或多个分区，每个分区中有一个独立的文件系统（划重点）。磁盘的
0号扇区称为**主引导记录**（Master Boot Record, MBR），用来引导计算机。在MBR 的结尾是分区表。该表
给出了每个分区的起始和结束地址。表中的一个分区被标记为活动分区。在计算机被引导时，BIOS 读入并执行
MBR。MBR 做的第一个件事是确定活动分区，读入它的第一个块，称为**引导块**（boot block），并执行之。
引导块中的程序将装载该分区中的操作系统。     

除了从引导块开始之外，磁盘分区的布局是随着文件系统的不同而变化的。文件系统经常包含如下的几个项目。    

+ **超级块**：包含文件系统的所有关键参数，在计算机启动时，或者在该文件系统首次使用时，超级块会被
读入内存。超级块中的典型信息包括：确定文件系统类型用的魔数、文件系统中块的数量以及其他重要的管理信息。
+ **空闲块的信息**
+ **i节点**
+ **根目录**
+ **文件和目录**     

### 4.3.2 文件的实现

文件存储实现的关键问题是记录各个文件分别用到了哪些磁盘块。不同的系统采用不同的方法：    

+ **连续分配**   

最简单的分配方案是把每个文件作为一连串连续数据块存放在磁盘上。在目录项中只需记录第一块的磁盘地址
和文件的块数即可。         

+ **链表分配**     

第二种方案是为每个文件构造磁盘块链表，每个块的第一个字作为指向下一块的指针，块的其他部分存放数据。在目录项
中，只需要存放第一个块的磁盘地址即可。     

+ **采用内存中的表进行链表分配**     

将每个磁盘块的指针字放到内存中的表上，内存中的这样一个表格称为**文件分配表**（File Allocation Table, FAT）。
那这样的话还是得事先就知道每个磁盘块的指针字，那这些指针字就得存在目录项中了把，相对来说，与上一种
方法相比并没有减少消耗的磁盘量吧，只是用内存加速以下读写速率。    

+ **i 节点**    

给每个文件赋予称为**i 节点**的数据结构，其中列出了文件属性和文件块的磁盘地址，只有在对应的文件打开时，其 i 节点
才在内存中。    

### 4.3.3 目录的实现

处理可变长度文件名字的一种方法是，使目录项自身都有固定长度，而将文件名放置在目录后面的堆中。这一方法
的优点是当一个文件目录项被移走后，另一个文件的目录项总是可以适合这个空隙。不过话说那文件名移除后该怎么办，
堆是会立刻压缩呢，还是保留空隙隔一段时间压缩一次。    

对于非常长的目录（这里应该是指里面文件特别多），线性查找一个文件名速度太慢。加快速度的一个方法是使用散列表。
用文件名进行散列。     

### 4.3.5 日志结构文件系统

促使设计**日志结构文件系统**（Log-structured File System, LFS）的主要原因是，CPU 的速度越来越快，
内存容量越来越大，同时磁盘高速缓存也迅速地增加。进而，不需要磁盘访问操作，就有可能满足直接来自文件系统
高速缓存的很大一部分只读请求。未来多数的磁盘访问是写操作。     

写操作往往是零碎的。出于这一原因，LFS 的设计者决定重新实现一种 UNIX 文件系统，该系统即使面对一个大部分
由零碎的随机写操作组成的任务，同样能够充分利用磁盘的带宽。其基本思想是将整个磁盘结构化为一个日志。每隔一段时间，
或是有特殊需要时，被缓冲在内存中的所有未决的写操作都被放到一个单独的段中，作为在日志末尾的一个邻接段写入磁盘。
这个单独的段可能会包括 i 节点、目录块、数据块或者都有。每一个段的开始都是该段的摘要，说明该段中
都包含有哪些内容。    

这种设计中，要在磁盘中找到一个 i 节点就比较麻烦了，为了找到 i 节点，必须要维护一个由 i节点编号索引组成的
i节点图。在这个图中的表项 i 指向磁盘中的第i个i节点。这个图保存在磁盘上，但是也保存在高速缓存中，大多数
情况下这个图的最常用部分还是在内存中。     

这样的话随着时间的推移，磁盘空间会被整个日志占满，而很多被删除的文件还在磁盘上占据着空间。为了解决这个问题，
LFS 有一个清理线程，该线程周期地扫描日志进行磁盘压缩。该线程首先读日志中的第一个段的摘要，检查有哪些i节点
和文件。然后该线程查看当前i节点图，判断该节点是否有效已经文件块是否在使用中。如果没有使用，则该信息被丢弃。如果
仍然使用，那么i节点和块就进入内存等待写回到下一段中，接着，原来的段被标记为空间，以便日志可以把它用来放新的
数据。     

### 4.3.6 日志文件系统

日志结构文件系统由于和现有的文件系统不匹配，所有没能广泛使用，不过其思想被其他文件系统借鉴。其基本思想
是保存一个用于记录系统下一步将要做什么的日志。这样当系统在完成它们即将完成的任务前崩溃时，重新启动后，
可以通过查看日志，获取崩溃前计划完成的任务，并完成它们。这样的文件系统称为**日志文件系统**。    

日志系统会将每次将要完成的动作写到一个日志项中，然后日志项被写入磁盘。只有当日志项已经被写入，不同的
操作才可以进行。当所有的操作成功完成后，擦除日志项。如果系统这时崩溃，系统恢复后，文件系统可以通过检查
日志来查看是不是有未完成的操作。如果有，可以重新运行所有未完成的操作。不过这里有东西没说明白啊，比如我
写入一个文件时，数据要不要保存在日志项中，保存的话，日志项会不会太大，不保存的话，崩溃后是无法恢复的把。    

### 4.3.7 虚拟文件系统

即使在同一个操作系统下，都可能会使用到很多不同文件系统。Windows 通过指定不同的盘符来处理这些不同
的文件系统，比如 "c:", "d:"。当一个进程打开一个文件，盘符是显式或者隐式存在的，所有 Windows 知道
向哪个文件系统传递请求，不需要尝试将不同类型文件系统整合为统一的模式。    

而UNIX 则做了这样的尝试，即将多种文件系统整合到一个统一的结构中。由于Sun公司之前的工作，绝大多数UNIX
操作系统都使用**虚拟文件系统**（Virtual File System, VFS）概念尝试将多种文件系统统一成一个有序的结构。
关键的思想是抽象出所有文件系统都共有的部分，并且将这部分代码放在单独的一层，该层调用底层的实际文件系统来具体管理
数据。    

所有和文件系统相关的系统调用在最初的处理上都指向虚拟文件系统。这些来自用户进程的调用，都是标准的POSIX 
系统调用，比如 open, read, write 等。因此，VFS 对用户进程有一个“上层”接口。同时，其对实际的文件系统还有
一个“下层”的接口，这个接口包含很多功能调用，这样VFS能使每一个文件系统完成任务。     

当系统启动时，根文件系统在 VFS 中注册。另外，当装载其他文件系统时，不管是在启动时还是在操作过程中，它们也必须在VFS 中
注册，当一个文件系统注册时，它做的最基本的工作就是提供一个包含VFS 所需要的函数地址的列表。    

### 4.4 文件系统管理和优化