# 第5章 输入 / 输出


<!-- TOC -->

- [5.1 I/O硬件原理](#51-io硬件原理)
  - [5.1.1 I/O 设备](#511-io-设备)
  - [5.1.2 设备控制器](#512-设备控制器)
  - [5.1.3 内存映射 I/O](#513-内存映射-io)
  - [5.1.4 直接存储器存取](#514-直接存储器存取)
  - [5.1.5 重温中断](#515-重温中断)
- [5.2 I/O 软件原理](#52-io-软件原理)
  - [5.2.1 I/O 软件的目标](#521-io-软件的目标)
  - [5.2.2 程序控制 I/O](#522-程序控制-io)
  - [5.2.3 中断驱动 I/O](#523-中断驱动-io)
  - [5.2.4 使用 DMA 的 I/O](#524-使用-dma-的-io)
- [5.3 I/O 软件层次](#53-io-软件层次)
  - [5.3.1 中断处理程序](#531-中断处理程序)
  - [5.3.2 设备驱动程序](#532-设备驱动程序)
  - [5.3.3 与设备无关的 I/O 软件](#533-与设备无关的-io-软件)
- [5.4 盘](#54-盘)
- [5.5 时钟](#55-时钟)
  - [5.5.1 时钟硬件](#551-时钟硬件)
  - [5.5.2 时钟软件](#552-时钟软件)

<!-- /TOC -->

除了提供抽象（例如，进程、地址空间和文件）以外，操作系统还要控制计算机的所有I/O设备。操作系统必须
向设备发送命令，捕捉中断，并处理设备的各种错误。它还应该在设备和系统的其他部分之间提供简单且易于
使用的接口。如果有可能，这个接口对于所有设备都应该是相同的，这就是所谓的设备无关性。     

## 5.1 I/O硬件原理

### 5.1.1 I/O 设备

I/O 设备大致可以分为两类：**块设备**和**字符设备**。块设备把信息存储在固定大小的块中，每个块有
自己的地址。所有传输以一个或多个完整的块为单位。块设备的基本特征是每个块都能独立于其他块而读写。     

字符设备以字符为单位发送或接受一个字符流。字符设备是不可寻址的，也没有任何寻道操作。    

### 5.1.2 设备控制器

I/O 设备一般由机械部件和电子部件两部分组成。通常可以将这两部分分开处理，以提供更加模块化和更加通用
的设计。电子部件称作**设备控制器**或**适配器**，可能是主板上的芯片，也可能是设备中的印刷电路板。机械部件则是设备本身。     

控制器卡上通常有一个连接器，通向设备本身的电缆可以插入到这个连接器中。很多控制器可以操作2个、4个甚至
8个相同的设备。     

控制器与设备之间的接口通常是一个很低层次的接口。例如，磁盘可以按每个磁道2000000个扇区，每个扇区
512字节进行格式化。然而，实际从驱动器出来的却是一个串行的位（比特）流，它以一个**前导符**开始，
接着是一个扇区中的4096位，最后是一个检验和，也称为**错误校正码**。    

控制器的任务是把串行的位流转换为字节块，并进行必要的错误校正工作。在证明字节块没有错误后，再将它复制到
主存中。    

### 5.1.3 内存映射 I/O

每个控制器有几个寄存器用来与 CPU 进行通信。通过写入这些寄存器，操作系统可以命令设备发送数据、接受数据、
开启或关闭，或者执行某些其他操作。通过读取这些寄存器，操作系统可以了解设备的状态，是否准备好接收一个新的命令。    

除了这些控制寄存器之外，许多设备还有一个操作系统可以读写的数据缓冲区。     

那么问题来了，CPU 如何与这些寄存器和缓冲区通信。有两种可选的方案，一种是每个寄存器被分配一个 I/O 端口
号，这是一个8位或16位的整数。所有 I/O 端口形成 I/O 端口空间，并且收到保护使得普通的用户程序不能对其
访问。使用一条特殊的 I/O 指令，例如 `IN REG, PORT`，CPU可以读取控制寄存器PORT 中的内容并将
结果存入到CPU寄存器 REG 中。早期计算机都是以这种方式运行的。    

第二个方案是将所有控制寄存器映射到内存空间中，每个控制寄存器被分配唯一的一个内存地址。并且不会有内存
分配这一地址。这样的系统称为**内存映射I/O**。另外还要一种混合的方案，即数据缓冲区采用内存映射I/O，
而控制寄存器则具有单独的端口。x86 采用这一体系结构。    

这些方案的具体工作流程是：当CPU 想要读一个字的时候，不论从内存中读入还是从 I/O 端口读入，它都要将需要的地址
放到总线上的地址线上，然后在总线的一条控制线上置起一个 READ 信号。还要用到第二条信号线来表明需要的是
I/O 空间还是内存空间，如果是内存空间，内存将响应请求。如果是 I/O 空间，I/O 设备将响应请求。如果只有内存
空间，那么每个内存模块和每个I/O 设备都将地址线和它所服务的地址范围进行比较，如果地址落在这一范围
之内，它就会响应请求。    

两种方案有各自的优缺点，映射的有点有：不需要用汇编来调用特殊的I/O 指令，所以驱动可以用C写，不需要额外
的保护方案防止用户访问I/O 设备。缺点是当前的计算机会使用高速缓存，这些缓存对I/O 设备的缓存是灾难性的。而且
由于只存在内存地址，所以在查找到底是内存地址还是I/O 地址时会很麻烦。    

### 5.1.4 直接存储器存取

只有硬件有 DMA 控制器时操作系统才能使用 DMA，有时DMA 控制器集成到I/O 设备控制器之中，不过更加普遍的
是只在主板上有一个 DMA 控制器，由它调控多个设备的数据传送。    

无论 DMA 控制器在物理上处于什么地方，它都能够独立于 CPU 访问系统总线，它包含若干个可以被 CPU 读写
的寄存器，其中包含一个内存地址寄存器、一个字节计数寄存器和一个或多个控制寄存器。控制寄存器指定要使用的 I/O
端口，传送方向、传送单位（每次一个字节或每次一个字）以及在一次突发传送中要传送的字节数。    

以读磁盘为例，解释以下 DMA 的工作原理。首先，CPU 通过设置 DMA 控制器的寄存器对它进行编程，所以 DMA
控制器知道将上面数据传送到什么地方（第1步）。DMA 控制器还要向磁盘控制器发出一个命令，通知它从磁盘读数据到其内部
的缓冲区中，并且对校验和进行校验。   

DMA 控制器通过在总线上发出一个读请求到磁盘控制器而发起 DMA 传送（第2步）。要写在内存的地址在总线
的地址线上，于是在一个标准总线周期内，磁盘将数据写入到内存中（第3步），之后，磁盘控制器在总线上发出一个应答
信号到 DMA（第4步），DMA 步增写入的内存地址，步减写入的字节数，重复2~4步直到写入所有字节。这时，
DMA 将中断 CPU 通知其传送完成。    

DMA 控制器也有简单和复杂之分，前面提到的是最简单，比较复杂一点的有多组寄存器，可以一次处理多路传送。    

许多总线能够以两种模式操作：每次一字模式和块模式。某些 DMA 控制器也能够以这两种模式操作。在前一个模式中，
操作如上所述：DMA 控制器请求传送一个字并且得到这个字，如果 CPU 也想使用总线，必须等待，这一机制称为**周期窃取**，
轻微地延迟 CPU。在块模式中，DMA 控制器通知设备获取总线，发起一连串的传送，然后释放总线，这一操作形式
称为**突发模式**，缺点很明显，长期占用总线会阻塞 CPU 和其他设备。    

但我们之前使用的是**飞越模式**，DMA 让设备控制器将数据直接传送到内存，上面的第一种模式是 DMA 先获取
到数据然后再传送给内存，这样会花费两个总线周期，但是更灵活。    

所以也就是说 DMA 一共有3种工作模式。    

### 5.1.5 重温中断

在硬件层面，中断的工作如下。当一个 I/O 设备完成交给它的工作时，它就产生一个中断，它通过在分配给它的一条总线信号线
上置起信号产生中断，该信号被主板上的中断控制器芯片检测到，由中断控制器芯片决定做什么。    

如果没有其他中断悬而未决，中断控制器将立刻对中断进行处理。如果有另一个中断正在处理中，或者另一个设备
在总线上具有更高优先级的一条中断请求线上同时发出中断请求，该设备将暂时不被理睬。在这种情况下，该设备
将继续在总线上置起中断信号，直到得到 CPU 服务。    

为了处理中断，中断控制器在地址线上放置一个数字表明哪个设备需要关注，并且置起一个中断 CPU 的信号。   

中断信号导致 CPU 停止当前正在做的工作并且开始做其他的事情。地址线上的数字被用来指向一个称为中断
向量的表格的索引，以便读取一个新的程序计数器。这一程序计数器指向相应的中断服务过程的开始。   

中断服务开始运行后，它立刻通过将一个确定的值写到中断控制器的某个 I/O 端口来对中断做出应答。这一应答告诉
中断控制器可以自由地发出另一个中断。通过让 CPU 延迟这一应答直到它准备好处理下一个中断，就可以避免与多个
几乎同时发生的中断相牵涉的竞争状态。    

在开始中断服务前，必须要将当前进程的运行状态保存下来，这些数据保存在哪是个问题，可以在进程的堆栈中，也可能
是内核的堆栈中，但都有一些问题。     

由于现代 CPU 的流水线设计和超标量CPU（就是取指、解码、执行分成3个单元以及多核 CPU 咯），在保存时如何
保存当前进程的状态是一个大问题，因为你很难确定执行了哪些指令执行了哪些没有执行，流水线
比如说3个单元速度不一致，那么可能3个单元中的指令有重叠，那当前指令的执行与否就很难判断（流水线还好把，多核就比较惨了）。    

将机器留在一个明确状态的中断称为**精确中断**。精确中断具有4个特性：     

1. PC（程序计数器）保存在一个已知的地方
2. PC 所指向的命令之前的所有指令已经完全执行
3. PC 所指向的命令之后的所有指令都没有执行
4. PC 所指向的指令的执行状态是已知的     

## 5.2 I/O 软件原理

### 5.2.1 I/O 软件的目标

第一个目标是**设备独立性**，即软件可以访问任意的 I/O 设备而无需事先指定设备。     

第二个是**统一命名**，一个文件或一个设备的名字应该是一个简单的字符串或一个整数，它不应依赖于设备。所有设备
和文件都采用相同的方式——路径名进行寻址。    

第三个是**错误处理**，设备驱动程序应该能够处理一些硬件解决不了的问题。    

第四个是**同步（即阻塞）**和**异步（即中断驱动）**传输。    

第五个是**缓冲**，数据离开一个设备之后通常不能直接存放到其最终的目的地。     

第六个是共享设备和独占设备的问题。    


### 5.2.2 程序控制 I/O   

I/O 可以采用三种不同的方式来实现，即程序控制I/O，中断驱动I/O和使用DMA的I/O，最简单的形式就是让
CPU 做全部工作，即**程序控制I/O**。    

以向打印机输出一段要打印的字符为例说明程序控制I/O的流程，首选操作系统将字符串数据复制到内核空间，
然后检查打印机当前是否可用，如果不可用就一直等到其可用，如果可用，将第一个字符输出到打印机的寄存器中。
之后操作系统继续轮询检查打印机是否准备好了接受另一个字符，直到所有字符打印完成，控制返回到用户进程。
在这种情况下，CPU 要不断查询设备以了解它是否就绪准备接收另一个字符。这一行为进程称为**轮询**或**忙等待**。    

缺点很明显，一直占据 CPU，浪费时间。    

### 5.2.3 中断驱动 I/O

这一种的话 CPU 在将数据复制内核空间后会查询打印机的状态，不管可不可用 CPU 会在处理后运行调度程序
执行下一个进程，而每次打印机准备好接收下一个字符时就发出一个中断，然后CPU 暂停当前进程开始处理中断。     

### 5.2.4 使用 DMA 的 I/O

这一种的话无非是让 DMA 来代替 CPU 一直给打印机提供字符。     

## 5.3 I/O 软件层次

I/O 软件通常组成四个层次。    


用户级I/O 软件（应该就是普通的应用程序了） |
---------|
与设备无关的操作系统软件 |
设备驱动程序 |
中断处理程序 |
硬件 |     

### 5.3.1 中断处理程序

当中断发生时，中断处理程序将做它必须要做的全部工作以便对中断进行处理，然后，它可以将启动中断的驱动程序
解除阻塞，中断的最终结果是使先前被阻塞的驱动程序现在能够继续运行。    

然而现实并没有这么简单，操作系统还有很多其他要做的工作，下面的一系列步骤简单介绍了这些工作，这些步骤在硬件
中断完成之后必须在软件中执行的（也就是CPU 接受中断控制器芯片发起的中断信号，并拿到中断向量地址吧，这个地址
上就是中断处理程序）。

1. 保存没有被中断硬件保存的所有寄存器。
2. 为中断服务过程设置上下午，可能包括设置TLB、MMU和页表。
3. 为中断服务过程设置堆栈。
4. 应答中断控制器，如果不存在集中的中断控制器，则再次开放中断。
5. 将寄存器从它们被保存的地方（可能是某个堆栈）复制到进程表中。
6. 运行中断服务过程，从发出中断的设备控制器的寄存器中提取信息。
7. 选择下一次运行的哪个进程，如果中断导致某个被阻塞的高优先级进程变为就绪，则可能选择它现在就运行。（这里其实中断可以说是
就处理完了吧）
8. 为下一次要运行的进程设置 MMU 上下文。也许还需要设置某个 TLB。
9. 装入新进程的寄存器，包括其 PSW。
10. 开始运行新进程。     

### 5.3.2 设备驱动程序

每个设备驱动程序通常处理一种类型的设备，或者至多处理一类紧密相关的设备，不过有些时候，极其不同的设备却
基于相同的底层技术，例如 USB。此处的技巧是 USB 驱动程序通常是堆栈式的，就像网络中的 TCP/IP 栈。    

为了访问设备的硬件（意味着访问设备控制器的寄存器），设备驱动程序通常必须是操作系统内核的一部分，至少对
目前的体系结构是如此。    

因为操作系统的设计者知道由外人编写的驱动程序代码片断将被安装在操作系统的内部，所以需要一个体系结构来允许
这样的安装。这意味着要有一个定义明确的模型，规定驱动程序做什么事情以及如何与操作系统的其余部分相互作用。   

大多数操作系统都定义了一个所有块都必须支持的标准接口，并且还定义了另一个所有字符设备都必须支持的标准接口。这些接口
由许多过程组成，操作系统的其余部分可以调用它们让驱动程序工作。    

### 5.3.3 与设备无关的 I/O 软件   

虽然 I/O 软件中有一些是设备特定的，但是其他部分 I/O 软件是与设备无关的。设备驱动程序和与设备无关的软件
之间确切界限依赖于具体系统（和设备），因为对于一些本来应按照与设备无关方式实现的功能，出于效率和其他原因，
实际上是由驱动程序来实现的。表中所示的功能典型地由与设备无关的软件实现。    


设备驱动程序的统一接口 |
---------|
 缓冲 |
 错误报告 |
 分配与释放专用设备 |
 提供与设备无关的块大小 |    


+ **设备驱动程序的统一接口**    

在为所有类似的驱动程序设计相同接口的方法中，对于每一种设备类型，例如磁盘和打印机，操作系统定义一组
驱动程序必须支持的函数。驱动程序通常包含一张表格，这张表格具有针对这些函数指向驱动程序自身的指针。当驱动程序
装载时，操作系统记录下这张函数指针表的地址，所以当操作系统需要调用一个函数时，它可以通过这张表格发出
间接调用。     

+ **缓冲**    

在内核空间创建两个缓冲区并且让中断处理程序将字符放到这两个缓冲区中，当第一个缓冲区填满后，将包含用户缓冲
区的页面调入内存，将内核缓冲区的内容复制到用户缓冲区，在这段时间中，使用第二个缓冲区缓冲数据，这种
缓冲模式称为**双缓冲**。    

缓冲的另一种形式是**循环缓冲区**。它由一个内存区域和两个指针组成，一个指针指向下一个空闲的字，新的数据
可以放置到此处。另一个指针指向缓冲区中数据的第一个字，该字尚未被取走。在许多情况下，当添加数据时，硬件将
推进第一个指针，而操作系统在取走并处理完数据时推进第二个指针。两个指针都是环绕的，当它们到达顶部时
将回到底部。    

剩下的先略了。     

## 5.4 盘

略。    

## 5.5 时钟

时钟又称为定时器，由于各种各样的原因决定了它对于任何多道程序设计系统的操作都是至关重要的。时钟负责
维护时间，并且防止一个进程垄断 CPU，此外还有其他的功能。    

### 5.5.1 时钟硬件

在计算机里通常使用两种类型的时钟，这两种类型的时钟与人们使用的钟表和手表有相当大的差异。比较简单的时钟被连接
到110V 或 220v 的电源线上，这样每个电压周期产生一个中断，频率是50Hz 或 60Hz。这些时候过去曾经占据统治
地位，但是如今非常罕见。   

另一种类型的时钟由三个部件构成：晶体振荡器、计数器和存储寄存器。当把一个石英晶体适当地切割并且安装在
一定的电压之下时，它就可以产生非常精确的周期性信号，典型的频率范围是几百兆赫兹，具体的频率值与所选晶体有关。
使用电子器件可以将这一基础信号乘以一个小的整数来获得高达1000MHz 甚至更高的频率（神奇）。在任何一台
计算机都可以找到至少一个这样的电路，它给计算机的各种电路提供同步信号。该信号被送到计数器，使其递减
计数至0。当计数器为0时，产生一个 CPU 中断。    

可编程时钟通常有几种操作模式。在**一次完成模式**下，当时钟启动时，它把存储寄存器的值复制到计数器中，
然后，来自晶体的每一个脉冲使计数器减1.当计数器变为0时，产生一个中断，并停止工作，知道软件再一次显示地
启动它。在**方波模式下**，当计数器变为0并且产生中断之后，存储寄存器的值自动复制到计数器中，并且整个过程
无限期地再次重复下去。这些周期性的中断称为**时钟滴答**（clock tick）。    

为了防止计算机的电源被切断时丢失当前时间，大多数计算机有一个电池供电的备份时钟。     

### 5.5.2 时钟软件

时钟硬件所做的全部工作是根据已知的时间间隔产生中断。涉及时间的其他所有工作都必须由软件——时钟驱动程序完成。
时钟驱动程序的确切任务因操作系统而异，但通常包括下面的大多数任务：   

1. 维护日时间
2. 防止进程超时运行
3. 对 CPU 的使用情况记账
4. 处理用户进程提出的 alarm 系统调用
5. 为系统本身的各个部分提供监视定时器
6. 完成概要剖析、监视和统计信息收集    

