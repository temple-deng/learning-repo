# 第 1 章 引论

多数计算机有两种运行模式： 内核态和用户态。软件中最基础的部分是操作系统，它运行在内核态（也称为管态、核心
态）。在这个模式中，操作系统具有对所有硬件的完全访问权，可以执行机器能够运行的任何指令。软件的其余部分
则运行在用户态下。在用户态下，只使用了机器指令中的一个子集。特别地，那么会影响机器的控制或可进行 I/O 操作
的指令，在用户态中的程序里是禁止的。   

## 1.1 什么是操作系统

操作系统有两个基本上独立的任务，即为应用程序员提供一个资源集的清晰抽象，并管理这个硬件资源，而不仅仅是一堆
硬件。    

### 1.1.1 作为扩展机器的操作系统

在机器语言一级上，多数计算机的体系结构是很原始的，以 SATA 硬盘为例，多数程序员是使用一些叫做硬盘
驱动的软件来与硬件交互。这类软件提供了读写硬盘块的接口，而不用深入细节。   

但是即使在这个层面，对于大多数应用来说还是太底层了，因此，所有的操作系统都提供使用硬盘的又一层抽象：文件。    

### 1.1.2 作为资源管理者的操作系统

把操作系统看做向应用程序提供基本抽象的概念，是一种自顶向下的观点。按照另一种自底向上的观点，操作系统
则用来管理一个复杂系统的各个部分。现代计算机包含处理器、存储器、磁盘、鼠标等许多设备。从这个角度看，
操作系统的任务是在相互竞争的程序之间有序地控制对处理器、存储器以及其他I/O接口设备的分配。    

## 1.3 计算机硬件简介

### 1.3.1 处理器

CPU 从内存中取出指令并执行之。在每个 CPU 基本周期中，首先从内存中取出指令，解码以确定其类型和操作数，
接着执行之，然后取指、解码并执行下一条命令。   

由于访问内存得到指令或者数据的时间要比执行指令花费的时间长的多，因此，所有的 CPU 内都有一些用来保存关键
变量和临时数据的寄存器。    

除了用来保存变量和临时结构的通用寄存器以外，多数计算机还有一些对程序员可见的专用寄存器。其中之一是
**程序计数器**，它保存了将要取出的下一条指令的内存地址。在指令取出之后，程序计数器就被更新以便指向
后继的指令。  

另一个寄存器是**堆栈指针**，它指向内存中当前栈的顶端，该栈包含了每个执行过程的栈帧。一个过程中的
栈帧中保存了有关的输入参数、局部变量以及那些没有保存在寄存器中的临时变量。感觉栈帧有点像程序中进入
一个局部作用域一样，比如在 JS 中函数调用进入一个 Execute Context。       

另一个寄存器是**程序状态字**（Program Status Word, PSW）。这个寄存器包含了条件码位、CPU 优先级、
模式（用户态还是内核态），以及其他各种控制位。    

在时间多路复用CPU中，操作系统经常会中止正在运行某个程序并启动（或再启动）另一个程序。每次停止一个运行着
的程序时，操作系统必须保存所有的寄存器值，这样在稍后该程序被再次运行时，可以把这些寄存器重新装入。（应该是
保存在进程表中了）     

超标量 CPU 的话貌似既不是指多核 CPU 也不是指多线程 CPU，应该是这样的 CPU 中可能有多个执行单元。    


为了从操作系统中获得服务，用户程序必须使用**系统调用**以陷入内核并调用操作系统。**TRAP**指令把用户态
切换成内核态，并启用操作系统（也就说，在执行系统调用过程中，是操作系统掌握了控制权对吧？）当有关工作
完成之后，在系统调用后面的指令把控制权返回给用户程序。     

多线程或者超线程 CPU 允许保持两个不同的线程状态，然后在纳秒级别的时间尺度内来回切换，也就是说并不是多线程
并行运行，只是提供了快速的线程上下文切换。     

### 1.3.2 存储器

存储器系统的顶层是 CPU 中的寄存器，它们用与 CPU 相同的材料制成，所以和 CPU 一样快。显然，访问它们
是没有时延的（这么牛逼的嘛），其典型的存储容量是，在 32位 CPU为 32 × 32位，在 64位 CPU为 64 × 64，也
就是 512B 咯。    

下一层是高速缓存，被分割成高速缓存行，典型大小为64字节，地址0至63对应高速缓存行0，地址64到127对应
高速缓存行1，依次类推。高速缓存命中通常需要两个时钟周期，如果未命中就要访问内存了。    

多数现代 CPU 设计了两个缓存。第一级或称为 L1 缓存总是在 CPU 中，通常用来将已解码的指令调入 CPU 的
执行引擎。典型的 L1 缓存大小为 16KB，另外往往还设计有二级缓存，称为 L2 缓存。L1 和 L2 缓存之间
的差别在于时序。对 L1 缓存的访问，不存在任何时延；而对 L2 缓存的访问则会延时1或2个时钟周期。（话说这里
的缓存和上面的高速缓存难道不是一个东西么，为什么介绍处处都不一样，有待考究）       

ROM 在工厂中就被编程完毕，然后再也不能被修改。   

EEPROM（电可擦除可编程ROM） 和闪存也是非易失性的，但是与 ROM 相反，它们可以擦除和重写。    

还有一类存储器是 CMOS，它是易失性的。许多计算机利用 CMOS 存储器保持当前时间和日期。CMOS 存储器和递增时间
的时钟电路由一块小电池驱动。CMOS 还可以保存配置参数。    

### 1.3.4 I/O 设备

I/O 设备一般包括两个部分：设备控制器和设备本身。控制器是插在电路板上的一块芯片或一组芯片，这块电路板物理地
控制设备。它从操作系统接受命令，例如从设备读数据，并且完成数据的处理。     


I/O 设备的另一个部分就是实际设备的自身。设备本身有个相对简单的接口，这是因为接口即不能做很多工作，又已经
被标准化了。例如，标准化后任何一个 SATA 磁盘控制器就可以适配任一种SATA 磁盘。   

每类设备控制器都是不同的，所以，需要不同的软件进行控制。专门与控制器对话，发出命令并接收响应的软件，称为设备
驱动程序。每个控制器厂家必须为所支持的操作系统提供相应的设备驱动程序。为了能够使用设备驱动程序，必须把
驱动程序装入到操作系统中。   

也就是说通常应用程序和操作系统打交道，然后操作系统和驱动打交道，驱动再去操作控制器，控制器再去和硬件提供的
接口对话。    

要将设备驱动程序装入操作系统，有三个途径。第一个途径是将内核与设备驱动程序重新链接，然后重启系统。许多 UNIX 系统
以这种方式工作。第二个途径是在一个操作系统文件中设置一个入口，并通知该文件需要一个设备驱动程序，然后重启系统。重启
时操作系统会去寻找所需的设备驱动程序并装载之。Windows 就是这种方式。第三种途径事实，操作系统能够在运行时接受
新的设备驱动程序并立即安好，无须重启，热插拔设备，诸如 USB 都需要动态可装载设备驱动程序。     

每个设备控制器都有少量用于通信的寄存器。例如，一个最小的磁盘控制器也会有用于指定磁盘地址、内存地址、扇区计数和方向
（读或写）的寄存器。要激活控制器，设备驱动程序从操作系统获得一条命令，然后翻译成对应的值，并写进设备寄存器中。
所有设备寄存器的集合构成了 I/O 端口空间。   

在有些计算机中，设备寄存器被映射到操作系统的地址空间，这样，它们就可以像普通存储字一样读出和写入。在
这种计算机中，不需要专门的I/O指令。在另外的一些计算机中，设备寄存器被放入一个专门的I/O端口空间中。
在这些机器中，提供在内核态中可使用的专门**IN**和**OUT**指令，供设备驱动程序读写这些寄存器用。    

实现输入和输出方式有三种。在最简单的方式中，用户程序发出一个系统调用，内核将其翻译成一个对应设备驱动程序
的过程调用。然后设备驱动程序启动I/O并在一个连续不断的循环中检查该设备，看设备是否完成了工作。当 I/O 结束
后，设备驱动程序把数据送到指定的地方并返回。然后操作系统将控制权返回给调用者。这种方式称为**忙等待**，其
缺点是要占据 CPU，CPU 一直轮询设备知道 I/O 操作完成。    

第二种方式是设备驱动程序启动设备并且让该设备在操作完成时发出一个中断。设备驱动程序在这个时刻返回。操作系统
接着在需要时阻塞调用者并安排其他工作进行。     

一旦 CPU 决定取中断，通常程序计数器和 PSW 就被压入当前堆栈中，并且 CPU 被切换到用户态。设备编号（由中断
控制器放到总线上）可以成为部分内存的一个引用，用于寻找该设备中断处理程序的地址。这部分内存称为**中断向量**。当中断处理程序（中断设备的设备驱动程序的一部分）开始后，它取走已入栈的程序计算器和PSW，并保存之，然后查询设备的状态。    

第三种方式是，为 I/O 使用一种特殊的**直接存储器访问**（DMA）芯片，它可以控制在内存和某些控制器之间
的位流，无须 CPU 的干预。CPU 对 DMA 芯片进行设置，接着启动 DMA。当 DMA 芯片完成时，它引发一个中断，其处理
方式同上。   

## 1.5 操作系统概念

### 1.5.1 进程

进程本质上是一个正在执行的一个程序。与每个进程相关的是**地址空间**，这是从某个最小值的存储位置到某个
最大值的存储位置的列表。在这个地址空间中，进程可以进行读写。该地址空间中存放有可执行程序、程序的数据和堆栈。
与每个进程有关的还有资源集，通常包括寄存器、打开的文件清单、突出的报警、有关进程清单，以及运行该程序
所需要的所有其他信息。在操作系统中，与一个进程有关的所有信息，除了该进程自身地址空间的内容以外，均放在操作系统
的一张表中，称为**进程表**，进程表是数组（或链表）结构，当前存在的每个进程都要占用其中的一项。    

### 1.5.3 文件

每个进程有一个**工作目录**。    

在读写文件之前，首先要打开文件，检查其访问权限。若权限许可，系统将返回一个小整数，称作**文件描述符**，
供后续操作使用。若禁止访问，系统则放回一个错误码。    

在 UNIX 中另外的总要概念是**特殊文件**，提供特殊文件是为了使 I/O 设备看起来像文件一般。这样，就像
使用系统调用读写文件一样，I/O 设备也可以通过同样的系统进行读写。有两类特殊文件：**块特殊文件**和**字符特殊文件**。
块特殊文件指那些可随机读取的块组成的设备，如磁盘。字符特殊文件用于打印机和其他接收或输出字符流的设备。    

**管道**是一类虚文件，它可连接两个进程。    

## 1.6 系统调用

任何单 CPU 计算机一次只能执行一条指令。如果一个进程正在用户态运行一个用户程序，并且需要一个系统服务，
比如从一个文件读数据，那么它必须执行一个陷阱或系统调用指令，将控制转移到操作系统。操作系统接着通过参数检查
找出所需要的调用进程。然后，它执行系统调用，并把控制返回给在系统调用后面跟随着的指令。    

以 read 系统调用为例，说明一下系统调用的步骤。用户程序在调用 read 后，程序将参数压进堆栈（1~3步）。接着
调用 read 库（第4步）。   

在可能是由汇编语言写成的库过程中，一般把系统调用的编号放在操作系统所期望的地方，如寄存器中（第5步）。这里系统
调度的编号应该是写在库中的，由调用库来执行该调用，注意库代码很可能是由汇编写成的，而且是非常依赖机器的，也就是
说不同的机器的库的实现可能是不同的，不过这些库应该是由操作系统提供的呢还是编译器提供的？感觉编译器的份数大。
然后执行一个 TRAP 指令，将用户态切换到内核态，并在内核中的一个固定位置开始执行（第6步）。TRAP 指令实际上
与过程调用指令非常类似非常类似，它们后面都跟随一个来自远处位置的指令，以及供以后使用的一个保存在栈中
的返回地址。     

跟随在 TRAP 指令后的内核代码开始检查系统调用编号，然后分派给正确的系统调用处理器，这通常是通过一张
由系统调用编号所引用的、指向系统调用处理器的指针表来完成（第7步）。此时，系统调用处理器运行（第8步）。
一旦系统调用处理器完成其工作，控制可能会在跟随在 TRAP 后面的指令中返回给用户空间库过程（第9步）。
这个过程接着以通常的过程调用返回的方式，返回到用户程序（第10步）。    

下面是 POSIX 标准中常用的几个系统调用：   

+ 进程管理
  - `pid = fork()`: 创建与父进程相同的子进程
  - `pid = waitpid(pid, &statloc, options)`: 等待一个子进程终止
  - `s = execve(name, argv, environp)`: 替换一个进程的核心映像
  - `exit(status)`: 终止进程执行并返回状态
+ 文件管理
  - `fd = open(file, how, ...)`: 打开一个文件供读、写或两者
  - `s = close(fd)`: 关闭一个打开的文件
  - `n = read(fd, buffer, nbytes)`: 把数据从文件读到缓冲区
  - `n = write(fd, buffer, nbytes)`: 把数据从缓冲区写到文件中
  - `position = lseek(fd, offset, whence)`: 移动文件指针
  - `s = stat(name, &buf)`: 取得文件的状态信息
+ 目录和文件系统管理
  - `s = mkdir(name, mode)`: 创建新目录
  - `s = rmdir(name)`: 删除一个空目录
  - `s = link(name1, name2)`: 创建一个新目录项name2，并指向 name1
  - `s = unlink(name)`: 删去一个目录项
  - `s = mount(special, name, flag)`: 安装一个文件系统
  - `s = unmount(special)`: 卸载一个文件系统
+ 杂项
  - `s = chdir(dirname)`: 改变工作目录
  - `s = chmod(name, mode)`: 修改一个文件的保护位
  - `s = kill(pid, signal)`: 发送信号给一个进程
  - `seconds = time(&seconds)`: 自1970.1.1 起的流逝时间   

上面的系统调用中，若出错 s 为 -1。    

### 1.6.1 用于进程管理的系统调用

`fork` 在 UNIX 中是唯一可以在 POSIX 中创建进程的调用。它创建一个原有进程的精确副本，包括所有
的文件描述符、寄存器等内容。fork 调用返回一个值，在子进程中该值为零，并且在父进程中等于子进程的进程标识符。

`waitpid` 可以等待一个特定的子进程，或者通过将第一个参数设为 -1的方式，等待任何一个老的子进程。在
waitpid 完成后，将把第二个参数 statloc 所指向的地址设置为子进程的退出状态。    

下面是一个高度简化的shell 实现:    

```c
#define TRUE 1

while(TRUE) {
  type_prompt()      /* 输出命令提示符 */
  read_command(command, parameters)    /* 读入命令 */
  
  if(fork() != 0) {
    waitpid(-1, &status, 0);     /* 父代码 */
  } else {
    execve(command, parameters, 0)   /* 子代码 */
  }
}
```    

首先在读入命令后，fork 子进程，然后父进程执行 `waitpid` 调用，而子进程这时是与父进程完全相同的状态，
但是在子进程中 `fork()` 调用返回的是0，因此进入 else 条件，执行具体的命令，执行完后子进程退出，
父进程进入下一轮循环，那这里来看，`waitpid` 应该是一个阻塞调用。   

`execve` 有三个参数：将要执行的文件名称，一个指向变量数组的指针，以及一个指向环境数组的指针。   

以 `cp` 程序为例，cp程序及多数 C 程序的主程序都有声明: `main(argc, argv, envp)`。   

其中argc 是该命令行内有关参数数目的计数器，包括程序名称。例如 `cp file1 file2`，argc 为3。   

argv 是一个指向数组的指针，该数组的元素 i 是指向命令行第 i 个字符串的指针，在上例中，argv[0] 是
'cp', argv[1] 指向 'file1， argv[2] 指向 'file2'。    

第三个参数是一个指向环境的指针，该环境是一个数组，含有 name=value 的赋值形式。    

`exit` 有一个参数——退出状态（0至255），该参数通过 waitpid 的 statloc 返回父进程。    

在 UNIX 中的进程将其存储空间分为三段：**正文段**（如程序代码）、**数据段**（如变量）以及**堆栈段**。
数据向上增长而堆栈向下增长。    

```
--------------
|   堆栈      |
--------------
|   空闲区    |
|            |
--------------
|   数据      |
--------------
|   正文      |
--------------
```    


### 1.6.2 用于文件管理的系统调用

要读写一个文件，首先要使用 `open` 打开文件，这个系统调用通过绝对路径名或指向工作目录的相对路径名指定要打开的
文件的名称，而代码 O_RDONLY、O\_WRONLY 或 O\_RDWR 的含义分别是只读、只写或者两者都可以。为了创建
一个新文件，使用O_CREAT 参数（注意没 E）。然后可使用返回的文件描述符进行读写操作，接着，可以用 `close`
关闭文件。     

与每个文件相关的是一个指向文件当前位置的指针。在顺序读（写）时，该指针通常指出要读出（写入）的下一个
字节。`lseek` 调用可以改变该位置指针的值。    

`lseek` 有3个参数：第一个是文件的描述符，第二个是文件位置，第三个说明该文件位置是相对于文件起始
位置、当前位置还是文件的结尾。在修改了指针之后，lseek 返回的值是文件中的绝对位置。    

`stat` 调用可以查看文件的相关信息。     

### 1.6.4 各种系统调用

kill 系统调用供用户或用户进程发送信号用。若一个进程准备好捕捉一个特定的信号，那么，在信号到来时，运行一个
信号处理程序。如果该进程没有准备好，那么信号的到来会杀掉该进程。    


## 1.8 依靠 C 的世界

### 1.8.3 大型变成项目

为了构建操作系统，每个 .c 被C 编译器编译成一个目标文件。目标文件使用后缀 .o，含有目标机器的二进制
代码（说明不同的机器编译出的目标文件是不同的）。随后它们可以直接在 CPU 上运行。     

C编译器的第一道称为**C 预处理器**。在它读入每个 .c 文件时，每当遇到一个 #include 指令，就取来
该名称的头文件，并加以处理、扩展宏、处理条件编译，然后将结果传递给编译器的下一道，仿佛它们原先就包含在
该文件中一样。    

由于操作系统非常大，每当文件修改后就重新编译是无法忍受的。另一方面，改变了用在成千上万个文件中的一个关键
头文件，确实需要重新编译这些文件。     

在 UNIX 中，有个名为 `make` 的程序，它读入 Makefile，该 Makefile 说明哪个文件与哪个文件有关。
make 的作用是，在构建操作系统二进制码时，检查此刻需要哪个目标文件，而且对于每个文件，检查自上次目标文件
创建之后是否有任何它依赖的文件已经被修改了。如果有，目标文件需要重新编译。在make 确定了哪个 .o 文件需要
重新编译之后，调用 C 编译器重新编译这些文件。    

一旦所有的 .o 文件就绪，这些文件被传递给称为 **linker** 的程序，将其组合成一个可执行的二进制文件。
在 linker 完成后，得到一个可执行程序，在 UNIX 称为 a.out 文件。    


