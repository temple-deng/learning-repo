# 0214

## 三方 cookie

简单来说，就是我们访问 a 网站的时候，不是可以向 b 网站发起请求吗，这个请求的响应就可以设置 cookie 的，很明显它不可能设置 domain = a 的 cookie，它只能设置 domain = b 的 cookie，它这种时候，如果它能采取到我们页面的交互信息，它就可以去把数据传回自己的系统存起来。    

这就可以用来做营销了。    

SameSite 是 Chrome 51 版本为浏览器的 Cookie 新增的了一个属性， SameSite 阻止浏览器将此 Cookie 与跨站点请求一起发送。其主要目标是降低跨源信息泄漏的风险。同时也在一定程度上阻止了 CSRF 攻击。     

看起来意思可能是，a 网站中发给 b 网站的请求，是不会携带上 b 网站的 cookie 的，那它就无法关联上任何有效的用户信息，那就可能只能通过 url 参数了。    

SameSite 可以避免跨站请求发送 Cookie，有以下三个属性：    

- strict: Strict 是最严格的防护，将阻止浏览器在所有跨站点浏览上下文中将 Cookie 发送到目标站点，即使在遵循常规链接时也是如此。因此这种设置可以阻止所有 CSRF 攻击。然而，它的用户友好性太差，即使是普通的 GET 请求它也不允许通过。
- Lax: 对于允许用户从外部链接到达本站并使用已有会话的网站站，默认的 Lax 值在安全性和可用性之间提供了合理的平衡。Lax 属性只会在使用危险 HTTP 方法发送跨域 Cookie 的时候进行阻止，例如 POST 方式。同时，使用 JavaScript 脚本发起的请求也无法携带 Cookie。例如，一个用户在 A 站点 点击了一个 B 站点（GET请求），而假如 B 站点 使用了Samesite-cookies=Lax，那么用户可以正常登录 B 站点。相对地，如果用户在 A 站点提交了一个表单到 B站点（POST请求），那么用户的请求将被阻止，因为浏览器不允许使用 POST 方式将 Cookie 从A域发送到Ｂ域。
- None: 浏览器会在同站请求、跨站请求下继续发送 Cookies，不区分大小写。    

但是，在 Chrome 80+ 版本中，SameSite 的默认属性是 SameSite=Lax。换句话说，当 Cookie 没有设置 SameSite 属性时，将会视作 SameSite 属性被设置为Lax 。如果想要指定 Cookies 在同站、跨站请求都被发送，那么需要明确指定 SameSite 为 None。具有 SameSite=None 的 Cookie 也必须标记为安全并通过 HTTPS 传送。这意味着所有使用 JavaScript 脚本收集用户信息的请求默认将不能携带三方 Cookie。     

### 解决方案

貌似是用第一方 cookie，意思是这样，访问 a 网站的时候，b 网站的 cookie 种在 a 域名下，但是这个只能通过 js 实现，怎么实现的还不是很清楚，然后呢，b 网站的发出的请求，信息也是附着在请求参数中。    


## Svelte

官网上列举的三个特征：    

- 没有模板代码
- 没有 v-dom
- 响应式，无需状态管理     

这是一个构建时的框架，而不像 react, vue 是运行时框架。