# Transport Layer Security

TLS 为通过网络进行交流的客户端和服务器添加了以下的特性：   

+ 由于使用了对称加密，因此传输的数据是安全的。每条连接使用的对称加密的密钥都是不同的，并且
都是基于会话开始时协商过的共享密钥生成的。服务器和客户端在发送数据前会协商加密算法以及加密
密钥的各种细节。
+ 通信双方的身份都是经过公钥加密算法验证的。身份的认证过程是可选的，但是通常来说指示需要
两者之一的身份。
+ 连接是可靠的，因为每条传输的消息都会附加 MAC 码用来进行消息完整性的检查，防止数据的损坏
以及传输过程中的修改。    

TLS 支持多种不同的方式进行密钥交换、数据加密、消息完整性检查。    

TLS 协议包含两层：TLS 记录和 TLS 握手协议。   

## 1. 描述

一旦客户端与服务器双方同意了使用 TLS 加密通信，它们会通过一个握手的流程来协商一系列连接
状态相关的参数。握手协议使用非对称加密算法来加密加密配置以及之后的会话相关的共享密钥。
在握手期间，双方会通过交流一系列的参数来建立一个安全的连接：   

+ 握手过程起始于客户端，客户端会要求服务器提供一个安全连接，客户端会提供一系列的加密套件
（加密算法和哈希函数）
+ 服务器从这个列表中选取一个加密算法和哈希函数，并且通知客户端它的选择
+ 服务器通常会以数字证书的形式提供它的身份证明。证书包含服务器名称，受信任的证书机构 CA，
服务器的公钥。
+ 客户端验证证书的有效性
+ 为了生成安全连接使用的会话密钥，客户端：
  - 使用服务器公钥加密一个随机数，将其发送给服务器，双方使用这个随机数生成一个会话密钥，
  后续的会话中的数据加解密要使用这个密钥。
  - 使用 Diffie-Hellman 密钥交换来安全地生成用于加密和解密的随机且唯一的会话密钥，该
  密钥具有转发安全的附加属性

所以其实第二条说的就是第一条中的那个会话密钥吧。    

## 2. 算法

### 2.1 密钥交换或密钥协定

在使用 TLS 通信前，CS 双方必须交换或者协定一个用来加密数据的密钥和算法。这些用来交换或者
协定密钥和算法的方法包括：RSA 公钥算法，Diffie-Hellman 算法(TLS_DH)，短 Diffie-Hellman 算法(TLS_DHE)，
椭圆曲线 Diffie-Hellman 算法(TLS_ECDH)，短椭圆曲线 Diffie-Hellman 算法(TLS_ECDHE)，
匿名 Diffie-Hellman 算法，pre-shared key 算法，Secure Remote Password 算法。    

由于 TLS_DH 和 TLS_ECDH 密钥协定不会验证服务器或客户的身份，因此很少使用，因为容易受到
中间人工具。只有 TLS_DHE, TLS_ECDHE 提供了转发安全性。    

公钥算法由于密钥的整数的大小和密钥的长度也经常不一致，导致提供的安全性的鲁棒性也不一致。
2013.07 Google 宣布不再使用 1024 bits 的公钥，而是使用 2048 bits 的公钥。    

### 2.2 加密算法

AES GCM, AES CCM, AES CBC, SEED CBC etc.   

### 2.3 数据完整性

Message authentication code(MAC) 提供了数据完整性。块加密和流加密的 CBC 模式可以使用
HMAC。    

HMAC-MD5, HMAC-SHA1.     


## 3. 协议细节

TLS 协议使用记录 records 交换数据，记录使用特定的方式封装了要交换的数据。每条记录可能会
被压缩，填充，附加 MAC，被加密。每个记录还包含数据的 content type，长度字段和 TLS 版本
字段。封装的消息可能是 TLS 自身的控制消息，也可能是正常传输的应用数据消息。    

### 3.1 TLS 握手

连接开始时，握手协议会封装一个“控制”消息到记录中。握手协议会用来交换双方在正式传输应用
数据前需要的所有信息。其定义了消息的格式以及交换的顺序。这些东西可能会由于 CS 双方需求的
不同而不同。     

#### 4.1.1 基础的 TLS 握手

下面的内容描述了服务器的握手流程：    

1. 协商阶段：
  - 客户端发送一个 **ClientHeelo** 消息，指出其支持的最高的 TLS 版本，一个随机数，
  一个支持的加密套件列表，以及一个支持的压缩方法的列表。如果客户端是在尝试进行一次恢复的
  握手，它可能还会发送一个会话 ID。如果客户端可以使用 ALPN，它可能还包括一个支持的应用协议
  的列表，例如 HTTP/2
  - 服务器使用一个 **ServerHello** 消息响应，包括选择的 TLS 协议版本，一个随机数，选择的
  加密套件和压缩方法。如果是确认一次会话的恢复握手，服务器会发送一个会话 ID。
  - 服务器发送其 **证书** 消息。
  - 服务器发送其 **ServerKeyExchange** 消息，这条消息通常是 DHE 和 DH 算法要求的。
  - 服务器发送一个 **ServerHelloDone** 消息，表明其完成了握手的协商。
  - 客户端用一个 **ClientKeyExchange** 消息进行响应，包含了一个 **前主密钥** (PreMasterSecret)。
  前主密钥使用服务器的公钥加密的。
  - 客户端和服务器使用随机数以及前主密钥计算出一个通用密钥，称为 **主密钥**(master secret)。
  连接所需的其他的所有密钥都是从这个主密钥中计算出来的
2. 客户端发送一个 **ChangeCipherSpec** 记录，告诉服务器 “从现在开始，我给你发送的所有
东西都是经过验证和加密的”。ChangeCipheSpec 是一个记录层的协议，content type 为 20.
  - 最后，客户端发送一个加密过的 **Finished** 消息，包括对之前握手消息的 hash 和 MAC
  - 服务器会尝试解密客户端的 Finished 消息，并且验证 hash 和 MAC。如果解密或验证失败，
  会认为握手失败，连接会中断。
3. 最后，服务器发送一个 **ChangeCipherSpec**，告诉客户端 “从现在开始，我给你发送的所有
东西都是经过加密和验证的”
  - 服务器发送其验证和加密的 **Finished** 消息
  - 客户端执行相同的解密和验证流程
4. 应用阶段：这时，握手就完成了，开始启用应用层协议，content type23。    

#### 4.1.2 包含客户端身份验证的 TLS 握手

1. 协商阶段：
  - 同上，客户端发送 **ClientHello** 消息。
  - 服务器使用 **ServerHello** 响应
  - 服务器发送 **Certificate** 消息
  - 服务器发送 **ServerKeyExchange** 消息
  - 服务器发送 **CertificateRequest** 消息，要求客户端提供证书
  - 服务器发送 **ServerHelloDone** 消息。
  - 客户端使用 **Certificate** 进行响应
  - 客户端发送 **ClientKeyExchange**
  - 客户端发送 **CertificateVerify** 消息，这个消息其实是之前的握手消息使用客户端私钥
  加密的签名。这个可以让服务器知道客户端有权访问证书的私钥以证明身份
  - 计算主密钥。
2. 后面的就都一样了。     

#### 4.1.3 恢复的 TLS 握手

公钥加密算法的各种操作是十分昂贵的。因此 TLS 在握手机制中提供了一个的安全的快捷方式，
以避免这些操作：恢复会话。恢复会话的方式有两种：会话 ID session IDs，以及会话记录单
session tickets。    

#### 4.1.4 Session IDs

在一个基本的握手阶段，服务器会在 **ServerHello** 消息中发送一个 session id。客户端会
将这个 session id 和服务器的 ID 以及 TCP 端口号绑定起来，以便在客户端下次连接服务器时
使用。在服务器端，session id 会和先前协商的加密参数，尤其是主密钥，映射起来。具体的一次
会话恢复如下：    

1. 协商阶段：
  - 客户端发送 **ClientHello** 消息，包含的内容同上，但是多了一个先前 TLS 连接的 session id
  - 服务器使用 **ServerHello** 消息响应，如果服务器能够识别出 session id，消息中还会
  包含这个 session id。客户端使用这个 id 识别出正要执行一次会话的恢复。如果服务器无法识别
  这个 session id，它会发送一个不同的 session id。这就告诉客户端，会话的恢复不会执行。
  这时，CS 双方都有了主密钥。
2. 服务器发送 **ChangeCipherSpec** 记录。
  - 服务器发送 **Finished**
3. 客户端发送 **ChangeCipherSpec** 记录
  - 客户端发送 **Finished**

#### 4.1.5 Session tickets

使用 session tickets 时，服务器存储一个会话特定的状态到一个 session ticket 中，然后将
这个 ticket 发送给客户端存储。如果客户端要恢复一个 TLS 会话，就将这个 session ticket
发送给服务器，服务器会根据这个 ticket 进行会话的恢复。ticket 是用服务器加密和验证过的。    

