# 第 3 章 传输层

<!-- TOC -->

- [第 3 章 传输层](#第-3-章-传输层)
  - [3.1 概述和传输层服务](#31-概述和传输层服务)
    - [3.1.1 传输层和网络层的关系](#311-传输层和网络层的关系)
    - [3.1.2 因特网传输层概述](#312-因特网传输层概述)
  - [3.2 多路复用与多路分解](#32-多路复用与多路分解)
  - [3.3 无连接传输：UDP](#33-无连接传输udp)
    - [3.3.1 UDP 报文段结构](#331-udp-报文段结构)
    - [3.3.2 UDP 校验和](#332-udp-校验和)
  - [3.4 可靠数据传输原理](#34-可靠数据传输原理)
    - [3.4.1 构造可靠数据传输协议](#341-构造可靠数据传输协议)
    - [3.4.2 流水线可靠数据传输协议](#342-流水线可靠数据传输协议)
    - [3.4.3 回退 N 步](#343-回退-n-步)
    - [3.4.4 选择重传](#344-选择重传)
  - [3.5 面向连接的传输：TCP](#35-面向连接的传输tcp)
    - [3.5.1 TCP 连接](#351-tcp-连接)
    - [3.5.2 TCP 报文段段结构](#352-tcp-报文段段结构)
    - [3.5.3 往返时间的估计和超时](#353-往返时间的估计和超时)
    - [3.5.4 可靠数据传输](#354-可靠数据传输)
    - [3.5.5 流量控制](#355-流量控制)
    - [3.5.6 TCP 连接管理](#356-tcp-连接管理)
  - [3.6 拥塞控制原理](#36-拥塞控制原理)
  - [3.7 TCP 拥塞控制](#37-tcp-拥塞控制)

<!-- /TOC -->

## 3.1 概述和传输层服务

传输层协议是在端系统而不是在路由器中实现的。在发送端，传输层将从发送应用程序接收到的报文转换成传输层
分组，用因特网术语来讲该分组称为传输层 **报文段**（segment）。实现的方法是将应用报文划分为较小的
块，并为每块加上一个传输层首部以生成传输层报文段。然后，在发送端系统中，传输层将这些报文端传递给网络层，
网络层将其封装成网络层分组（即数据报）并向目的地发送。注意到下列事实是重要的：网络路由器仅作用于
该数据报的网络层字段；即它们不检查封装在该数据报中的传输层报文段字段。在接收端，网络层从数据报中提取
传输层报文段，并交付给传输层，传输层再处理接收到的报文段，从而交付给应用程序。    

网络应用程序可以使用多种的传输层协议。例如，因特网有两种协议，即TCP 和 UDP。每种协议都能
为调用的应用程序提供一组不同传输层协议。    

### 3.1.1 传输层和网络层的关系

网络层提供了主机之间的逻辑通信，而传输层为运行在不同主机上的进程之间提供了逻辑通信。    

### 3.1.2 因特网传输层概述

因特网为应用层提供了两种截然不同的可用传输层协议。这些协议一种是 UDP（用户数据报协议），它为调用
它的应用程序提供了一种不可靠、无连接的服务。另一种是 TCP（传输控制协议），它为调用它的应用程序提供了
一种可靠的、面向连接的服务。     

UDP 和 TCP 最基本的责任是，将两个端系统间 IP 的交付服务扩展为运行在端系统上的两个进程之间
的交付服务。将主机间交付扩展到进程间交付被称为 **传输层的多路复用** 与 **多路分解**。
进程到进程的数据交付和差错检查是两种最低限度的传输层服务，也是 UDP 所能提供的仅有的两种服务。     

## 3.2 多路复用与多路分解

一个进程有一个或多个 **套接字**，它相当于从网络向进程传递数据和从进程向网络传递数据的门户。在接收主机
中的传输层实际上并没有直接将数据交付给进程，而是将数据给交给了一个中间的套接字。由于在任一时刻，在接收主机上
可能有不止一个套接字，所以每个套接字都有唯一的标识符。标识符的格式取决于他是 UDP 还是 TCP。    

现在我们考虑接收主机怎样将一个到达的传输层报文段定向到适当的套接字。为此目的，每个传输层报文段中具有几个
字段。在接收端，传输层检查这些字段，标识出接收套接字，进而将报文段定向到该套接字。将传输层报文段中的数据交付
到正确的套接字的工作称为 **多路分解**。在源主机从不同套接字中收集数据块，并为每个数据封装上首部信息从而
生成报文段，然后将报文段传递到网络层，所有这些工作称为 **多路复用**。      

通过上述讨论，我们知道传输层多路复用要求：①套接字有唯一标识符；②每个报文段有特殊字段来指示该报文段
所有交付到的套接字。这些特殊字段是 **源端口号字段** 和 **目的端口号字段**。端口号是一个 16 比特的数，
其大小在 0\~65535 之间。0\~1023 范围的端口号称为 **周知端口号**，是受限制的，这是指它们保留给诸如
HTTP 和 FTP 之类的周知应用层来使用。     

1. **无连接的多路复用与分解**    

一个 UDP 套接字是由一个二元组来全面标识的，该二元组包含一个目的 IP 地址和一个目的端口号。因此，如果两个
UDP 报文段有不同的源 IP 地址和/或源端口号，但具有相同的目的 IP 地址和目的端口号，那么这两个报文段将
通过相同的目的套接字被定向到相同的目的进程。说的很明显了，UDP 的话使用目的 IP 和目的端口就可以定位。而不需要
相同的源 IP 和端口。     

2. **面向连接的多路复用与分解**     

TCP 套接字是由一个四元组（源 IP 地址、源端口号、目的 IP 地址、目的端口号）来标识的。这样，当一个 TCP 报文段从
网络到达一台主机时，该主机使用 **全部4个值** 来将报文段定向到相应的套接字。特别与 UDP 不同的是，两个具有不同源 IP
地址或源端口号的到达 TCP 报文段将被定向到两个不同的套接字，除非 TCP 报文段携带了初始创建连接的请求（注意
这一特殊情况）。    

这一点其实就说明了一个没有指定源 IP 地址和端口的套接字其实是类似于一种监听端口，所有初始连接的请求都会
先发送到这个套接字，然后拥有这个套接字的进程或者线程应该是再分配实际用来连接的套接字。      

比如说，某个服务器在 12000 有一个监听套接字，当它收到一条建立连接的请求时，进程会创建一个
新的套接字。与此同时，服务器的传输层注意到该连接请求报文段中的下列四个值：1. 该报文段中的
源端口号；2. 源主机 IP 地址；3. 该报文段中的目的端口号；4. 自身的 IP 地址。新创建的连接
套接字通过这 4 个值标记。所有后续到达的报文段，如果它们的源端口号、源 IP 地址、目的端口号和
目的 IP 地址都与这 4 个值匹配，则被分解到这个套接字。   

## 3.3 无连接传输：UDP

UDP 只是做了传输协议能够做的最少工作。除了复用/分解功能及少量的差错检测外，它几乎没有对 IP 增加别的
东西。实际上，如果应用程序开发人员选择 UDP 而不是 TCP，则该应用程序差不多就是直接与 IP 打交道。UDP
从应用进程得到数据，附加上用于多路复用/分解服务的源和目的端口号字段，以及两个其他的小字段，然后将形成
的报文段交给网络层。    

UDP 的优点有以下几点：    

+ 关于何时、发送什么数据的应用层控制更为精细。采用 UDP 时，只要应用进程将数据传递给 UDP，UDP 就会
将此数据打包进 UDP 报文段并立即将其传递给网络层。在另一方面，TCP 有一个拥塞控制机制，以便当源和目的主机间的
一条或多条链路变得极度拥塞时来遏制传输层 TCP 发送方。   
+ 无需连接建立。TCP 在开始数据传输之前要经过三次握手。UDP 却不需要任何准备即可进行数据传输。因此 UDP 不会
引入建立连接的时延。
+ 无连接状态。TCP 需要在端系统中维护连接状态。此连接状态包括接收和发送缓存、拥塞控制参数以及序号与确认号的参数。
UDP 不维护连接状态，也不跟踪这些参数。
+ 分组首部开销小。每个 TCP 报文段有20字节的首部开销，而UDP仅有8字节的开销。    

需要提一下，使用 UDP 的应用是可以实现可靠数据传输的。这可通过在应用程序自身中建立可靠性机制来完成。
也就是说应用程序可以进行可靠通信，而无需受制于由 TCP 拥塞控制机制。     

### 3.3.1 UDP 报文段结构

UDP 首部只有 4 个字段，每个字段由两个字节组成。长度字段指示了在 UDP 报文段中的字节数（首部加数据）。接收方
使用检验和来检查在该报文段中是否出现了差错。实际上，计算检验和时，除了 UDP 报文段以外还包括了 IP 首部
的一些字段。     

![udp](https://raw.githubusercontent.com/temple-deng/markdown-images/master/network/udp.png)

### 3.3.2 UDP 校验和

UDP 校验和提供了差错检验功能。这就是说，检验和用于确定当 UDP 报文段从源到达目的地移动时，其中的比特是否
发生了改变（例如，由于链路中的噪声干扰或者存储在路由器中时引入问题）。发送方的 UDP 对报文段中的所有 16 比特
字的和进行反码运算，求和时遇到的任何溢出都会被回卷。得到的结果被放在 UDP 报文段中的检验和字段。举例
来说，假定我们有下面的 3个16 比特的字：    

```
0110011001100000
0101010101010101
1000111100001100

这些 16 比特字的前两个之和是：

0110011001100000
0101010101010101
----------------
1011101110110101

再将上面的和与第三个字相加，得出：    

1011101110110101
1000111100001100
----------------
0100101011000010    
```    

注意到最后一次加法有溢出，它要被回卷（貌似就是进到最低位上了）。反码运算就是将所有的 0 换成 1，所有的
1 换成 0 。因此，该和 0100101011000010 的反码运算就是 1011010100111101，这变为了检验和。在接收方，
全部的4个16比特字（包括检验和）加在一起。如果该分组中没有引入差错，则显然在接收方处该和将是1111111111111111。
如果这些比特之一是0，那么我们知道该分组中出现了差错。     

## 3.4 可靠数据传输原理

### 3.4.1 构造可靠数据传输协议

1. 经具有比特差错信道的可靠数据传输   

**肯定确认**，即当收到一个正确的报文分组时，会发送一条确认信息(ACK)给发送方，让
发送方知道哪些内容被正确接收。**否定确认**，即接收方收到的报文有比特错误的话，会发送一条
重传的消息(NAK) 给发送方，让发送方重传出错的报文段。    

当发送方处于等待 ACK 或 NAK 的状态时，它不能从上层获得更多的数据，因此，发送方将不会发送一块新数据，
除非发送方确信接收方已正确的接收当前分组，基于这样行为的协议被称为 **停等** 协议。    

单纯使用上面的肯定确认或者否定确认的情况还是无法解决比特出错的情况，因为我们没有考虑到 ACK
或者 NAK 出错的情况。针对这个问题，处理方法有 3 种：   

+ 第一种就是再重复发送 ACK 或者 NAK，但是这样为了分辨对 ACK 或 NAK 的 ACK 或 NAK，又要
引入新的控制报文，而且并不能根本的解决问题
+ 第二种是增加足够的检验和比特，使发送方不仅可以检测差错，还可恢复差错。对于会产生差错但不
丢失分组的信道，这就可以直接解决问题
+ 第三种方法时，当发送方接收到有问题的 ACK 或 NAK 分组时，只需重传当前数据分组。然而，这种
方法在发送方到接收方的信道中引入了 **冗余分组**。这种方案的问题是接收方不知道它上次所发送
的 ACK 或 NAK 是否被发送方正确地收到。因为它无法判定接收到的分组是新的还是一次重传。    

解决冗余分组问题的一个简单方法是在数据分组中添加一新字段，让发送方对其数据分组编号，即将发送
数据分组的序号放在该字段。于是，接收方只需要检查序号即可确定收到的分组是否一次重传。    

如果收到受损的分组，接收方可以发送一个 NAK。如果不发送 NAK,而是对上次正确接收的分组发送一个
ACK，我们也能实现和 NAK 一样的效果。发送方接收到对同一个分组的两个 ACK，就知道接收方没有
正确接收到跟在被确认两次的分组后面的分组。   

其实序号还可以解决乱序到达的问题吧。   

2. 经具有比特差错的丢包信道的可靠数据传输

在这种情况下，我们的协议还需处理另外两个关注的问题：怎样检测丢包已经发生丢包后该做些什么。
使用检验和、序号、ACK 分组和重传等，使我们能给出后一个问题的答案。为了解决第一个关注的
问题，还需增加一种新的协议机制。    

在这里，我们让发送方负责检查和恢复丢包工作。假定发送方传输一个数据分组，该分组或者接收方对
该分组的 ACK 发生了丢失。在这两种情况下，发送方都收不到应当到来的接收方的响应。如果发送方
愿意等待足够长的时间以便确定分组已丢失，则它只需重传该数据分组即可。    

从发送方的观点来看，重传是一种万能灵药。发送方不知道是一个数据分组丢失，还是一个 ACK 丢失，
或者只是该分组或 ACK 过度延时。在所有这些情况下，动作是同样的：重传。为了实现基于时间的
重传机制，需要一个 **倒计时定时器**，在一个给定的时间量过期后，可中断发送方。因此，发送方
需要能做到：1. 每次发送一个分组时，便启动一个定时器。2. 响应定时器中断 3. 终止定时器    

### 3.4.2 流水线可靠数据传输协议

上节所得出的协议存在性能的问题，主要是因为它是一个停等协议。   

与停等协议相反的，不使用停等方式，允许发送方发送多个分组而无需等待确认。因为许多从发送方向接收方
输送的分组可以被看成是填充到一条流水线中，故这种技术被称为 **流水线**。流水线对可靠数据传输协议带来如下的
影响下：    

+ 必须增加序号范围，因为每个传输中的分组必须有一个唯一的序号，且也许有多个在输送中未确认的报文。
在上一节的停等协议中，因为我们途中最多只有一条报文，所以用一个二进制位来做序号就够了。
+ 协议的发送方和接收方两端也许必须缓存多个分组。发送方最低限度应当能缓冲那些已发送但没有确认的分组。
+ 所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。解决流水线
差错恢复有两种基本方法：**回退 N 步**（Go Back N, GBN）和 **选择重传**（Selective Repeat, SR）。    

### 3.4.3 回退 N 步

在回退 N 步协议中，允许发送方发送多个分组而不需等待确认，但它也受限于在流水线中未确认的分组数不能超过某个
最大允许数 N。      

我们将基序号定义为最早等待未确认分组的序号，将下一序列号定义为最小的未使用序号（即下一个待发分组的序号），
则可将序号范围分为4 段。在[0, base-1] 段内的序号对应于已经发送并被确认的分组。[base, nextseqnum -1] 是
已发送但未被确认的分组，[nextseqnum, base + N -1] 段内的序号能用于那些要被立即发送的分组，如果
有数据来自上层的话。最后，大于或等于 base + N 的序号是不能使用的，直到当前流水线中未被确认的分组已得到
确认为止。      

N 常被称为窗口长度，GBN 协议常被称为 **滑动窗口协议**。    

GBN 发送方必须响应三种类型的事件：   

+ 上层的调用。当上层调用 rdt_send() 时，也就是要发送数据时，发送方首先检查发送窗口是否已满，即是否
有 N 个已发送但未被确认的分组。如果窗口未满，则产生一个分组并将其发送，并相应地更新变量。如果窗口已满，
发送方只需将数据返回给上层，隐式地指示上层该窗口已满。然后上层可能过一会再试。 
+ 收到一个 ACK。在 GBN 协议中，对序号为 n 的分组的确认采取 **累积确认**的方式，表明接收方已正确接收
到序号为 n 的以前且包括 n 在内的所有分组。
+ 超时事件。如果出现超时，发送方重传所有已发送但还未被确认过的分组。     

在 GBN 中，接收方的动作也很简单。如果一个序号为 n 的分组被正确接收到，并且按序，则接收方为分组 n 发送一个
ACK，并将该分组中的数据部分交付到上层。在所有其他情况下，接收方丢弃该分组，并为最近按序接收的分组重新
发送 ACK。这其实确保了发送方累积确认是正常无误的，不然的话如果来个乱序的分组，接收方也
照常发送 ACK 的话，很可能会发生丢包了但双方都不知道的情况。     

当然现实情况是，接收方可能会先缓存一下乱序的分组，直到接收方或者发送方检测到了之前的包的
丢失，那么接收方可以直接丢弃掉缓存的分组，因为这时候发送方肯定会重传所有的丢失分组。   

GBN 也有它自己的问题，比如说累积确认的方式可能会发送很多未丢包的分组，以及超时后重发所有
未确认的分组，都会造成不必要的冗余分组。   

### 3.4.4 选择重传

选择重传协议通过让发送方仅重传那些它怀疑在接收方出错的分组而避免了不必要的重传。这种个别的、按需的重传要求
接收方逐个地确认正确接收的分组。    

SR 发送方响应的事件动作如下：    

+ 从上层收到数据。与 GBN 一样把。
+ 超时。每个分组都有自己的逻辑定时器，因为超时发生后只能发送一个分组。而 GBN 里面只有一个
定时器即可，即最早的未确认的分组的定时器。
+ 收到 ACK，如果收到 ACK，若分组序号在窗口内，则 SR 发送方将那个被确认的分组标记为已接收。如果该
分组的序号等于 send_base，则窗口基序号向前移动到最小的未被确认的分组处。    

下面说明了 SR 接收方采用的动作：    

+ 序号在 [rcv_base, rcv\_base + N -1] 内的分组被正确接收。在此情况下，收到的分组落在接收方的窗口内，
一个选择 ACK 被回送给发送方。如果该分组以前没收到过，则缓存该分组。如果该分组的序号等于接收窗口内的基序号，
则该分组以及以前缓存的序号连续的分组交付给上层。然后，接收窗口移动。
+ 序号在 [rcv_base - N, rcv\_base - 1] 内的分组被正确接到。在此情况下，必须产生一个 ACK，即使
该分组是接收方以前确认过的分组。
+ 其他情况，忽略该分组。    

至此我们结束了对可靠数据传输协议的讨论。下表总结了这些机制。     


机制 | 用途和说明
----------|---------
 检验和 | 用于检测在一个传输分组中的比特错误
 定时器 | 用于超时/重传一个分组，可能是因为该分组（或其 ACK）在信道中丢失了。
 序号 | 用于为发送方流向接收方的数据分组按顺序编号。
 确认号 | 接收方用于告诉发送方一个分组或一组分组已被正确地接收到了。    


## 3.5 面向连接的传输：TCP

### 3.5.1 TCP 连接

一旦建立起一条 TCP 连接，两个应用进程之间就可以相互发送数据了。客户进程通过套接字传递数据流，数据
一旦交付给套接字，它就由客户中运行的 TCP 控制了。TCP 将这些数据引导到该连接的 **发送缓存**里，发送缓存
是在三次握手初期设置的缓存之一。接下来 TCP 就会不时从发送缓存里取出一块数据。TCP 可以从缓存中取出并放入
报文段中的数据数量受限于 **最大报文段长度**（Maximum Segment Size, MSS）。MSS 通常根据最初确定的由
本地发送主机的最大链路层帧长度（即所谓的 **最大传输单元**（Maximum Transmission Unit, MTU））来设置。
设置该 MSS 要保证一个 TCP 报文段加上 TCP/IP 首部将适合单个链路层帧。以太网和 PPP链路层协议都具有
1500 字节的 MTU，因此 MSS 的典型值为 1460 字节。注意到 MSS 是指在报文段里应用层数据的最大长度，
而不是指包括 TCP 首部的 TCP 报文段的最大长度。     

### 3.5.2 TCP 报文段段结构

![tcp](https://raw.githubusercontent.com/temple-deng/markdown-images/master/network/tcp.png) 

同 UDP 一样， TCP 首部包括 **源端口号**和 **目的端口号**以及 **检验和字段**。此外，报文段首部还包含下列字段：    

+ 32 比特的 **序号字段**（sequence number field）和 32 比特的 **确认号字段**（acknowledgment number field）。
+ 16 比特的 **接收窗口字段**（receive window field），该字段用于流量控制，该字段用于指示接收方愿意接收的
字节数量。
+ 4 比特的 **首部长度字段**（header length field），该字段指示了以 32 比特的字为单位的 TCP 首部长度。
由于 TCP 选项字段的原因，TCP 首部的长度是可变的。不过通常选项字段为空，所以 TCP 首部的典型长度就是 20 字节。
+ 可选与变长的 **选项字段**（options field），该字段用于发送方与接收方协商最大报文段长度（MSS）时，
或在高速网络环境下用作窗口调节因子时使用。
+ 6 比特的 **标志字段**（flag field）。**ACK 比特**用于指示确认字段中的值是有效的，即该报文段包括一个
对已被成功接收报文段的确认。**RST、SYN** 和 **FIN** 比特用于连接的建立和拆除。当 **PSH** 比特被设置的
时候，就指示接收方应立即将数据交给上层。最后 **URG** 比特用来指示报文段里存在着被发送端的上层实体置为
“紧急”的数据。紧急数据的最后一个字节由 16 比特的**紧急数据指针字段**指出。当紧急数据存在并给出指向紧急数据
尾的指针的时候，TCP 必须通知接收端的上层实体。     

在实践中，PSH、URG 和紧急数据指针并没有使用。   

1. **序号和确认号**     

序号是建立在传送的字节流之上，而不是建立在传送的报文段的序列之上。**一个报文段的序号**因此是该报文段首字节
的字节流编号。举例来说，假设主机 A 上的一个进程想通过一条 TCP 连接向主机 B 上的一个进程发送一个数据流。
主机 A 中的 TCP 将隐式地对数据流中的每一个字节编号。假定数据流由一个包含 500 000 字节的文字组成，
其 MSS 为 1000 字节，数据流的首字节编号为 0。该 TCP 将为该数据流构建 500 个报文段。给第一个报文段
分配序号 0，第二个报文段分配序号 1000，第三个报文段分配序号 2000。     

主机 A 填充进报文段的确认号是主机 A 期望从主机 B 收到的下一字节的序号。假设主机 A 已收到了来自主机 B
的编号为 0~535 的所有字节，同时假设它打算发送一个报文段给主机 B。主机 A 等待主机 B 的数据流中字节 536 及
之后的所有字节。所以主机 A 就会在它发往主机 B 的报文段的确认号字段中填上 536。    

事实上，一条 TCP 连接的双方均可随机地选择初始序号。这样做可以减少将那些仍在网络中存在的来自两台主机之间
先前已终止的连接的报文段，误认为是后来这两台主机之间新建连接所产生的有效报文段的可能性（它碰巧与旧连接
使用了相同的端口号）。     

### 3.5.3 往返时间的估计和超时

1. **估计往返时间**    

报文段的样本 RTT（表示为 SampleRTT）就是从某报文段被发出（即交给 IP）到对该报文段的确认被收到之间的
时间量。大多数 TCP 的实现尽在某一时刻做一次 SampleRTT 测量，而不是为每个发送的报文段测量一个 SampleRTT。
这就是说，在任意时刻，仅为一个已发送的但目前尚未被确认的报文段估计 SampleRTT，从而产生一个接近每个 RTT 的
新 SampleRTT 值。    

显然，由于路由器的拥塞和端系统负载的变化，这些报文段的 SampleRTT 值会随之波动。由于这种波动，
任何给定的 SamplerRTT 值也许都是非典型的。因此，为了估计一个典型的 RTT，自然要采取某种对 SampleRTT 取
平均的办法。TCP 维持一个 SampleRTT 均值（称为 EstimatedRTT）。一旦获得一个新 SampleRTT，TCP 就会
根据下列公式来更新 EstimatedRTT:     

` EstimatedRTT = (1 - α) * EstimatedRTT + α * SampleRTT`     

标准中给出的 α 参考值是 0.125。    

除了估算 RTT 外，测量 RTT 的变化也是有价值的。即 RTT 偏差 DevRTT，用于估算 SampleRTT 一般会
偏离 EstimatedRTT 的程度：    

` DevRTT = (1 - β) * DevRTT + β * | SampleRTT - EstimatedRTT | `    

β 的推荐值为 0.25.     

2. **设置和管理重传超时间隔**     

通常来说将超时间隔设为 EstimatedRTT 加上一定余量。当 SampleRTT 值波动较大时，这个余量应该大些；当波动
较小时，这个余量应该小些。因此， DevRTT 值在这里发挥作用了：    

` TimeoutInterval = Estimated + 4 * DevRTT`    

推荐初始的 TimeoutInterval 值为 1秒。同样，当出现超时时，TimeoutInterval 值将加倍，以免即将被确认
后的后继报文段过早出现超时。不管怎样，一旦报文段收到并更新 EstimatedRTT，TimeoutInterval 就又使用
上述公式计算了。    

### 3.5.4 可靠数据传输

1. **超时间隔加倍**     

我们现在讨论一下在大多数 TCP 实现中所做的一些修改。首先关注的是在定时器时限过期后超时间隔
的长度，在这种修改中，每当超时事件发生时，如前所述，TCP 重传具有最小序号的还未被确认的报文
段。只是每次 TCP 重传时都会将下一次的超时间隔设为先前值的两倍，而不是用从 EstimatedRTT
和 DevRTT 推算出的值。    

然而，每当定时器在另两个事件（即收到上层应用的数据和收到 ACK）中的任意一个启动时，超时间隔
将由最近的 EstimatedRTT 值和 DevRTT 值推算得到。    

2. **快速重传**    

超时触发重传存在的问题之一是超时周期可能相对较长。当一个报文段丢失时，这种长超时周期迫使发送方延迟重传丢失的分组，因而增加了端到端时延。
幸运的是，通常可在超时事件发生之前通过注意所谓冗余 ACK 来较好地检测到丢包情况。**冗余 ACK** 就是
再次确认某个报文段的 ACK，而发送方先前已经收到对该报文的确认。要理解发送方对冗余 ACK 的响应，我们
必须首先看一下接收方为什么会发送冗余 ACK。下表总结了 TCP 接收方的 ACK 生成策略。当接收方收到一个具有
这样序号的报文段时，即其序号大于下一个所期望的、按序的报文段，它检测到了数据流中的一个间隔，
这就是说有报文段丢失。这个间隔可能是由于在网络中报文段丢失或重新排序造成的。因为 TCP 不使用
否定确认，所有接收方不能向发送方发回一个显式的否定确认。相反，它只是对已经接收到的最后一个按序字节
数据进行重复确认。     


事件 | TCP 接收方动作
----------|---------
 具有所期望序号的按序报文段到达。所有在期望序号及以前的数据都已经被确认 | 延迟的 ACK。对另一个按序报文段的到达最多等待 500ms。如果下一个按序报文段在这个时间间隔内没有达到，则发送一个 ACK
 具有所期望序号的按序报文段到达。另一个按序报文段等待 ACK 传输 | 立即发送单个累积 ACK，以确认两个按序报文段。那这里意思是最多累积两个 ACK 一起发送
 比期望序号大的失序报文段到达。检测出间隔 | 立即发送冗余 ACK，指示下一个期待字节的序号
 能部分或完全填充接收数据间隔的报文段到达 | 倘若该报文段起始于间隔的低端，则立即发送 ACK    

如果 TCP 发送方接收到对相同数据的 3 个冗余 ACK（注意是3个冗余的 ACK，也就是说对同一序号的报文段一共4个ACK），
他把这当做一种暗示，说明跟在这个已被确认过3次的报文段之后的报文段已经丢失。一旦收到 3
个冗余 ACK，TCP 就执行 **快速重传**，即在该报文段的定时器过期之前重传丢失的报文段。    

3. **是回退 N 步还是选择重传**    

首先确认一点，TCP 是采用累积确认的，这样来看，TCP 更像一个 GBN 风格的协议，不过 TCP 和
GBN 又有很多的区别。首先假设某个分组 n 丢失了，GBN 会重传 n，n+1, n+2 等等分组，而 TCP
将只重传 n。如果对报文段 n+1 的确认报文是在 n 超时之前到达，TCP 甚至都不会重传报文段 n。
因为之前上面提到了，对于乱序的失序报文是会发送冗余 ACK 的，如果发送方收到了正常的 ACK，
那说明 n+1 之前的报文是被正确接收了。    

对 TCP 提出的一种修改意见是所谓的 **选择确认**，它允许 TCP 接收方有选择地确认失序报文段，而不是累积地
确认最后一个正确接收的有序报文段。当将该机制与选择重传机制结合起来使用时，TCP 看起来就很像我们通常的 SR 协议。
因此，TCP 的差错恢复机制也许最好被分类为 GBN 协议与 SR 协议的混合体。    

### 3.5.5 流量控制     

TCP 为它的应用程序提供了 **流量控制服务**以消除发送方使接收方缓存溢出的可能性。流量控制因此是一个速度
匹配服务，即发送方的发送速率与接收方应用程序的读取速率向匹配。前面提到过，TCP 发送方也可能因为 IP 
网络的拥塞而被遏制；这种形式的发送方的控制被称为 **拥塞控制**。即使流量控制和拥塞控制采取的动作非常相似，
但是它们显然是针对完全不同的原因而采取的措施。    

TCP 通过让发送方维护一个称为 **接收窗口**的变量来提供流量控制。通俗的说，接收窗口用于给发送方一个指示——该接收方
还有多少可用的缓存空间。假设主机 A 通过一条 TCP 连接向主机 B 发送一个大文件。主机 B 上的应用进程
不时地从该缓存中读取数据。我们定义如下变量：    

+ LastByteRead: 主机 B 上的应用进程从缓存读出的数据流的最后一个字节的编号。
+ LastByteRcvd: 从网络中到达的并且已放入主机 B 接收缓存中的数据流的最后一个字节的编号。   

由于 TCP 不允许已分配的缓存溢出，所以下式必须成立：`LastByteRcvd - LastByteRead <= RcvBuffer`     

接收窗口用 rwnd = RcvBuffer - [ LastByteRcvd - LastByteRead ]。     

主机 B 通过把当前的 rwnd 值放入它发给主机 A 的报文段接收窗口字段中，通知主机 A 它在该连接
的缓存中还有多少可用空间。     

主机 A 轮流跟踪两个变量，LastByteSent 和 LastByteAcked。注意到这两个变量之间的差 LastByteSent - LastByteAcked，
就是主机 A 发送到连接中但未被确认的数据量。通过将未确认的数据量控制在值 rwnd 以内，就可以保证主机 A
不会使主机 B 的接收缓存溢出。    

上述的方案有个问题就是，假设 B 的接收缓存已满，rwnd = 0。在将 rwnd 通告给 A 之后，还要假设 B 没有
任何数据要发给主机A（这样后续的 rwnd 就无法发给A）。此时，当 B 将缓存清空后，TCP 并不向 A 发送带有
rwnd 新值的报文段。这样，A 无法知道 B 的缓存已经有空间了，所以 A 就一直阻塞下去。因此，TCP 规范要求：
当 B 的接收窗口为 0 时，A 继续发送只有一个字节数据的报文段。这些报文段将会被接收方确认。最终缓存将开始清空，
并且确认报文里将包含一个非 0 的 rwnd 值。     

### 3.5.6 TCP 连接管理

+ 第一步：客户端的 TCP 首先向服务器端的 TCP 发送一个特殊的 TCP 报文段。该报文段中不包括应用层数据。
但是在报文段的首部中的一个标志位（即 SYN）被置为 1。因此，这个特殊的报文段被称为 SYN 报文段。另外，客户
会随机地选择一个初始序号(client_isn)，并将此编号放置于该起始的 TCP SYN 报文段的序号字段中。该报文段
会发送给服务器。
+ 第二步：一旦包含 TCP SYN 报文段的 IP 数据报到达服务器主机，服务器会从该数据报中提取出 TCP SYN 报文段，为该 TCP
连接分配 TCP 缓存和变量，并向该客户 TCP 发送允许连接的报文段。这个允许连接的报文段也不包含应用层数据。
但是，在该报文段的首部却包含 3 个重要的信息。首先，SYN 比特被置为 1。其次，该 TCP 报文段首部的确认
号字段被置为 client_isn + 1。最后，服务器选择自己的初始序列号（server\_isn），并将其放到序号字段中。
该允许连接的报文段有时被称为 **SYNACK报文段** 。
+ 第三步：在收到 SYNACK 报文段后，客户也要给该连接分配缓存和变量。客户主机则向服务器发送另一个报文段；
这最后一个报文段对服务器的允许连接的报文段进行了确认。因为连接已经建立，所有该 SYN 比特置 0 。三次握手
的第三个阶段可以在报文段负载中携带应用程序数据了。    

在握手后的每一个报文段中，SYN 比特都被置 0。    

在 TCP 连接终止时，主机中的资源需要被释放。客户进程发出一个关闭连接命令。这会引起客户 TCP 向服务器进程
发送一个特殊的 TCP 报文段。这个特殊的报文段让其首部中的一个标志位 FIN 比特置 1 。当服务器接收到该
报文段后，就向发送方回送一个确认报文段。然后，服务器发送它自己的终止报文段，其 FIN 比特置 1 。最后，该客户
对这个服务器的终止报文段进行确认。此时，在两台主机上用于该连接的所有资源都被释放了。    

在一个 TCP 连接的生命周期内，运行在每台主机中的 TCP 协议在各种 **TCP 状态**之间变迁。下图说明了
客户 TCP 会经历的一系列典型 TCP 状态。     

![client-tcp-state](https://raw.githubusercontent.com/temple-deng/markdown-images/master/network/client-tcp-state.png) 

> SYN 洪泛攻击   
> 在这种攻击中，攻击者发送大量的 TCP SYN 报文段，而不完成第三次握手的步骤。随着这种 SYN 报文段
纷至沓来，服务器不断为这些半开连接分配资源，导致服务器的连接资源被消耗殆尽。现在有一种有效的防御系统，
称为 **SYN cookie**，以下列方式工作：   
> + 当服务器收到一个 SYN 报文段时。服务器不会为该报文段生成一个半开连接。相反，服务器生成一个初始 TCP 序列号，该序列号是 SYN 报文段的源和目的 IP 地址与端口号以及仅有该服务器知道的秘密数的一个复杂函数（哈希函数）。这种精心制作的初始序列号被称为“cookie”。重要的是，服务器并不记忆该 cookie 或任何对应于 SYN 的其他状态信息。
> + 如果客户是合法的，则它将返回一个 ACK 报文段。当服务器收到该 ACK，需要验证该 ACK 是否与前面发送的某些 SYN 想对应的。服务器使用报文段中的源和目的 IP 地址和端口号以及秘密数运行相同的哈希函数，最终的值如果和确认号减1相等，那么就说明是个合法的客户端。服务器生成一个具有套接字的全开的连接。
> + 另一方面，如果客户没有返回一个 ACK 报文段，则初始的 SYN 并没有对服务器产生危害，因为服务器没有为它分配任何资源。     

下图是服务器端 TCP 经历的一系列状态。    

![server-tcp-state](https://raw.githubusercontent.com/temple-deng/markdown-images/master/network/server-tcp-state.png) 


考虑当一台主机接收到一个 TCP 报文段，其端口号或源 IP 地址与该主机上进行中的套接字都不匹配的情况。例如，假如
一台主机接收了具有目的端口 80 的一个 TCP SYN 分组，但该主机在端口 80 不接收连接。则该主机将向源发送一个
特殊重置报文段。该报文段将 RST 标志位置 1.因此，当主机发送一个重置报文段时，它告诉该源“我没有那个报文
段的套接字，请不要再发送该报文段了”。当一台主机接收一个 UDP 分组，它的目的端口与进行中的 UDP 套接字
不匹配，该主机发送一个特殊的 ICMP 数据报。    

## 3.6 拥塞控制原理

先略。太复杂了。     

## 3.7 TCP 拥塞控制

TCP 所采用的方法是让每一个发送方根据所感知到的网络拥塞程度来限制其能向连接发送流量的速率。如果一个 TCP 发送方
感知从它到目的地之间的路径上没什么拥塞，则 TCP 发送方增加其发送速率；如果发送方感知沿着该路径有拥塞，
则发送方就会降低其发送速率。但是这种方法提出三个问题。第一，一个 TCP 发送方如何限制它向其连接发送流量的速率
呢？第二，发送方如何感知从它到目的地之间的路径上存在拥塞呢？第三，当发送方感知到端到端的拥塞时，采用何种算法来改变
其发送速率呢?      

首先分析一个 TCP 发送方如何限制向其连接发送流量的。TCP 连接的每一端都是由一个接收缓存、一个发送缓存和几个变量组成。
运行在发送方的 TCP 拥塞控制机制跟踪一个额外的变量，即 **拥塞窗口**（congestion window）。拥塞窗口表示为
cwnd，它对一个 TCP 发送方能向网络中发送流量的速率进行了限制。特别是，在一个发送方中未被确认的数据量不会
超过 cwnd 和 rwnd 中的最小值，即 `LastByteSend - LastByteAcked <= min{cwnd, rwnd}` 中的最小值。因此通过
调整 cwnd 的值，发送方因此能够调整它向连接发送数据的速率。     

接下来考虑 TCP 发送方是如何感知在它与目的地之间的路径上出现了拥塞的。我们将一个 TCP 发送方的“丢包事件”定义为：要么出现超时，
要么收到来自接收方的 3 个冗余 ACK。当出现了丢包事件时，发送方就认为在发送方到接收方的路径上出现了拥塞
的指示。     

最后看一下 TCP 发送方怎样确定它应当发送的速率呢？TCP 发送方如何确定它们的发送速率，即使得以更高的速率
发送而不会使网络阻塞，与此同时又能充分利用所有可用的带宽？TCP 使用下列指导性原则回答这些问题：    

+ 一个丢失的报文段意味着拥塞，因此当丢失报文段时应当降低 TCP 发送方的速率。对于给定报文段，
一个超时事件或者 4 个确认被解释为丢包事件的发生。
+ 一个确认的报文段指示该网络正在向接收方交付发送方的报文段，因此，当对先前未确认报文段的确认到达时，能够增加
发送方的速率。
+ 带宽探测。为探测拥塞开始出现的速率，TCP 发送方增加它的传输速率，从该速率后退，进而再次开始探测，看看拥塞开始
速率是否发生了变化。    

概述了 TCP 拥塞控制后，下面就该介绍 **TCP 拥塞控制算法**。该算法包括 3 个主要部分：①慢启动；②拥塞避免；
③快速恢复。慢启动和拥塞避免是 TCP 的强制部分，两者的差异在于对收到的 ACK 做出反应时增加 cwnd 长度的方式。快速
恢复是推荐部分。     

1. **慢启动**    

当一条 TCP 连接开始时，cwnd 的值通常初始设置为一个 MSS 的最小值。在 **慢启动**状态，cwnd 的值以 1 个
MSS 开始并且每当传输的报文段首次被确认就增加一个 MSS。这一个过程每过一个 MSS，发送速率就翻倍。因此，TCP 发送速率
起始慢，但在慢启动阶段以指数增长。     

但是，何时结束这种指数增长呢？慢启动对这个问题提供了几种答案。首先，如果存在一个由超时指示的丢包事件，
TCP 发送方将 cwnd 设置为 1 并重新开始慢启动过程。它还将第二个状态变量的值 ssthresh
设置为 cwnd/2，即当检测到拥塞时将 ssthresh 置为拥塞窗口值的一半。慢启动结束的第二个
方式是直接与 ssthresh 值相关联。因为当检测到拥塞时 ssthresh 设为 cwnd 的值的一半，当到达或超过
ssthresh 的值时，继续使 cwnd 翻番可能有些鲁莽。因此，当 cwnd 的值等于 ssthresh 时，结束慢启动并且 TCP
转移到拥塞避免模式。最后一种结束慢启动的方式是，如果检测到 3 个冗余 ACK，这时 TCP 执行一种快速重传
并进入快速恢复状态。    

综上所述的意思差不多是这样，慢启动一开始 cwnd = 1，开始以翻倍的速率增长，然后如果遇到了超时引起的丢包
事件，就重新启动，继续从 1 开始，并记录 ssthresh 值，等再次增长到 ssthresh / 2 时候进入拥塞避免
模式，在这个模式中会修改 cwnd 增长的模式。如果遇到的是3个冗余 AKC 的丢包事件，进入快速恢复模式，看图的意思，
也会把 ssthresh 记录为 cwnd/2，不过这时候好像 cwnd 不是重置为1，而是改成 ssthresh + 3*MSS。
此外，在拥塞避免和快速恢复模式又遇到超时的话，重复上面的行为。    

2. **拥塞避免模式**   

进入拥塞避免模式后，每个 RTT 只将 cwnd 的值增加一个 MSS。这能够通过几种方式完成，一种通用的方法是是对于
TCP 发送方无论何时到达一个新的确认，就将 cwnd 增加一个 MSS * (MSS/cwnd) 字节。例如，如果 MSS 是 1460 字节并且
cwnd 是 14600 字节，则在一个 RTT 内发送 10 个报文段。每个到达的 ACK 增加 1/10 MSS 的拥塞窗口长度，
因此在收到对所有 10 个报文段的确认后，拥塞窗口的值增加一个 MSS。    

当时何时应当结束拥塞避免的线性增长呢？当出现超时时，与慢启动类似，cwnd = 1，ssthresh = cwnd/2.
不过如果是 3 次冗余 ACK 引起的丢包，与快速恢复模式类似，ssthresh = cwnd/2, cwnd = ssthresh + 3 * MSS.    

3. **快速恢复**

在快速恢复中，对于引起 TCP 进入快速恢复状态的缺失报文段，对收到的每个冗余的 ACK，cwnd 的值增加一个
MSS（那就和正常一样）。最终，当对丢失报文段的一个 ACK 到达时，TCP 在降低 cwnd 后进入拥塞避免状态。
这里的计算顺序搞的不是很清楚，看样子是先把 ssthresh 设为 cwnd/2 一般，然后 cwnd 从 cwnd/2 + 3 * MSS 
开始。     

 