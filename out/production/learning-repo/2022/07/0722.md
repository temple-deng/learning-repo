## 0722

<!-- TOC -->

- [0722](#0722)
    - [Vue 面试题](#vue-面试题)

<!-- /TOC -->

### Vue 面试题

1. 在vue2中，v-for的优先级是高于v-if，把它们放在一起，输出的渲染函数中可以看出会先执行循环再判断条件，哪怕我们只渲染列表中一小部分元素，也得在每次重渲染的时候遍历整个列表，这会比较浪费；另外需要注意的是在vue3中则完全相反，v-if的优先级高于v-for，所以v-if执行时，它调用的变量还不存在，就会导致异常
2. v-model是一个指令，它的神奇魔法实际上是vue的编译器完成的。我做过测试，包含v-model的模板，转换为渲染函数之后，实际上还是是value属性的绑定以及input事件监听，事件回调函数中会做相应变量更新操作。
3. v-dom 的好处，减少 DOM 操作成本，减少 reflow, repaint，便于 renderer 移植
4. 开发时，有两个场景我们会用到nextTick：
  - created中想要获取DOM时；
  - 响应式数据变化后获取DOM更新后的状态，比如希望获取列表更新后的高度。
5. 关于 watch/$watch: 首先选项式 watch 好像只能监听 data 和 computed，但是根据测试的话，props 也可以，然后底层好像就是在实例化的时候调用 $watch，但是可以监听嵌套的属性。而 $watch 监听顶层 data, props, computed，但是实测也能检测嵌套的
6. 发现一个问题，好像 script 和 script setup 里面的变量不能互访问啊
7. ref 即使包装一个对象类型的，对属性也会响应式。
8. watch和watchEffect异同。watchEffect立即运行一个函数，然后被动地追踪它的依赖，当这些依赖改变时重新执行该函数。和 mobx 的 autorun 类似，通过执行一次，记录依赖。watch侦测一个或多个响应式数据源并在数据源变化时调用一个回调函数。这个的话，和那个 reaction 类似。
9. 渲染大量数据：
   1. 可以采取分页的方式获取，避免渲染大量数据
   2. vue-virtual-scroller等虚拟滚动方案，只渲染视口范围内的数据
   3. 如果不需要更新，可以使用v-once方式只渲染一次
   4. 通过v-memo可以缓存结果，结合v-for使用，避免数据变化时不必要的VNode创建
   5. 可以采用懒加载方式，在用户需要的时候再加载数据，比如tree组件子树的懒加载


