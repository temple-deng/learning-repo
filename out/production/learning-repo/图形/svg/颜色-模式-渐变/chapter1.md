# 深入理解 SVG

# 第 1 章 你应该知道的事

## 1.1 SVG 通过代码来画图

SVG 就是⼀个图⽚⽂件。我们可以像使⽤ PNG 或 JPEG 等图⽚⽂件⼀样使⽤它，可以在可视化编辑器中
创建和编辑 SVG，也可以将其作为图⽚嵌⼊到⽹页中。    

但是 SVG 并不仅仅是图⽚，它是包含标记元素、⽂本、样式指令的结构化⽂档。其他图⽚格式是告诉计算机
在屏幕上哪⼀点应该绘制什么颜⾊，⽽ SVG 是告诉计算机如何通过它的组成部分重组图形。这产⽣以下两个
主要结果：    

- SVG 最终在屏幕上的显⽰依赖于软件对 SVG 规范的⽀持程度。跨浏览器的兼容性往往是⼀个问题。
- 对 SVG 的⼀部分单独进⾏增加、删除、修改的操作是⾮常容易的，不⽤担⼼会改变 SVG 的其他部分。
我们可以在编辑器中进⾏此类操作，也可以动态地在⽹页中制作动画或交互图形。     

## 1.4 SVG 是可压缩的

SVG 的⼤部分语法的设计都是为了使其易于阅读和理解，⽽不是为了结构紧凑，这使得某些 SVG ⽂件看起来
相当冗长和冗余。但是，这也使得 SVG ⾮常适合通过 gzip 压缩。通常，这将使⽂件⼤⼩减少⼀半甚⾄更多。
在普通的⽂件服务器上存储压缩过的 SVG 时，通常使⽤ .svgz 作为扩展名。  

SVG 也是容易臃肿的，这也在另⼀⽅⾯使它可压缩。⼤多数 SVG 编辑器通过给定唯⼀的 XML 命名空间，
在 SVG ⽂件中添加⾃⼰的元素和属性。有些优化⼯具开发了在不影响最终结果的基础上把代码剥离出来的
功能。     

## 1.5 图片是形状的集合

那么这所有的代码想要表现的是什么呢？当然是形状！（也可能是⽂本或嵌⼊的图像）    

## 1.9 SVG 是无数 canvas 的有限集

在计算机精度允许的范围内，可以给⽮量形状添加任意多个坐标。不过最终显⽰的是 viewBox 属性建⽴的
特定范围坐标内的形状。通过给 preserveAspectRatio 设置不同的值来控制在宽⾼⽐不匹配时，如何把
坐标的范围缩放到视图区域（viewport）。   

嵌套 &lt;svg&gt; 元素或复⽤ &lt;symbol&gt; 元素可以创建嵌套的视口，它们除了提供控制宽⾼⽐的
区域外，还定义了确定⼦元素百分⽐值的依据。其他元素还可以使⽤ viewBox 属性来创建⼀个伸缩到合适
⼤⼩的效果（我们将在第 11 章的 &lt;pattern&gt; 元素中学习），⽽不⽤重新去定义百分⽐。   

## 1.11 SVG 是有样式的

SVG 图形可以仅仅由所有的样式信息都通过属性来设置的 XML 元素组成。当然，这些和表现相关的样式也
可以通过 CSS 规则来设定，⽐如通过 class 或者元素类型来控制。还可以使⽤媒体属性或瞬时状态等有条
件的 CSS 样式，⽐如 :hover 和 :focus。   

严格分开⼏何结构（XML 属性）和表现样式（表现属性或者 CSS 样式规则）是有些武断的。随着 SVG 的
发展，这两者之间的界限将越来越模糊。SVG2 的规范草案把许多布局属性升级为表现属性。这便可以通过灵
活的 CSS 语法来提供以下特性：通过类给相似元素设置⼀个差不多的尺⼨，然后再通过 CSS 伪类或媒体
查询来修改具体的尺⼨或布局。     

# 第 2 章 画家模型

## 2.1 使用 fill 属性进行填充

如果在你的 SVG 中仅仅包含⼀个圆或⼀个长⽅形的标记（或其他任何形状或⽂本）⽽没有其他的样式信息，
它将在你定义的尺⼨内显⽰⼀个纯⿊⾊的区域。这是因为 fill 属性的默认值是纯⿊⾊。   

fill 属性告诉 SVG 渲染软件如何操作⼏何形状。对于屏幕上的每⼀个像素（可以对⽐纸上的每⼀个墨斑），
软件都可以确定该点是不是在形状之内。如果该点在形状之内，软件就会填充 fill 的值，然后确定下⼀步
怎么做。    

fill 属性（以及 stroke 属性）的最后⼀个可以设置的值是 currentColor 关键词。这⼀关键词通常被
估算为给定元素的 CSS color 属性的当前值。color 属性本⾝对 SVG 没有直接的影响，但是结合 currentColor，
它将有下面的主要⽤途。    

- 为重复使⽤的内容提供⼀个间接继承的样式值。使⽤ &lt;use&gt; 元素复制的 SVG 图形可以从使⽤它
的上下⽂中继承 fill 和 stroke 等样式。给重复使⽤的图形中的重要属性使⽤ currentColor，这样可以
通过改变 &lt;use&gt; 元素上的 color 值来分开操作复⽤图形的 fill 和 stroke 的值。    

默认情况下，fill 属性被渲染为纯⾊且不透明（除⾮在渲染服务中有不同的指令）。可以通过给
fill-opacity 属性设定值来调整不透明度。    

当你不能确定图形的某⼀部分是在图形之内还是之外时，fill-rule 属性可以给计算机发送精确的指令。
它会影响内部有洞的 &lt;path&gt; 元素以及路径、多边形和纵横交错的折线。    

SVG 中的每个图形和⽂本都可以被填充，且默认是填充的。这包括不闭合的 &lt;path&gt; 元素和 &lt;polyline&gt;
元素，它们可以定义⼀个结束点不与起始点相连的图形。这些图形会创建⼀个结束点和起始点⽤直线相连的填
充区域。如果在结束时与其他的边有交叉，fill-rule 属性就会计算并应⽤。    

即使是⼀个 &lt;line&gt; 元素严格来说也是默认填充的：因为连接终点与起始点的返回线与原线完全重合，
所以最后的形状不包括任何区域。形状内是没有点的，所以没有点被填充值影响。如果你想看到它，就得给它
加 stroke。     

## 2.2 使用 stroke 属性描边

在 SVG 中（⽬前如此），描边的实现⽅式是沿着主形状的边线向内和向外延伸出辅助形状。该描边区域使⽤
与填充主形状相同的⽅式来渲染：软件会依次扫描并确定某个点是否在描边区域的内部。如果在，软件就会
使⽤ stroke 属性设置的渲染指令来设置颜⾊。    

stroke 的默认值是 none，即不渲染描边区域。就像 fill-opacity 属性会改变 fill 的效果⼀样，
描边同样也有 stroke-opacity 属性来改变它的效果。     

还有许多和描边相关的属性，它们可以控制描边区域的几何形状：    

- stroke-width: 描边宽度，其值可以是长度值、用户单位数或者坐标系宽和高的加权百分比。在 SVG1.1 中，
描边区域通常以形状的边为中⼼，所以描边的⼀半宽度在形状之内，⼀半在形状之外。    
- stroke-linecap: 用来给未闭合的路径或线条设置描边样式。其默认值 butt 会紧密修剪描边并且与
端点垂直。其他选项（round 和 square）会以特定形状（即分别以半圆形和方形）使用一半的描边宽度来
延伸描边。    
- stroke-linejoin: 该属性用于指定在形状中拐角的描边样式。其默认值 miter 在直线上延伸描边，
直到两条边在某一点相汇。其他可选值时 round（使用圆弧来连接两条描边）和 bevel（使用一根额外的
直线连接两条描边）。    
- stroke-miterlimit: 延伸斜接线可以超出形状边线的最大距离，是描边宽度的倍数（默认是宽度的四倍）。
如果描边在这个距离之内没有汇合，则使用 stroke-linejoin 值为 bevel 时的效果。   
- stroke-dasharray: 定义给形状间断描边时的距离模式（线和间隔）。其默认值 none 会给整个形状
添加连续的描边。每⼀条线的端点都受 stroke-linecap 值的影响。    
- stroke-dashoffset: 定义间断描边时起始偏移的距离。默认值是 0。    

## 2.3 层叠描边和填充

当⼀个图形同时拥有填充属性和描边属性时，描边区域和填充区域会有⼀部分重合的地⽅，因此重合部分会有
两种特定的颜⾊。在所有的 SVG 中，画家模型都适⽤：如果两种颜⾊都是不透明的，则上层的颜⾊将会替换
下层的颜⾊。     

默认情况下，描边是渲染在填充层之上的。这意味着你通常可以看到整个描边宽度，也意味着如果描边是半透
明的话，将显⽰出两种颜⾊。填充的颜⾊将会出现在描边区域内部⼀半之下⽽不是外部⼀半之下。    

SVG2 引入了 paint-order 属性，使用空格分隔的关键词（stroke, fill 以及 markers）列表来指示
图形的各部分被渲染的顺序：    

```svg
<path id="shape" d="..." stroke="blue" fill="red" paint-order="stroke fill" />
```    

在 paint-order 属性中没有定义的渲染层将会在之后渲染，并按照他们本来的顺序渲染。    
