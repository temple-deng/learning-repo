# HTTP2.0


<!-- TOC -->

- [HTTP2.0](#http20)
  - [1. HTTP/2 协议概览](#1-http2-协议概览)
  - [2. HTTP/2 启动](#2-http2-启动)
    - [2.1 HTTP/2 版本标识](#21-http2-版本标识)
    - [2.2 通过 http URIs 启动 HTTP/2](#22-通过-http-uris-启动-http2)
      - [2.2.1 HTTP2-Settings 首部](#221-http2-settings-首部)
    - [2.3 从 http URIs 启动 HTTP/2](#23-从-http-uris-启动-http2)
    - [2.4 在预先知道的前提下启动 HTTP/2](#24-在预先知道的前提下启动-http2)
    - [2.4 HTTP/2 Connection Preface](#24-http2-connection-preface)
  - [3. HTTP 帧](#3-http-帧)
    - [3.1 帧的格式](#31-帧的格式)
    - [3.2 帧的大小](#32-帧的大小)
    - [3.3 首部压缩和解压](#33-首部压缩和解压)
  - [4. 流和多路复用](#4-流和多路复用)
    - [4.1 流的状态](#41-流的状态)
      - [4.1.1 流标识符](#411-流标识符)
      - [4.1.2 流的并发](#412-流的并发)
    - [4.2 流量控制](#42-流量控制)
      - [4.2.1 流量控制的原则](#421-流量控制的原则)
    - [4.3 流的优先级](#43-流的优先级)
      - [4.3.1 流依赖](#431-流依赖)
      - [4.3.2 依赖权重](#432-依赖权重)
      - [4.3.3 重新排序](#433-重新排序)
    - [4.4 错误处理](#44-错误处理)
      - [4.4.1 连接错误处理](#441-连接错误处理)
      - [4.4.2 流错误处理](#442-流错误处理)
  - [5. 帧的定义](#5-帧的定义)
    - [5.1 DATA](#51-data)
    - [5.2 HEADERS](#52-headers)
    - [5.3 PRIORITY](#53-priority)
    - [5.4 RST_STREAM](#54-rst_stream)
    - [5.5 SETTINGS](#55-settings)
    - [5.6 PUSH_PROMISE](#56-push_promise)
    - [5.7 PING](#57-ping)
    - [5.8 GOAWAY](#58-goaway)

<!-- /TOC -->

## 1. HTTP/2 协议概览

HTTP2 通过将每个 HTTP 请求/响应的数据交换与其自身的流相关联，来实现请求的多路复用。流都是相互
独立的，因此一个阻塞或者缓慢的请求或者响应不会影响其他流中的处理。    

## 2. HTTP/2 启动

### 2.1 HTTP/2 版本标识

这份文档定义的 HTTP/2 协议有两种标识：   

- 字符串 'h2' 表示使用了 TLS 的 HTTP/2。在 TLS-ALPN 中，会使用这个标识符。换成八进制序列
就是 0x68 0x32
- 'h2c' 表示跑在了 TCP 明文上的 HTTP/2。通常在 HTTP/1.1 Upgrade 首部中使用这个。     

### 2.2 通过 http URIs 启动 HTTP/2

在不知道下一跳是否支持 HTTP/2 的情况下，客户端会在一个 http URI 请求中使用 HTTP Upgrage
机制。这样的一个 HTTP/1.1 请求，必须包含一个准确的 HTTP2-Settings 首部：   

```
GET / HTTP/1.1
Host: server.example.com
Connection: Upgrade, HTTP2-Settings
Upgrage: h2c
HTTP2-Settings: <base64url encoding of HTTP/2 SETTINGS payload>
```    

如果服务器不支持 HTTP/2 的话，就直接丢弃掉 Upgrade 首部进行响应：    

```
HTTP/1.1 200 OK
Content-Length: 243
Content-Type: text/html
```    

服务器必须忽略 Upgrade 首部中的 'h2' 符号。     

如果服务器支持 HTTP/2 就使用 101 进行响应。在发送完 101 响应后，服务器就可以开始发送 HTTP/2
帧了。    

```
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: h2c

[ HTTP/2 connection ...]
```    

服务器发送的第一个 HTTP/2 帧必须是一个 connection preface，由一个 SETTINGS 帧组成。在收到 101 
响应后，客户端也必须发送一个 SETTINGS 包含 connection preface。    

先前用来升级协议的 HTTP/1.1 请求被赋予了流 ID 为 1。    

#### 2.2.1 HTTP2-Settings 首部

如果在协议升级的请求中没有出现这个首部，或者说出现了不止一个，那服务器就不能将协议升级为 HTTP/2。    

### 2.3 从 http URIs 启动 HTTP/2

要说的内容上面都说了，在 TLS 协商完成后，客户端和服务器必须发送 connection preface。    

### 2.4 在预先知道的前提下启动 HTTP/2

客户端可能从某些渠道了解到某个特定的服务器是支持 HTTP/2 的。    

客户端首先必须发送 connection preface，并且可能会立刻发送一个 HTTP/2 帧给这样的一个服务器。服务器可以通过
连接配置的存在识别出这些连接。这种情况只影响通过明文 TCP 建立的 HTTP/2 连接。使用 TLS 支持的
HTTP/2 必须使用 ALPN。     

同理，服务器必须发送 connection preface。    

### 2.4 HTTP/2 Connection Preface

在 HTTP/2 中，每一端都被要求发送一个 connection preface 作为对使用协议的最终确认，并且需要
对 HTTP/2 连接进行初始的配置。客户端和服务器每一方发送一个不同的 connection preface。    

客户端 connection preface 由一个 24 的八进制流序列开头，16进制表示为：   

```
0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a
```    

换成字符串就是 `PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n`。这个序列后面必须紧跟一个 SETTINGS 帧，
不过这个帧可能是空的。客户端在接收到 101 响应，或者作为 TLS 连接的第一个应用层数据发送这个 preface。
如果是在知道支持 HTTP/2 的前提下启动的连接，在连接建立后就发送 preface。    

服务器 connection preface 必须是 HTTP/2 连接的的第一个帧，可能也会包含一个空的 SETTINGS 帧。   

任何一方在收到 connection preface 一部分的 SETTINGS 帧后，必须进行 ACK 确认。    

## 3. HTTP 帧

### 3.1 帧的格式

所有的帧都包含一个固定的 9 个字节的首部，后面跟着的是变长的负载。    

```
 +-----------------------------------------------+
 |                 Length (24)                   |
 +---------------+---------------+---------------+
 |   Type (8)    |   Flags (8)   |
 +-+-------------+---------------+-------------------------------+
 |R|                 Stream Identifier (31)                      |
 +=+=============================================================+
 |                   Frame Payload (0...)                      ...
 +---------------------------------------------------------------+
```     

帧首部的各字段定义如下：   

+ **Length:** 帧负载的长度，24 位无符号整数表示。大于 2<sup>14</sup>(16384) 的负载必须要
事先通知接收者进行配置，帧首部的 9 个字节不包含在其中
+ **Type:** 帧的类型，帧的类型决定了帧的格式与语义。
+ **Flags:** 一个标志位只在某些帧类型情况下生效。
+ **R**
+ **Stream Identifier:** 31 位无符号流标识符。0x0 是为了沟通连接参数而保留的流。    

### 3.2 帧的大小

SETTINGS_MAX_FRAME_SIZE 配置表明了发送方愿意接收的最大的帧的负载的大小。    

如果接收方收到了一个大于 SETTINGS_MAX_FRAME_SIZE 的帧，或者说帧的尺寸大于了该帧类型的长度
限制，那必须发送一个 FRAME_SIZE_ERROR错误码。    

### 3.3 首部压缩和解压

首部列表是零或多个首部字段的集合。当通过连接传输时，首部列表使用 HTTP 首部压缩机制序列化为一个
首部块。序列化后的首部块之后被分为一到多个字节序列，叫做 header block fragments，然后作为
HEADERS, PUSH_PROMISE, CONTINUATION 帧的负载进行传输。    

Cookie 首部是会进行特殊的处理的。    

接收方会通过拼接这些 fragments 重组首部块，然后将其解压，重建出首部列表。    

完整的首部块包括：    

+ 一个单一的 HEADERS 或者 PUSH_PROMISE 帧，帧的 END_HEADERS flag 置位，或者
+ 一个 HEADERS 或者 PUSH_PROMISE 帧，帧的 END_HEADERS1 flag 清零，并且还有一到多个
CONTINUATION 帧，最后一个 CONTINUATION 帧的 END_HEADERS flag 置位。     

首部压缩是有状态的。如果出现了解码的错误，那么必须将其视为一个 COMPRESSION_ERROR 类型的连接
错误。    

## 4. 流和多路复用

一个流是一个在客户端与服务器之间一个 HTTP/2 连接中的一个双向的独立的交换帧的序列。流有以下的几个
重要特征：   

+ 一个 HTTP/2 连接可以包含多个并发的打开的流
+ 流可以是单方面地被建立和使用，也可以被服务器和客户端共享
+ 流可以被任意一端关闭
+ 流中发送帧的顺序是重要的。接收方按照其收到的顺序处理帧。特别是，HEADERS 和 DATA 帧的顺序是
语义相关的。
+ 流由一个整数标志。初始化一个流的那一端负责给予流一个 ID。    

### 4.1 流的状态

流的生命周期：   

```
            
                             +--------+
                     send PP |        | recv PP
                    ,--------|  idle  |--------.
                   /         |        |         \
                  v          +--------+          v
           +----------+          |           +----------+
           |          |          | send H /  |          |
    ,------| reserved |          | recv H    | reserved |------.
    |      | (local)  |          |           | (remote) |      |
    |      +----------+          v           +----------+      |
    |          |             +--------+             |          |
    |          |     recv ES |        | send ES     |          |
    |   send H |     ,-------|  open  |-------.     | recv H   |
    |          |    /        |        |        \    |          |
    |          v   v         +--------+         v   v          |
    |      +----------+          |           +----------+      |
    |      |   half   |          |           |   half   |      |
    |      |  closed  |          | send R /  |  closed  |      |
    |      | (remote) |          | recv R    | (local)  |      |
    |      +----------+          |           +----------+      |
    |           |                |                 |           |
    |           | send ES /      |       recv ES / |           |
    |           | send R /       v        send R / |           |
    |           | recv R     +--------+   recv R   |           |
    | send R /  `----------->|        |<-----------'  send R / |
    | recv R                 | closed |               recv R   |
    `----------------------->|        |<----------------------'
                             +--------+

       send:   endpoint sends this frame
       recv:   endpoint receives this frame

       H:  HEADERS frame (with implied CONTINUATIONs)
       PP: PUSH_PROMISE frame (with implied CONTINUATIONs)
       ES: END_STREAM flag
       R:  RST_STREAM frame

```    

啥玩意啊这是。。。     

看样子，连接双方都拥有一个流状态的主观视图，这份视图在传输过程中可能双方是不同的。    

流包括以下的状态：   

**idle:**    

所有流开始时都处于 idle 状态，从这个状态开始可能有以下的状态过渡：   

- 发送或者接收到一个 HEADERS 帧会使流变为 "open" 状态。The same HEADERS frame can
also cause a stream to immediately become "half-closed".后面这句什么意思没弄懂
- 在其他流中发送的一个 PUSH_PROMISE 帧可能就标志出这个空闲的流，以便其能在以后使用前得到保留。
被保留的流的状态会变为 "reserved(local)"
- 同理，收到一个 PUSH_PROMISE 帧也会这样，被保留的流的状态变为 "reserved(remote)"    

处于这个状态的流如果收到除了 HEADERS or PRIORITY 以外的任何帧，都必须将其视为一个 PROTOCOL_ERROR
的连接错误。     

**reserved(local):**    

一个处于 "reserved(local)" 的流是为一个已经发送出去的 PUSH_PROMISE 帧预约而保留的。在这种
状态，只有以下的状态转变是可能的：    

- 端点可以发送一个 HEADERS 帧。这会造成流变为 "half-closed(remote)" 状态
- 任意一端可以发送一个 RST_STREAM 帧造成流变为 "closed" 状态。这会解除流的预约。    

这个状态下的流不能发送除 HEADERS, RST_STREAM, PRIORITY 帧以外的其他类型的帧。    

但是这个状态可能会收到 PRIORITY or WINDOW_UPDATE 帧。收到除了 RST_STREAM, PRIORITY,
WINDOW_UPDATE 以外的帧，流必须将其视为一个 PROTOCOL_ERROR 类型的连接错误。   

**reserved(remote):**    

处于 reserved(remote) 状态的流是被远端预定了的。    

在这种状态下，只有下面的状态转变是可能的：   

- 收到一个 HEADERS 帧，变为 "half-closed(local)" 状态
- 任意一方可以发送一个 RST_STREAM 帧，变为 "closed" 状态，释放对流的预定     

处于这个状态的流可能会发送一个 PRIORITY 帧来重新安排这个被预定的流。但是不能发送除 RST_STREAM,
PRIORITY, WINDOW_UPDATE 以外的帧。    

收到除 HEADER, RST_STREAM, PRIORITY 以外的帧，流就必须将其视为一个 PROTOCOL_ERROR 类型
的连接错误。     

**open:**     

一个处于 open 状态的帧可以被连接双方用来发送任意类型的帧。    

在这种状态下，任意一方都可能发送一个将 END_STREAM 置位的帧，从而造成流变为 "half-closed"
状态。发送方会变为 "half-closed(local)"，而接收方会变为 "half-closed(remote)" 状态。   

任意一方也可以发送一个 RST_STREAM 帧从而使流变为 "closed" 状态。   

**half-closed(local):**    

一个处在 "half-closed(local)" 的流不能再发送除 WINDOW_UPDATE, PRIORITY, RST_STREAM
以外的帧。    

当前状态的流会在收到一个 END_STREAM 置位的帧或者收到一个 RST_STREAM 帧后过渡到 "closed"
状态。    

这个状态的流还可以接收任意类型的帧，使用 WINDOW_UPDATE 帧提供流量控制的信息在继续接收
帧方面是很有必要的。    

**half-closed(remote):**    

处于这个状态的流表明对方不再会在该流上发送数据。    

如果端点收到了额外的帧，除了 WINDOW_UPDATE, PRIORITY, RST_STREAM 类型以外，端点
应该将其视为发生了 STREAM_ERROR 类型的流错误（注意这里是流错误，上面都是连接错误），
那么端点必须使用这个错误进行响应。    

当前流可以在发送一个包含 END_STREAM 置位的帧或者在发送或接收一个 RST_STREAM 帧后进入
"closed"。    

**closed:**     

"closed" 状态就是一个流最终的状态。    

在一个关闭的流上，端点就只能发送 PRIORITY 帧。在收到一个 RST_STREAM 帧后再收到除
PRIORITY 以外的任意类型的帧，端点都应该将其视为 STREAM_CLOSED 类型的流出错。类似的，
一个流如果在收到一个 END_STREAM 帧后再收到任意类型的帧，都应该将其视为一个 STREAM_CLOSED
类型的连接错误，除非是在下面描述的允许的帧。    

在发送了包含一个 END_STREAM 置位的 DATA 或 HEADERS 帧之后的很段一段时间内，流还可以
接收 WINDOW_UPDATE 或 RST_STREAM 帧。    

在一个关闭的流上可以发送 PRIORITY 帧来重新安排流的优先级。    

#### 4.1.1 流标识符

流使用一个无符号 31 位的整数标识。由客户端初始化的流必须使用奇数流 ID，由服务器初始
化的流必须使用偶数流 ID。ID 为 0 的流使用传送连接控制信息。    

新建立的流的 ID 必须要大于所有当前端点以及打开或者预留的流的 ID。如果一端收到一个意料
之外的流 ID，那么其应该使用 PROTOCOL_ERROR 类型的连接错误进行响应。    

新流 ID 的第一次使用，隐式的会关闭掉所有低 ID 的处于 idle 状态的流。   

流 ID 不可被重用，一个长连接可能会导致端点耗尽了所有可用的流 ID。这时，无法建立新流的
的客户端就只能建立新的连接来传输新流上的东西。而无法建立新流的服务器，可以发送一个
GOAWAY 帧，以便强制客户端去建立一个新的连接。    

#### 4.1.2 流的并发

一个对等方可能会在 SETTINGS 帧中使用 SETTINGS_MAX_CONCURRENT_STREAMS 限制当前活跃
的流的并发数量。最大并发流的数量是特定于一端的，并且只应用于接收到这个配置的一方。即，
客户端可以指定服务器可以初始化的并发流的数量，服务器可以指定客户端初始化并发流的数量。    

处在 "open" 或者 "half-closed" 状态的流会统计进并发流数量中。     

端点不能超过其对等方对它的限制，如果一端收到一个 HEADERS 帧，这个帧导致其超出了并发流的
限制，那么其应该将其视为一个 PROTOCOL_ERROR 或 REFUSED_STREAM 类型的流错误。    

### 4.2 流量控制

HTTP/2 使用 WINDOW_UPDATE 帧提供了流量控制功能。    

#### 4.2.1 流量控制的原则

HTTP2 中的流量控制具有以下的特征：   

1. 流量控制是特定于连接的。即，流量控制只控制一跳之间的流量，而不是整个端到端的路径
2. 流量控制是基于 WINDOW_UPDATE 帧的。接收者会告知对方其为一个流和整个连接准备好接收
多少字节了。
3. 流量控制是单方向由接收方控制的。发送方必须遵守接收方暴露出来的流量控制的大小。
4. 初始窗口大小是 65535，新流和整个连接都是这个
5. 帧的类型决定了流量窗口是否适用于该帧，目前，只有 DATA 帧是流量控制的主体。所有其他的
帧不会消耗流量窗口。
6. 流量控制不可被禁用。


### 4.3 流的优先级

客户端可以在一个打开一个流的 HEADERS 帧包含一些优先级信息，这些信息会用来设置这个新流的
优先级。在任意时刻，都可以使用 PRIORITY 帧来调整流的优先级。    

可以通过将流标记为依赖于其他流的完成，来对流进行优先级排序。每个依赖都会被赋予一个相对权重，
该数字用于确定分配给依赖于同一流的流的可用资源的相对比例。    

明确的为流设置的优先级仅仅是一个优先级过程的输入，它并不能保证针对该流会进行顺序的处理
或排序。一个端点也无法通过使用优先级强制对方以特定顺序处理流。**优先级只是一种建议**。   

#### 4.3.1 流依赖

每个流都可以明确指出依赖于另一个流。如果一个流不依赖任何的流，那么可以将依赖声明为 0x0。     

依赖于另一个流的流是一个依赖流（好拗口啊）。而依赖流所依赖的那个流叫做父流。     

一个独占标志位允许插入新级别的依赖项。这个标志位会造成流变成其父流的唯一依赖项，从而
导致其他依赖项依赖于独占流。例如，如果流 D 是独占依赖于流 A 的，那么会导致流 D 变为
B 和 C 的父依赖。   

```
                      A
    A                 |
   / \      ==>       D
  B   C              / \
                    B   C
```    

#### 4.3.2 依赖权重

所有的依赖流都会分到一个 1~256 之间的一个整数权重。   

具有相同父流的流依赖基于权重合理地分配资源。例如，流 B 依赖于流 A，权重为 4，流 C 依赖
于流 A，权重为 12。那么理想状态下，流 B 应该被分配三分之一流 C 分配的资源。   

#### 4.3.3 重新排序

流的优先级是可以使用 PRIORITY 帧修改的。    

如果重新设置优先级，那么依赖流会随着其父流一起移动。    

略。     

### 4.4 错误处理

HTTP2 帧允许两种类型的错误：   

+ 那些可以使整个连接不可用的错误叫做连接错误
+ 那些只发生在独立的流中的错误是流错误    

#### 4.4.1 连接错误处理

连接错误是指那些导致将来分帧层都无法工作或者摧毁了连接状态的错误。    

如果一端遇到了连接错误，那么它应该首先发送一个 GOAWAY 帧，帧中包含着其成功从对方接受到
的最后一个流的 ID。GOAWAY 帧包含一个错误码，表明了为什么连接被终止。在发送了 GOAWAY
帧后，端点必须关闭掉 TCP 连接。   

当然可能存在一种情况就是对方可能会没有收到 GOAWAY（比如说丢包）。因此，其实 GOAWAY 
只是尽自己最大的努力来告诉对方为什么连接被终止。    

#### 4.4.2 流错误处理

流错误是指那些相关于特定流的，并不影响其他流处理的错误。    

如果一端检测到了流错误，它会发送一个 RST_STREAM 帧，包含错误发生流的流 ID。同时它还包含
一个错误类型的错误码。   

RST_STREAM 是端点可以在一个流上发送的最后一个帧。    

为了避免循环，端点不能发送一个 RST_STREAM 帧作为对一个 RST_STREAM 帧的响应。   

## 5. 帧的定义

### 5.1 DATA

DATA 帧（type=0x0）传输与流相关的任意的、变长的字节序列。     

DATA 帧可能包含填充。填充是处于安全的目的，用于掩盖消息的长度。    

```
 +---------------+
 |Pad Length? (8)|
 +---------------+-----------------------------------------------+
 |                            Data (*)                         ...
 +---------------------------------------------------------------+
 |                           Padding (*)                       ...
 +---------------------------------------------------------------+
```    

但是你填充长度都告诉人家了，又如何起到安全的作用呢？？     

DATA 帧包含以下字段：   

+ **Pad Length:** 帧填充的长度，以字节为单位。仅在 PADDED 置位情况下出现。
+ **Data:**  应用数据
+ **Padding:** 均为 0.   

DATA 帧定义了以下标志位：   

- **END_STREAM(0x1):** 置位时表明这个帧是发送端在该流上发送的最后一个帧。
- **PADDED(0x8)**    

注意 Pad Length 和 Padding 是算在流量控制窗口之内的。     

### 5.2 HEADERS

HEADERS 帧(type=0x1) 用于打开一个流，并额外携带了 header block fragment。    

```
 +---------------+
 |Pad Length? (8)|
 +-+-------------+-----------------------------------------------+
 |E|                 Stream Dependency? (31)                     |
 +-+-------------+-----------------------------------------------+
 |  Weight? (8)  |
 +-+-------------+-----------------------------------------------+
 |                   Header Block Fragment (*)                 ...
 +---------------------------------------------------------------+
 |                           Padding (*)                       ...
 +---------------------------------------------------------------+
```    

后面重复的字段就不解释了，HEADERS 帧定义了以下的标志位：    

+ **END_STREAM(0x1)**
+ **END_HEADERS(0x4)**
+ **PADDED(0x8)**
+ **PRIORITY(0x20)**     

### 5.3 PRIORITY

PRIORITY(type=0x2)。    

```
 +-+-------------------------------------------------------------+
 |E|                  Stream Dependency (31)                     |
 +-+-------------+-----------------------------------------------+
 |   Weight (8)  |
 +-+-------------+
```    

PRIORITY 帧不包括任何标志位。   

### 5.4 RST_STREAM

RST_STREAM(type=0x3)立刻中断一个流。发送 RST_STREAM 通常用来请求取消一个流，或者表明
出现了错误。   

```
 +---------------------------------------------------------------+
 |                        Error Code (32)                        |
 +---------------------------------------------------------------+
```    

### 5.5 SETTINGS

SETTINGS(type=0x4)传输配置信息。同时也用于对配置参数的确认 ACK。   

SETTINGS 参数并非是协商参数，它们描述了发送的特征，这些参数由接收方使用。也就说，我发给你
的 SETTINGS 是用来限制你的行为的，不是限制我的。    

连接双方必须在连接建立的开始就互相向对方发送一个 SETTINGS 帧。并且在之后的时间内，可以
在任意时间再发送新的 SETTINGS。    

SETTINGS 帧中的每个参数都会直接替换掉现存的参数值。参数按照其出现的顺序进行处理。    

SETTINGS 参数由接收方进行确认。因此其定义了以下的标志位：   

+ **ACK(0x1):** 置位时，表明接收方确认了 SETTINGS 参数。设置了这个标志时，SETTINGS
帧的负载必须为空。    

SETTINGS 帧的流 ID 为 0x0。    

SETTINGS 帧的负载包括零到多个参数。每个参数包含一个无符号 16 位配置 ID 以及一个无符号
32 位配置值。   

```
 +-------------------------------+
 |       Identifier (16)         |
 +-------------------------------+-------------------------------+
 |                        Value (32)                             |
 +---------------------------------------------------------------+
```    

+ **SETTINGS_HEADER_TABLE_SIZE(0x1):** 允许发送方通知接收方，用来进行解码 header
blocks 的首部压缩的表格的最大尺寸。初始值为 4096 字节。
+ **SETTINGS_ENABLE_PUSH(0x2):** 初始值为 1，即允许服务端推送
+ **SETTINGS_MAX_CONCURRENT_STREAMS(0x3):** 发送方允许接收方初始化的最多的并发流的数量。
默认情况是无限制的。
+ **SETTINGS_INITIAL_WINDOW_SIZE(0x4):** 发送方为流级设置的流量控制窗口大小。这个配置
会影响所有的流。
+ **SETTINGS_MAX_FREAM_SIZE(0x5):**
+ **SETTINGS_MAX_HEADER_LIST_SIZE(0x6):** 发送方准备接受的首部列表的最大的尺寸，基于
未压缩首部字段大小。包含字段名和字段值，以及每个字段的 32 字节的开销（这是什么意思）    

### 5.6 PUSH_PROMISE

PUSH_PROMISE(type=0x5)。    

```
 +---------------+
 |Pad Length? (8)|
 +-+-------------+-----------------------------------------------+
 |R|                  Promised Stream ID (31)                    |
 +-+-----------------------------+-------------------------------+
 |                   Header Block Fragment (*)                 ...
 +---------------------------------------------------------------+
 |                           Padding (*)                       ...
 +---------------------------------------------------------------+
```    

PUSH_PROMISE 包含两个标志位：   

+ **END_HEADERS(0x4):**
+ **PADDED**    

PUSH_PROMISE 帧必须在一个 "open" 或者 "half-closed(remote)" 状态的流上发送。    

PUSH_PROMISE 的接收方式可以选择拒绝推送的，即发送方一个 RST_STREAM 帧在被预约的流上。   

一个 PUSH_PROMISE 帧可以以两种方式修改连接的状态。首先，包含 header block 会潜在地修改
连接双方维护的首部压缩表。第二点，PUSH_PROMISE 会预约一个流。    

### 5.7 PING

PING(type=0x6) 测量最小 RTT，以及确定空闲的连接是否仍然可用。   

```
 +---------------------------------------------------------------+
 |                                                               |
 |                      Opaque Data (64)                         |
 |                                                               |
 +---------------------------------------------------------------+
```   

PING 帧必须包含 8 个字节的数据在负载中。发送者可以包含任意的值在这 8 个字节中。   

如果接收方收到了一个 ACK 标志未置位的 PING 帧，那他必须发送一个 ACK 置位的 PING 帧
作为响应，以及相同的负载。   

+ **ACK(0x1)**   

PING 帧在流 0x0 上发送和接收。   

### 5.8 GOAWAY

GOAWAY(type=0x7) 初始化关闭一个连接。   

GOAWAY 帧中通常包含发送方最后正常接收到的发送方初始化的 ID 最大的流的 ID。   

一旦发送了 GOAWAY 帧，发送方会忽略接收方初始化的流 ID 大于帧中流 ID 的所有流上的任意帧。    

```
 +-+-------------------------------------------------------------+
 |R|                  Last-Stream-ID (31)                        |
 +-+-------------------------------------------------------------+
 |                      Error Code (32)                          |
 +---------------------------------------------------------------+
 |                  Additional Debug Data (*)                    |
 +---------------------------------------------------------------+
```   

Last-Update: 2018-11-16
