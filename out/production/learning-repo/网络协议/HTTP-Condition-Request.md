# HTTP 条件请求

## 主要原则

HTTP 条件请求会根据不同的首部值执行不同的操作。这些首部会定义一个前提，请求的结果会根据前提满足与否而返回不同的结果。  

这种差异行为是由请求使用的方法及设置的前提的首部的定义的：  

+ 对于安全的方法来说，例如 GET，条件请求可能会在有必要的情况下返回文档。
+ 对于不安全的方法来说，例如 PUT，上传文件，只有在之前上传的内容与当前内容是处于同一服务器上时，条件请求才会上传内容。  

## 验证器

所有的条件首部都会检查是否服务器上资源匹配给定的版本，所以一般来说，条件首部都会指定一个资源的版本。这些版本值就被叫做验证器，分为下面两种类型：  

+ 文档上次的修改日期, `last-modified`。
+ 一个不透明的字符串，用来唯一识别一个版本，`entity tag` or `etag`。  

比较同于资源的版本时会有些复杂：根据上下文，有两种类型的质量检测：  

+ 当期望每个字节都相同时，使用强验证 `Strong validation`。例如当恢复下载时。
+ 当用户代理只需要确认是否两份资源有相同的内容时使用弱验证 `Weak validation`。  

验证的类型是与使用的验证器相互独立的。两种类型的验证器都支持强弱验证。HTTP 默认使用强验证。  

相对来说 `Last-Modified` 使用一个唯一的标识符来实现强验证是比较困难的。通常来说使用资源
的MD5 值在 `ETag` 中来实现强验证。  

弱验证不考虑两份资源是否是相同的，只考虑两份资源是否可以认作是相等的。    

## 条件首部

+ If-Match: 如果资源的ETag与这个首部列表中的某一个相等就是匹配成功。默认情况下，除非 etag 前缀了 `'W/'`,否则都是强验证。  

+ If-None-Match: 如果资源的ETag与这个首部列表中的每一个都不相等就是匹配成功。默认情况下，除非 etag 前缀了 `'W/'`,否则都是强验证。   

+ If-Modified-Since: 如果资源的 Last-Modified 比首部的时间更接近限制就是匹配成功。  

+ If-Unmodified-Since: 如果资源的 Last-Modified 比首部的时间更老限制就是匹配成功。

+ If-Range: 类似于 If-Match, If-Unmodified-Since。但是只有一个 etag 或者 date。  

## Cache-Control

注意，服务器和客户端都可以用 `Cache-Control` 来说明新鲜度。所有下面很多指令都有两个版本。  

| 指令 | 报文类型 | 描述 |
| :------------- | :------------- | :------------- |
| no-cache | 请求 | 在重新向服务器验证之前，不要返回文档的缓存副本 |
| no-store | 请求 | 不要返回文档的缓存副本。不要保存服务器的响应。 |
| max-age | 请求 | 缓存中的文档不能超过指定的试用期。 |
| max-stale | 请求 | 文档允许过期（根据服务器提供的过期信息计算），但不能超过指令中指定的过期值。max-age 相当于我们请求自己设置一个有效期，那么只要在有效期就可以返回副本，max-stale 是相对于副本设置的过期日期的，假设副本有效期为1天，我们 max-stale 为2天，那么其实在副本过期后的两天内都可以用副本返回 |
| min-fresh | 请求 | 文档的使用期不能小于这个指定的时间与它的当前存活时间之和。换句话说，响应必须至少在这段时间内保持新鲜。（没懂这个） |
| no-transform | 请求 | 文档在发送之前不允许被转换 |
| only-if-cached | 请求 | 只有文档在缓存中才发送，不要联系原始服务器 |
| public | 响应 | 响应可以被任何服务器缓存 |
| private | 响应 | 响应可以被缓存，但只能被单个客户端访问 |
| no-cache | 响应 | 如果该指令伴随一个首部列表的话，那么内容可以被缓存并提供给客户端，但必须先删除所列出的首部。如果没有指定首部，缓存中的副本在没有重新向服务器验证之前不能提供给客户端 |
| no-store | 响应 | 响应不允许被缓存 |
| no-transform | 响应 |  响应在提供给客户端之前不能做任何形式的修改 |
| must-revalidate | 响应 | 响应在提供给客户端之前必须重新向服务器验证 |
| proxy-revalidate | 响应 | 共享的缓存在提供给客户端之前必须向原始的服务器验证。私有的缓存可以忽略这条指令。|
| max-age | 响应 | 指定文档可以被缓存以及新鲜度的最长时间 |
| s-max-age | 响应 | 指定文档作为共享缓存的最长使用时间。私有的缓存可以忽略本指令。 |


## 官方文档的内容

### 1. 验证器

#### 1.1 Weak versus Strong

有两种形式的验证器：strong or weak。弱验证器很容易生成，但是在比较的时候作用不大。强
验证器是比较时的理想选择，但是生成不够高效。HTTP 并没有强制大家都使用一致强度的验证器，
HTTP 在使用验证器时会暴露出验证器的类型，并在使用弱验证器时施加了一些限制。   

#### 1.2 Last-Modified

Last-Modified 时间验证器通常认为属于弱验证器，除非其满足以下条件之一，这时候就可以认为
它是强验证器：   

+ 服务器将这个时间与当前时间进行比较，然后得出资源没有发生过变动的结论（好奇这种情况下，
服务器是如何拿到旧的验证器时间的，难道是服务器做了缓存）
+ 客户端将这个验证器，也就是时间通过包含在 If-Modified-Since, If-Unmodified-Since,
If-Range 之一的首部发送给了服务器，并且请求还附带着响应时的 Date 值，那么
Last-Modified 值至少要比 Date 提前 60s。 
+ 一个中间缓存服务器，使用这个缓存中的验证器和 Date 比，Last-Modified 要比 Date 提前
60s。    

#### 1.3 ETag

注意 ETAG 是一个带双引号的字符串：   

```
ETag: "xyzzy"
ETag: W/"xyzzy"
ETag: ""
```    

ETag 即可能是强验证器，也可能是弱验证器。默认是强的。前缀 W/ 的就表明服务器将这个验证器
标示为弱验证器，注意 W 是大小写敏感的。   

##### 1.3.1 比较

有两种实体标签比较函数，使用哪种取决了当前比较上下文是否允许使用弱验证器：   

+ 强比较。两者都不是弱验证器，且两者是字符与字符相等的。
+ 弱比较。好像是引号内的东西是字符与字符相等的即可，而不管两者是不是弱验证器。    

### 1.4 何时使用 ETag 和 Last-Modified

对于服务器对 GET or HEAD 方法的 200 响应：   

+ 服务器在可以的情况下应该发送一个 ETag
+ 如果强 ETag 由于性能或者其他原因不好生成的话，可以发送一个弱 ETag
+ 可能的情况下应该发送一个 Last-Modified     

换句话说，最好的情况是同时发送一个强 Etag 和一个 Last-Mofified。    

同时客户端：    

+ 如果服务器在缓存中提供了 ETag，那么客户端必须在任意的缓存验证请求中发送 ETag（通过
If-Match 和 If-None-Match）
+ 如果服务器在缓存中提供了 Last-Modified，那么客户端应该在非子范围的缓存验证请求中发送
Last-Modified 值（通过 If-Modified-Since）
+ 如果服务器两个都提供了，那客户端就应该在任意的缓存验证请求中将两者都发送    

### 2. 先决条件首部

#### 2.1 If-Match

首部值可以是一个通配符 \*，或者是一个实体标签的列表。如果是通配符则服务器至少要有一个匹配
的资源，而列表的话也一样，至少有一个匹配的资源。    

服务器在应对这个首部时，必须使用强比较函数。    

```
If-Match: "xyzzy"
If-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
If-Match: *
```    

这个首部通常用于一些会引起状态改变的方法，例如 POST, PUT, DELETE，以阻止当多个用户并行
的对同一个资源进行操作时的操作覆盖。    

服务器在收到一个带有这个首部的请求时，必须在执行方法前计算条件。如果首部值是 "\*"，
那么当服务器对资源没有任意一份内容时，条件返回 false。如果是一个列表，那服务器如果没有
一个匹配的内容时，条件返回 false。    

如果条件的结果是 false，那么服务器就不能执行请求的方法。这时候服务器必须使用一个
412 Precondition Failed 进行响应，或者是在服务器已经验证了请求的状态改变已经进行过了，
就发回 2xx 的码。也就是说 false 也是可以返回 2xx 的。在第二种情况下，除非服务器是可以
验证请求是同一个客户发的冗余的一份请求，否则其不能在响应中包含一个验证器首部。   

这个首部会被缓存服务器和中间服务器忽略，因为其不适用于响应的存储。   

