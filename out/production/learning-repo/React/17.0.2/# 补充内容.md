# 补充内容    

<!-- TOC -->

- [补充内容](#补充内容)
  - [PriorityLevel](#prioritylevel)
  - [Lane](#lane)
  - [ReactDOM](#reactdom)
  - [EC](#ec)
  - [UpdateLane](#updatelane)
  - [第一次渲染](#第一次渲染)
  - [updateHostRoot](#updatehostroot)
  - [updateClassComponent](#updateclasscomponent)
  - [begin(App-div)](#beginapp-div)
  - [begin(header)](#beginheader)
  - [complete(header)](#completeheader)
  - [begin(Content)](#begincontent)
  - [begin(content-p1)](#begincontent-p1)
  - [complete(Content)](#completecontent)
  - [complete(div)](#completediv)
  - [complete(App)](#completeapp)
  - [complete(hostRoot)](#completehostroot)
  - [performSyncWorkOnRoot](#performsyncworkonroot)
- [更新](#更新)
  - [概述](#概述)
    - [begin(hostRoot)](#beginhostroot)
  - [begin(App)](#beginapp)
    - [begin(Header)](#beginheader-1)
    - [begin(Div)](#begindiv)
    - [complete(div)](#completediv-1)
    - [complete(App)](#completeapp-1)
- [渲染](#渲染)
  - [第一部分](#第一部分)
  - [第二部分](#第二部分)
  - [第三阶段](#第三阶段)
- [Hook](#hook)

<!-- /TOC -->

## PriorityLevel   

priorityLevel 数字枚举变量：0 - 5。   

```tsx
export const NoPriority = 0;
export const ImmediatePriority = 1;
export const UserBlockingPriority = 2;
export const NormalPriority = 3;
export const LowPriority = 4;
export const IdlePriority = 5;
```    

默认是 NormalPriority。    

## Lane    

数字量。二进制量。     

```tsx
type Lane = number;
type Lanes = number;
export const NoLanes: Lanes = /*                        */ 0b0000000000000000000000000000000;
export const NoLane: Lane = /*                          */ 0b0000000000000000000000000000000;

export const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000001;
export const SyncBatchedLane: Lane = /*                 */ 0b0000000000000000000000000000010;

export const InputDiscreteHydrationLane: Lane = /*      */ 0b0000000000000000000000000000100;
const InputDiscreteLanes: Lanes = /*                    */ 0b0000000000000000000000000011000;

const InputContinuousHydrationLane: Lane = /*           */ 0b0000000000000000000000000100000;
const InputContinuousLanes: Lanes = /*                  */ 0b0000000000000000000000011000000;

export const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000100000000;
export const DefaultLanes: Lanes = /*                   */ 0b0000000000000000000111000000000;

const TransitionHydrationLane: Lane = /*                */ 0b0000000000000000001000000000000;
const TransitionLanes: Lanes = /*                       */ 0b0000000001111111110000000000000;

const RetryLanes: Lanes = /*                            */ 0b0000011110000000000000000000000;

export const SomeRetryLane: Lanes = /*                  */ 0b0000010000000000000000000000000;

export const SelectiveHydrationLane: Lane = /*          */ 0b0000100000000000000000000000000;

const NonIdleLanes = /*                                 */ 0b0000111111111111111111111111111;

export const IdleHydrationLane: Lane = /*               */ 0b0001000000000000000000000000000;
const IdleLanes: Lanes = /*                             */ 0b0110000000000000000000000000000;

export const OffscreenLane: Lane = /*                   */ 0b1000000000000000000000000000000;
```    


## ReactDOM

```tsx
root = container._reactRootContainer = legacyCreateRootFromDOMContainer(
    container,
    forceHydrate,
);
fiberRoot = root._internalRoot;
```

所以 `container._reactRootContainer` 是一个 `ReactDOMBlockingRoot` 对象，而其上面的 `_internalRoot` 是 FiberRoot 节点。    

FiberRoot 的 current 是 hostRootFiber 节点，而 hostRootFiber.stateNode 又是 FiberRoot。   

## EC

```tsx
type ExecutionContext = number;

export const NoContext = /*             */ 0b0000000;
const BatchedContext = /*               */ 0b0000001;
const EventContext = /*                 */ 0b0000010;
const DiscreteEventContext = /*         */ 0b0000100;
const LegacyUnbatchedContext = /*       */ 0b0001000;
const RenderContext = /*                */ 0b0010000;
const CommitContext = /*                */ 0b0100000;
```    

## UpdateLane   

在React体系中, 有 2 种情况会创建update对象:   

1. 应用初始化: 在react-reconciler包中的updateContainer函数中    


```tsx
export function updateContainer(
  element: ReactNodeList,
  container: OpaqueRoot,
  parentComponent: ?React$Component<any, any>,
  callback: ?Function,
): Lane {
  const current = container.current;
  const eventTime = requestEventTime();
  const lane = requestUpdateLane(current); // 根据当前时间, 创建一个update优先级
  const update = createUpdate(eventTime, lane); // lane被用于创建update对象
  update.payload = { element };
  enqueueUpdate(current, update);
  scheduleUpdateOnFiber(current, lane, eventTime);
  return lane;
}
```    


2. 发起组件更新: 假设在 class 组件中调用setState    

```tsx
const classComponentUpdater = {
  isMounted,
  enqueueSetState(inst, payload, callback) {
    const fiber = getInstance(inst);
    const eventTime = requestEventTime(); // 根据当前时间, 创建一个update优先级
    const lane = requestUpdateLane(fiber); // lane被用于创建update对象
    const update = createUpdate(eventTime, lane);
    update.payload = payload;
    enqueueUpdate(fiber, update);
    scheduleUpdateOnFiber(fiber, lane, eventTime);
  },
};
```     

3 种 lane 相关的地方，updateLane 保存在 Update 对象上，表示每次更新的 lane，
渲染的 lane，保存在 fiberRoot 上，pendingLanes 等等，表示当前整体的 lanes 状态，
还有 fiber.lanes, fiber.childLanes 表示当前节点目前所有的 lanes，这个东西应该是
当前节点所包含的所有 updateLane 的 `|`。   


如果全局的渲染优先级renderLanes不包括fiber.lanes, 证明该fiber节点没有更新, 可以复用.
如果不能复用, 进入创建阶段.    

这里感觉说的不准确，应该是 renderLanes 不包括 fiber.lanes，证明本次渲染的内容不包含当前的更新，
当前 fiber 节点暂时不用更新。    

## 第一次渲染    

requestUpdateLane 在 legacy 模式下永远都是 SyncLane。   

`unbatchedUpdate -> updateContainer -> scheduleUpdateOnFiber -> performSyncWorkOnRoot`。    

```tsx
function performSyncWorkOnRoot(root) {
  invariant(
    (executionContext & (RenderContext | CommitContext)) === NoContext,
    'Should not already be working.',
  );

  flushPassiveEffects();

  let lanes;
  let exitStatus;
  // 第一次更新 wipr = null 不走这个 if
  if (
    root === workInProgressRoot &&
    includesSomeLane(root.expiredLanes, workInProgressRootRenderLanes)
  ) {
    // There's a partial tree, and at least one of its lanes has expired. Finish
    // rendering it before rendering the rest of the expired work.
    lanes = workInProgressRootRenderLanes;
    exitStatus = renderRootSync(root, lanes);
    if (
      includesSomeLane(
        workInProgressRootIncludedLanes,
        workInProgressRootUpdatedLanes,
      )
    ) {
      lanes = getNextLanes(root, lanes);
      exitStatus = renderRootSync(root, lanes);
    }
  } else {
    // 这里 getNextLanes 好像就是当前这次 work 的 lanes
    // 除非可能有其他优先级的已存 work，那可能压过本次的 lanes
    lanes = getNextLanes(root, NoLanes);
    // 这里构建 fiber 树
    exitStatus = renderRootSync(root, lanes);
  }


  if (exitStatus === RootFatalErrored) {
    const fatalError = workInProgressRootFatalError;
    prepareFreshStack(root, NoLanes);
    markRootSuspended(root, lanes);
    ensureRootIsScheduled(root, now());
    throw fatalError;
  }

  // We now have a consistent tree. Because this is a sync render, we
  // will commit it even if something suspended.
  const finishedWork: Fiber = (root.current.alternate: any);
  root.finishedWork = finishedWork;
  root.finishedLanes = lanes;
  commitRoot(root);

  // Before exiting, make sure there's a callback scheduled for the next
  // pending level.
  ensureRootIsScheduled(root, now());

  return null;
}
```    


进入 renderRootSync:   

```tsx
function renderRootSync(root: FiberRoot, lanes: Lanes) {
  const prevExecutionContext = executionContext;
  executionContext |= RenderContext;
  const prevDispatcher = pushDispatcher();

  // If the root or lanes have changed, throw out the existing stack
  // and prepare a fresh one. Otherwise we'll continue where we left off.
  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    // 这个会处理好 wip 和 wipr
    prepareFreshStack(root, lanes);
    startWorkOnPendingInteractions(root, lanes);
  }

  const prevInteractions = pushInteractions(root);

  do {
    try {
      workLoopSync();
      break;
    } catch (thrownValue) {
      handleError(root, thrownValue);
    }
  } while (true);
  resetContextDependencies();
  if (enableSchedulerTracing) {
    popInteractions(((prevInteractions: any): Set<Interaction>));
  }

  executionContext = prevExecutionContext;
  popDispatcher(prevDispatcher);

  if (workInProgress !== null) {
    // This is a sync render, so we should have finished the whole tree.
    invariant(
      false,
      'Cannot commit an incomplete root. This error is likely caused by a ' +
        'bug in React. Please file an issue.',
    );
  }

  if (__DEV__) {
    if (enableDebugTracing) {
      logRenderStopped();
    }
  }

  if (enableSchedulingProfiler) {
    markRenderStopped();
  }

  // Set this to null to indicate there's no in-progress render.
  workInProgressRoot = null;
  workInProgressRootRenderLanes = NoLanes;

  return workInProgressRootExitStatus;
}
```   

进入 workLoopSync:   

```tsx
function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
```   

我们构建新 tree 的时候是在 wip，这个要记住，所以遍历处理的是 wip。  

```tsx
function performUnitOfWork(unitOfWork: Fiber): void {
  // The current, flushed, state of this fiber is the alternate. Ideally
  // nothing should rely on this, but relying on it here means that we don't
  // need an additional field on the work in progress.
  const current = unitOfWork.alternate;

  let next = beginWork(current, unitOfWork, subtreeRenderLanes);

  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next === null) {
    // If this doesn't spawn new work, complete the current work.
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }

  ReactCurrentOwner.current = null;
}
```    

beginWork 的内容就大了，删掉一些不用的内容，首先首次渲染的时候 renderLanes 应该就一个 SyncLane，因为 legacy 模式 requestUpdateLane 好像统一返回 SyncLane，然后传到
fiberRoot.pendingLanes 中，进而在 prepareFreshStack 中传到 wipRenderLanes, subtreeRenderLanes 等等：    

```tsx
function beginWork(
    current: Fiber | null,
    workInProgress: Fiber,
    renderLanes: Lanes,
): Fiber | null {
    const updateLanes = workInProgress.lanes;

    if (current !== null) {
        // 更新流程，初次构建不涉及
        // 但是首次构建的 hostRootFiber 要进来
        // 但首次构建 hostRootFiber 也就下面这点省略一些条件
        didReceiveUpdate = false;
    } else {
        didReceiveUpdate = false;
    }
    workInProgress.lanes = NoLanes;

    switch (workInProgress.tag) {
        case FunctionComponent: {
            const Component = workInProgress.type;
            const unresolvedProps = workInProgress.pendingProps;
            const resolvedProps =
                workInProgress.elementType === Component
                    ? unresolvedProps
                    : resolveDefaultProps(Component, unresolvedProps);
            return updateFunctionComponent(
                current,
                workInProgress,
                Component,
                resolvedProps,
                renderLanes,
            );
        }
        case ClassComponent: {
            const Component = workInProgress.type;
            const unresolvedProps = workInProgress.pendingProps;
            const resolvedProps =
                workInProgress.elementType === Component
                    ? unresolvedProps
                    : resolveDefaultProps(Component, unresolvedProps);
            return updateClassComponent(
                current,
                workInProgress,
                Component,
                resolvedProps,
                renderLanes,
            );
        }
        case HostRoot:
            return updateHostRoot(current, workInProgress, renderLanes);
        case HostComponent:
            return updateHostComponent(current, workInProgress, renderLanes);
        case HostText:
            return updateHostText(current, workInProgress);
    }
}
```    

beginWork(current, unitOfWork, subtreeRenderLanes)针对所有的 Fiber 类型, 其中的每一个 case 处理一种 Fiber 类型. updateXXX函数(如: updateHostRoot, updateClassComponent 等)的主要逻辑:   

1. 根据 ReactElement对象创建所有的fiber节点, 最终构造出fiber树形结构(设置return和sibling指针)
2. 设置fiber.flags(二进制形式变量, 用来标记 fiber节点 的增,删,改状态, 等待completeWork阶段处理)
3. 设置fiber.stateNode局部状态(如Class类型节点: fiber.stateNode=new Class())    

所以针对 hostRootFiber 节点，进到 `updateHostRoot`。    

大致 beiginWork 是这样：   

1. 有 current 节点
  1. props 有更新或者 context 有更新 didReceiveUpdate = true，return updateXXX
  2. 节点没有更新的属性，同时节点 lanes 不在 renderLanes，可以复用
  3. 节点没有更新的属性，但是也不能复用，当前节点可能触发了更新，didReceiveUpdate = false，return updateXXX
2. 无 current 节点，didReceiveUpdate, return updateXXX    

可以简单想一下我们开发过程中可能遇到的一些情形，一个节点调用了 setState 触发了更新，从 hostRoot 开始，在当前节点之上的祖先节点，大概率走了 1.2 因为基本上能
复用，在遇到当前节点时，可能走 1.3，然后当前节点的后代节点可能走 1.1 或者 1.2。    

而首次渲染的节点可能直接走 2.    

updateXXX函数(如: updateHostRoot, updateClassComponent 等)虽然 case 较多, 但是主要逻辑可以概括为 3 个步骤:

1. 根据fiber.pendingProps, fiber.updateQueue等输入数据状态, 计算fiber.memoizedState作为输出状态
2. 获取下级ReactElement对象
    1. class 类型的 fiber 节点
        -构建React.Component实例
        - 把新实例挂载到fiber.stateNode上
        - 执行render之前的生命周期函数
        - 执行render方法, 获取下级reactElement
        - 根据实际情况, 设置fiber.flags
    2. function 类型的 fiber 节点
        - 执行 function, 获取下级reactElement
        - 根据实际情况, 设置fiber.flags
    3. HostComponent 类型(如: div, span, button 等)的 fiber 节点
        - pendingProps.children作为下级reactElement
        - 如果下级节点是文本节点,则设置下级节点为 null. 准备进入completeUnitOfWork阶段
        - 根据实际情况, 设置fiber.flags
    4. 其他类型...
3. 根据ReactElement对象, 调用reconcileChildren生成Fiber子节点(只生成次级子节点)
    - 根据实际情况, 设置fiber.flags

首先看 hostRoot，这个节点应该每次都是走 1.3，走updateHostRoot，而这种节点有什么更新的呢，大概率就是唯一的子节点会有变化，或者是其 props 变化，或者是节点直接换类型了，而且大概率
是通过反复 `ReactDOM.render`，否则就基本都是后代更新，当前就直接往下过就行。   

## updateHostRoot

```tsx
function updateHostRoot(current, workInProgress, renderLanes) {
    pushHostRootContext(workInProgress);
    const updateQueue = workInProgress.updateQueue;
    const nextProps = workInProgress.pendingProps;
    const prevState = workInProgress.memoizedState;
    const prevChildren = prevState !== null ? prevState.element : null;
    cloneUpdateQueue(current, workInProgress);
    // processUpdateQueue 貌似只在 hostRoot 和 class 组件中会用到
    // 处理 updateQueue，应用 update 计算新的 state，更新 memorizedState
    // 同时还可能会处理 flags 和 effects
    processUpdateQueue(workInProgress, nextProps, null, renderLanes);
    const nextState = workInProgress.memoizedState;
    // Caution: React DevTools currently depends on this property
    // being called "element".
    // 针对 hostRoot 来说，这个 element 就是 ReactDOM.render 中的跟组件
    const nextChildren = nextState.element;
    // 如果两次更新是一个 ReactElement
    // 直接复用，否则根据 ReactElement
    if (nextChildren === prevChildren) {
        resetHydrationState();
        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    }
    const root: FiberRoot = workInProgress.stateNode;
    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
    resetHydrationState();


    return workInProgress.child;
}
```   

和上面说的差不多，首先计算了新的 state，然后调用 reconcilerChildren 计算后代。
这个函数应该是相当于我们现在有了 fiber 节点，然后需要根据 fiber 节点对应的 ReactElement，计算后代的 fiber 节点。    

```tsx
function reconcileChildren(
  current: Fiber | null,
  workInProgress: Fiber,
  nextChildren: any,
  renderLanes: Lanes,
) {
  if (current === null) {
    // If this is a fresh new component that hasn't been rendered yet, we
    // won't update its child set by applying minimal side-effects. Instead,
    // we will add them all to the child before it gets rendered. That means
    // we can optimize this reconciliation pass by not tracking side-effects.
    workInProgress.child = mountChildFibers(
      workInProgress,
      null,
      nextChildren,
      renderLanes,
    );
  } else {
    // If the current child is the same as the work in progress, it means that
    // we haven't yet started any work on these children. Therefore, we use
    // the clone algorithm to create a copy of all the current children.

    // If we had any progressed work already, that is invalid at this point so
    // let's throw it out.
    workInProgress.child = reconcileChildFibers(
      workInProgress,
      current.child,
      nextChildren,
      renderLanes,
    );
  }
}
```   

mountChildFibers 和 reconcileChildFibers 事实上是一个函数，区别仅在于是否追踪副作用，这里副作用只什么咱也不清楚，先已 hostRoot 带入看一下。    

具体就是执行这个：   


```tsx
// 需要注意的是这里 currentFirstChild 应该是 fiber 节点，而 newChild 还是 ReactElement 节点
return placeSingleChild(
    reconcileSingleElement(
        returnFiber,
        currentFirstChild,
        newChild,
        lanes,
    ),
);

// 首先根据 ReactElement 创建 fiber 节点
function reconcileSingleElement(
    returnFiber: Fiber,
    currentFirstChild: Fiber | null,
    element: ReactElement,
    lanes: Lanes,
): Fiber {
    // 根据 ReactElement 节点
    const created = createFiberFromElement(element, returnFiber.mode, lanes);
    // 这里好像对于非 string 的 ref 是直接返回了
    created.ref = coerceRef(returnFiber, currentFirstChild, element);
    created.return = returnFiber;
    return created;
}

function placeSingleChild(newFiber: Fiber): Fiber {
// This is simpler for the single child case. We only need to do a
// placement for inserting new children.
if (shouldTrackSideEffects && newFiber.alternate === null) {
    // 话说这里为什么直接赋值啊，不是 | 进去，这样不担心覆盖吗
    newFiber.flags = Placement;
}
    return newFiber;
}
```   

从 fiber 节点的创建过程能看出，fiber.elementType 就是 ReactElement.type，而fiber.type 是和热更新相关的，一般可能就是 elementType。    

这里相当于就是根据根组件创建了 fiber 节点。    

reconcileChildren 就是根据 element 创建了一个 fiber 节点并返回。   

也就是针对 hostRootFiber 来说，他的 beginWork 就是处理 updateQueue，计算 memorizedState，然后计算后代 fiber。  

那么这里 App 的 fiber 节点构建好了，开始对这个 fiber 节点的 work。    

## updateClassComponent

从 beginWork 开始看。由于 current 是 null，走 ClassComponent 的分支：   

```tsx
case ClassComponent: {
    const Component = workInProgress.type;
    const unresolvedProps = workInProgress.pendingProps;
    const resolvedProps =
        workInProgress.elementType === Component
            ? unresolvedProps
            : resolveDefaultProps(Component, unresolvedProps);
    return updateClassComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderLanes,
    );
}
```     

初次构建类组件的话，需要构建一个实例对象，绑定到 stateNode 属性，并且把实例的 state 赋给 fiber.memorizedState，同时设置 _reactInternals 属性。    

updateClassComponent 的话，基本上就调用了 3 个函数，`constructClassInstance` 初始化实例，`mountClassInstance` 处理 render 方法前的一些生命周期，看情况绑定 Update flag，最后是
`finishClassComponent`，调用类的 render 方法获取后代 ReactElement，然后调用 reconcileChildren 调和算法，处理后代节点，最后返回。    

与 hostRoot 不同的时，这里我们走的 mountChildFibers，最终应该还是走了
`placeSingleChild(reconcileSingElement())`，不过这里就不用打 Placement 的 flag 了，所以为什么不用打了呢，你看现在打不打的逻辑是，之前 App 是因为其 hostRoot 有 current，所以要追踪副作用，同时 App 没有 current，于是就打上了标签，
而到 App render 的 div 的时候，由于 App 没有 current，就不用追踪副作用了。   

可以这样理解，父节点存在但子节点不存在，需要添加 Placement flag，但是如果父节点就不存在，那就不用添加了，应该是因为父节点自身就会打上，那子节点就没必要了。    

即有父节点，新的子节点，Placement，没有父节点，在父节点上可能打了，子节点就不用了。    


## begin(App-div)    

beginWork 中属于 HostComponent:   

```tsx
    case HostComponent:
      return updateHostComponent(current, workInProgress, renderLanes);
```    

看下 updateHostComponent，这里就是直接 reconcileChildren 了，由于没有 current，继续走 mount 的分支，得把新节点 mount 上去。    

这里 reconcile 走了这个分支：   

```tsx
if (isArray(newChild)) {
    return reconcileChildrenArray(
        returnFiber,
        currentFirstChild,
        newChild,
        lanes,
    );
}
```   

这里就涉及到那个比较麻烦的 diff 算法了。但是尴尬的一点是，这里我们 current 应该是 null，估计就不用遍历。最终就是这里：   

```ts
if (oldFiber === null) {
  // If we don't have any more existing children we can choose a fast path
  // since the rest will all be insertions.
  for (; newIdx < newChildren.length; newIdx++) {
    // 这里就是创建了子 fiber 节点
    const newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
    if (newFiber === null) {
      continue;
    }
    // 这里就只是修改了 fiber.index 属性，不重要
    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
    // 这里就是链一下各个 fiber 节点，最终返回了第一个子节点的 fiber 节点
    if (previousNewFiber === null) {
      // TODO: Move out of the loop. This only happens for the first run.
      resultingFirstChild = newFiber;
    } else {
      previousNewFiber.sibling = newFiber;
    }
    previousNewFiber = newFiber;
  }
  return resultingFirstChild;
}
```    

## begin(header)    

beginWork 中应该还是 HostComponent，走 updateHostComponent 路线。   

不过在这个函数里面的执行逻辑，与上面 div 的不同，应该这里 header 的子节点是普通字符串，在 update 函数中会处理掉，不会继续往下生成后代 fiber 节点。    

最终在 mountChildFibers 中直接在最后返回：    

```tsx
return deleteRemainingChildren(returnFiber, currentFirstChild);
```   

这个东西直接返回 null 了，所有 header.child = null

仔细看看 reconcileChildFibers 有这么几个 reconcile 方法：   

- `reconcileChildrenArray`
- `reconcileChildrenIterator`
- `reconcileSingleTextNode`
- `reconcileSingleElement`
- `reconcileSinglePortal`    

那么在这个节点 beginWork 后，进入 completeUnitOfWork 的过程。   

## complete(header)

completeWork 的代码就不粘了，600多行。主要是对不同类型的 fiber 节点有不同的处理。HostComponent 类型的基本上是下面这些：    

```tsx
case HostComponent: {
  popHostContext(workInProgress);
  const rootContainerInstance = getRootHostContainer();
  const type = workInProgress.type;
  if (current !== null && workInProgress.stateNode != null) {
    updateHostComponent(
      current,
      workInProgress,
      type,
      newProps,
      rootContainerInstance,
    );

    if (current.ref !== workInProgress.ref) {
      markRef(workInProgress);
    }
  } else {
    if (!newProps) {
      invariant(
        workInProgress.stateNode !== null,
        'We must have new props for new mounts. This error is likely ' +
          'caused by a bug in React. Please file an issue.',
      );
      // This can happen when we abort work.
      return null;
    }

    const currentHostContext = getHostContext();
    // TODO: Move createInstance to beginWork and keep it on a context
    // "stack" as the parent. Then append children as we go in beginWork
    // or completeWork depending on whether we want to add them top->down or
    // bottom->up. Top->down is faster in IE11.
    const wasHydrated = popHydrationState(workInProgress);
    if (wasHydrated) {
      // TODO: Move this and createInstance step into the beginPhase
      // to consolidate.
      if (
        prepareToHydrateHostInstance(
          workInProgress,
          rootContainerInstance,
          currentHostContext,
        )
      ) {
        // If changes to the hydrated node need to be applied at the
        // commit-phase we mark this as such.
        markUpdate(workInProgress);
      }
    } else {
      const instance = createInstance(
        type,
        newProps,
        rootContainerInstance,
        currentHostContext,
        workInProgress,
      );

      appendAllChildren(instance, workInProgress, false, false);

      workInProgress.stateNode = instance;

      // Certain renderers require commit-time effects for initial mount.
      // (eg DOM renderer supports auto-focus for certain elements).
      // Make sure such renderers get scheduled for later work.
      if (
        finalizeInitialChildren(
          instance,
          type,
          newProps,
          rootContainerInstance,
          currentHostContext,
        )
      ) {
        markUpdate(workInProgress);
      }
    }

    if (workInProgress.ref !== null) {
      // If there is a ref on a host node we need to schedule a callback
      markRef(workInProgress);
    }
  }
  return null;
}
```

目测主要是下面这些代码：   

```tsx
const instance = createInstance(
  type,
  newProps,
  rootContainerInstance,
  currentHostContext,
  workInProgress,
);

appendAllChildren(instance, workInProgress, false, false);

workInProgress.stateNode = instance;

// Certain renderers require commit-time effects for initial mount.
// (eg DOM renderer supports auto-focus for certain elements).
// Make sure such renderers get scheduled for later work.
if (
  finalizeInitialChildren(
    instance,
    type,
    newProps,
    rootContainerInstance,
    currentHostContext,
  )
) {
  markUpdate(workInProgress);
}

if (workInProgress.ref !== null) {
  // If there is a ref on a host node we need to schedule a callback
  markRef(workInProgress);
}

return null;
```     

最终在 createInstance 中调用 `document.createElement` 创建了一个 DOM 元素。在 fiber 节点上，`__reactFiber$xxx` 的属性上，挂上对应的 DOM 元素。同时把 props 挂在了 dom 元素上的随机 key 属性上。   

然后在 appendAllChildren 中由于没有 children 直接返回。进入
finalizeInitialChildren 函数：   

```tsx
function finalizeInitialChildren(
  domElement: Instance,
  type: string,
  props: Props,
  rootContainerInstance: Container,
  hostContext: HostContext,
): boolean {
  setInitialProperties(domElement, type, props, rootContainerInstance);
  return shouldAutoFocusHostComponent(type, props);
}
```   

貌似没啥有用的内容，就是处理下 dom 元素的相关属性。由于只有自动 focus 的元素 finalize 函数才返回 true，所以一般的都返回 false。    

最后返回 null。    

那我们看看 completeWork 都干了什么。对于新创建的 dom 节点类型来说。主要就是创建对应的 DOM 元素，绑定到 fiber 树上。    

之后 completeUnitOfWork 重置了节点的 childLanes。  

然后是 effect 相关的，我们到这里好像还没有遇到过设置 effect 的。   

首先会把当前节点的 effect 添加到父节点的 effect 链表中。   


## begin(Content)    

这又是一个类组件，与 App 类似。这里主要不同的地方可能在 reconcile 那里，因为它 render 返回的是 `React.Fragment`。不过感觉还是走到了 `reconcileChildrenArray`。那和上面都差不多了，就是没有 Placement 的flag。   

## begin(content-p1)   

同上面的 header。   

## complete(Content)    

类组件的 completeWork 直接返回 null。那么它就会走后面的步骤，
重置它的 childLanes。    

不过 effect 那里还有不用管。但是 flags 那里要弄。    

```tsx
if (flags > PerformedWork) {
  if (returnFiber.lastEffect !== null) {
    returnFiber.lastEffect.nextEffect = completedWork;
  } else {
    returnFiber.firstEffect = completedWork;
  }
  returnFiber.lastEffect = completedWork;
}
```    

相当于把自身 fiber 节点赋值给了上层 div 对应 fiber 节点的 firstEffect 和 lastEffect 上，这也是我们程序第一次用到了 effect。   

然后回到上层 div 节点的 fiber。进行 completeUnitOfWork。   

## complete(div)    

这里 appendAllChildren 同上面的不同，要执行，因为 div.child 有内容。    

```tsx
appendAllChildren = function(
    parent: Instance,
    workInProgress: Fiber,
    needsVisibilityToggle: boolean,
    isHidden: boolean,
  ) {
    // We only have the top Fiber that was created but we need recurse down its
    // children to find all the terminal nodes.
    let node = workInProgress.child;
    while (node !== null) {
      if (node.tag === HostComponent || node.tag === HostText) {
        appendInitialChild(parent, node.stateNode);
      } else if (enableFundamentalAPI && node.tag === FundamentalComponent) {
        appendInitialChild(parent, node.stateNode.instance);
      } else if (node.tag === HostPortal) {
        // If we have a portal child, then we don't want to traverse
        // down its children. Instead, we'll get insertions from each child in
        // the portal directly.
      } else if (node.child !== null) {
        node.child.return = node;
        node = node.child;
        continue;
      }
      if (node === workInProgress) {
        return;
      }
      while (node.sibling === null) {
        if (node.return === null || node.return === workInProgress) {
          return;
        }
        node = node.return;
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
  };

function appendInitialChild(
  parentInstance: Instance,
  child: Instance | TextInstance,
): void {
  parentInstance.appendChild(child);
}
```     

这里首先把 header，然后把2个p，append 到 div 中。   

基本上就完了。然后重置 resetLanes。处理 effect。这里虽然不走 flags 那里，但是走前面了。    

```tsx
if (returnFiber.firstEffect === null) {
  returnFiber.firstEffect = completedWork.firstEffect;
}
if (completedWork.lastEffect !== null) {
  if (returnFiber.lastEffect !== null) {
    returnFiber.lastEffect.nextEffect = completedWork.firstEffect;
  }
  returnFiber.lastEffect = completedWork.lastEffect;
}
```    

这样就把 div 的 effect 传到了 App 上。    

## complete(App)   

completeWork 就不看了，直接到 effect 这里。这里上下两部分都会执行。    

首先把 effect 传给 hostRoot。然后把自身添加到 hostRoot 的effect 末尾。   

## complete(hostRoot)

```tsx
    case HostRoot: {
      popHostContainer(workInProgress);
      popTopLevelLegacyContextObject(workInProgress);
      resetMutableSourceWorkInProgressVersions();
      const fiberRoot = (workInProgress.stateNode as FiberRoot);
      if (fiberRoot.pendingContext) {
        fiberRoot.context = fiberRoot.pendingContext;
        fiberRoot.pendingContext = null;
      }
      if (current === null || current.child === null) {
        // If we hydrated, pop so that we can delete any remaining children
        // that weren't hydrated.
        const wasHydrated = popHydrationState(workInProgress);
        if (wasHydrated) {
          // If we hydrated, then we'll need to schedule an update for
          // the commit side-effects on the root.
          markUpdate(workInProgress);
        } else if (!fiberRoot.hydrate) {
          // Schedule an effect to clear this container at the start of the next commit.
          // This handles the case of React rendering into a container with previous children.
          // It's also safe to do for updates too, because current.child would only be null
          // if the previous render was null (so the the container would already be empty).
          workInProgress.flags |= Snapshot;
        }
      }
      updateHostContainer(workInProgress);
      return null;
    }
```    

基本上 completeWork 啥都没做。继续处理 effect。   

这样整个 workLoopSync 的流程就完了。   

回到 performSyncWorkOnRoot。   

## performSyncWorkOnRoot

```tsx
  // We now have a consistent tree. Because this is a sync render, we
  // will commit it even if something suspended.
  const finishedWork: Fiber = (root.current.alternate as any);
  root.finishedWork = finishedWork;
  root.finishedLanes = lanes;
  commitRoot(root);

  // Before exiting, make sure there's a callback scheduled for the next
  // pending level.
  ensureRootIsScheduled(root, now());

  return null;
```    

# 更新


```tsx
import React from 'react';

class App extends React.Component {
  state = {
    list: ['A', 'B', 'C'],
  };
  onChange = () => {
    this.setState({ list: ['C', 'A', 'X'] });
  };
  componentDidMount() {
    console.log(`App Mount`);
  }
  render() {
    return (
      <>
        <Header />
        <button onClick={this.onChange}>change</button>
        <div className="content">
          {this.state.list.map(item => (
            <p key={item}>{item}</p>
          ))}
        </div>
      </>
    );
  }
}

class Header extends React.PureComponent {
  render() {
    return (
      <>
        <h1>title</h1>
        <h2>title2</h2>
      </>
    );
  }
}
export default App;
```    

这里假设我们进行点击，触发 setState，进入更新状态，最后还是走到了 `scheduleUpdateOnFiber`    

这里由于不是 LegacyUnBatchedContext 所以走入 else 分支：   

```tsx
ensureRootIsScheduled(root, eventTime);
schedulePendingInteractions(root, lane);
if (executionContext === NoContext) {
    // Flush the synchronous work now, unless we're already working or inside
    // a batch. This is intentionally inside scheduleUpdateOnFiber instead of
    // scheduleCallbackForFiber to preserve the ability to schedule a callback
    // without immediately flushing it. We only do this for user-initiated
    // updates, to preserve historical behavior of legacy mode.
    resetRenderTimer();
    flushSyncCallbackQueue();
}
```    

然后是进入了 ensureRootIsScheduled，在这个函数里面走了这个调度：   

```tsx
  // Schedule a new callback.
  let newCallbackNode;
  if (newCallbackPriority === SyncLanePriority) {
    // 这里
    // Special case: Sync React callbacks are scheduled on a special
    // internal queue
    newCallbackNode = scheduleSyncCallback(
      performSyncWorkOnRoot.bind(null, root),
    );
  } else if (newCallbackPriority === SyncBatchedLanePriority) {
    newCallbackNode = scheduleCallback(
      ImmediateSchedulerPriority,
      performSyncWorkOnRoot.bind(null, root),
    );
  } else {
    const schedulerPriorityLevel = lanePriorityToSchedulerPriority(
      newCallbackPriority,
    );
    newCallbackNode = scheduleCallback(
      schedulerPriorityLevel,
      performConcurrentWorkOnRoot.bind(null, root),
    );
  }
```    

所以最后又走到了 performSyncWorkOnRoot。    

然后后面的几个链路是一致的，走到 workLoopSync。    

## 概述 

而由于这次是有 current 的，大部分节点会先走下上面的 if 流程。    


对于 hostRoot 来说，和上次一次，进入 updateHostRoot 节点。不过这里在 hostRoot 这里应该会 bailOut。   

```tsx
const nextChildren = nextState.element;
if (nextChildren === prevChildren) {
    resetHydrationState();
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
}
```    

与初次创建不同, 在对比更新过程中, 如果是老节点, 那么current !== null, 需要进行对比, 然后决定是否复用老节点及其子树(即bailout逻辑).

- `!includesSomeLane(renderLanes, updateLanes)` 这个判断分支, 包含了渲染优先级和update优先级的比较(详情可以回顾fiber 树构造(基础准备)中优先级相关解读), 如果当前节点无需更新, 则会进入bailout逻辑.
- 最后会调用bailoutOnAlreadyFinishedWork:
    + 如果同时满足 `!includesSomeLane(renderLanes, workInProgress.childLanes)`, 表明该 fiber 节点及其子树都无需更新, 可直接进入回溯阶段(completeUnitofWork)
    + 如果不满足!includesSomeLane(renderLanes, workInProgress.childLanes), 意味着子节点需要更新, clone并返回子节点.  

这是 beginWork 第一部分需要注意的不同，然后是 updateXX 部分，一个一个看。   

对比更新过程的不同之处:

1. `bailoutOnAlreadyFinishedWork`
    - 对比更新时如果遇到当前节点无需更新(如: class类型的节点且shouldComponentUpdate返回false), 会再次进入bailout逻辑.
2. reconcileChildren调和函数
    - 调和函数是updateXXX函数中的一项重要逻辑, 它的作用是向下生成子节点, 并设置fiber.flags.
    - 初次创建时fiber节点没有比较对象, 所以在向下生成子节点的时候没有任何多余的逻辑, 只管创建就行.
    - 对比更新时需要把ReactElement对象与旧fiber对象进行比较, 来判断是否需要复用旧fiber对象.     

本节只需要先了解调和函数目的:

- 给新增,移动,和删除节点设置fiber.flags(新增,移动: Placement, 删除: Deletion)
- 如果是需要删除的fiber, 除了自身打上Deletion之外, 还要将其添加到父节点的effects链表中(正常副作用队列的处理是在completeWork函数, 但是该节点(被删除)会脱离fiber树, 不会再进入completeWork阶段, 所以在beginWork阶段提前加入副作用队列).    

updateHostRoot 上面已经讲过了。直接 bailOut 了。   

updateHostComponent 的话，更新和首次是完全一样的了，差别估计都在 reconcileChildren 里面。   

updateClassComponent，这个还是有点区别的。   

```tsx
  const instance = workInProgress.stateNode;
  let shouldUpdate;
  // 第一次创建的时候走这里
  // 更新的时候走 else 了
  if (instance === null) {
    if (current !== null) {
      // A class component without an instance only mounts if it suspended
      // inside a non-concurrent tree, in an inconsistent state. We want to
      // treat it like a new mount, even though an empty version of it already
      // committed. Disconnect the alternate pointers.
      current.alternate = null;
      workInProgress.alternate = null;
      // Since this is conceptually a new fiber, schedule a Placement effect
      workInProgress.flags |= Placement;
    }
    // In the initial pass we might need to construct the instance.
    constructClassInstance(workInProgress, Component, nextProps);
    mountClassInstance(workInProgress, Component, nextProps, renderLanes);
    shouldUpdate = true;
  } else if (current === null) {
    // In a resume, we'll already have an instance we can reuse.
    shouldUpdate = resumeMountClassInstance(
      workInProgress,
      Component,
      nextProps,
      renderLanes,
    );
  } else {
    // 更新的时候应该是走这了
    shouldUpdate = updateClassInstance(
      current,
      workInProgress,
      Component,
      nextProps,
      renderLanes,
    );
  }
  const nextUnitOfWork = finishClassComponent(
    current,
    workInProgress,
    Component,
    shouldUpdate,
    hasContext,
    renderLanes,
  );
```   

在 updateClassInstance 里面的会处理 updateQueue 生成新的 state，也会调用一些生命周期，比如 getDerivedStateFromProps 获取新的 state，以及类似 componentWillUpdate 之类生命周期，还会检查是否挂了一些 render 后生命周期，比如 componentDidUpdate，如果有打上 flag。   

同时会检查实例上的 `shoudComponentUpdate` 的返回值     

然进入 finishClassComponent，如果 shouldUpdate 返回 false，直接 bailOut。    

否则调用 render 方法，进入 reconcileChildren 内容。    

然后 completewUnitOfWork，主要是 completeWork，
对于 HostRoot 和 ClassComponent，completeWork 什么都不做。   

主要是 hostComponent。具体流程比较长，先不细看了，估计是更新了必要的属性。    

那我们这里看下整个的流程，beginWork 中，大致和初次创建是一致的，除了部分分支可能直接 bailOut，而 completeUnitOfWork 则几乎和首次创建也是一致的。    

那么整个流程就是生成了一颗新的 fiber 树，只不过对于有的可复用的节点，直接用旧树上的节点。   

下面我们一点一点看：   

### begin(hostRoot)    

进入 bailOut 逻辑，    

```tsx
function bailoutOnAlreadyFinishedWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  if (current !== null) {
    // Reuse previous dependencies
    workInProgress.dependencies = current.dependencies;
  }

  // 这里 lane 的先跳过
  markSkippedUpdateLanes(workInProgress.lanes);

  // Check if the children have any pending work.
  if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {
    // The children don't have any work either. We can skip them.
    // TODO: Once we add back resuming, we should check if the children are
    // a work-in-progress set. If so, we need to transfer their effects.
    return null;
  } else {
    // This fiber doesn't have work, but its subtree does. Clone the child
    // fibers and continue.
    cloneChildFibers(current, workInProgress);
    return workInProgress.child;
  }
}
```   

这里相当于返回了一个 App fiber 节点副本，那进入这个副本节点的 beginWork。     

## begin(App)

这里是不能直接 bailOut，因为他有 lanes，进入 updateClassComponent，
这里在 updateClassInstance 中处理 updateQueue，计算出新的 state。
然后进入 finishClassComponent，打上 perform flag，调用 render 方法，生成新的 children，进入 reconcileChildren 算法。    

由于有 current，进入 reconcileChildFibers。    

由于 render 返回了 Fragment，且 Fragment 的子节点是数组，所以进入 reconcileChildrenArray 的情况。   

但是这里我们先完整介绍一下单节点调和算法：   

```tsx
  function reconcileSingleElement(
    returnFiber: Fiber,
    currentFirstChild: Fiber | null,
    element: ReactElement,
    lanes: Lanes,
  ): Fiber {
    const key = element.key;
    let child = currentFirstChild;

    // 新建情况直接跳过
    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      // key 相等
      if (child.key === key) {
        switch (child.tag) {
          case Fragment: {
            if (element.type === REACT_FRAGMENT_TYPE) {
              deleteRemainingChildren(returnFiber, child.sibling);
              const existing = useFiber(child, element.props.children);
              existing.return = returnFiber;
              if (__DEV__) {
                existing._debugSource = element._source;
                existing._debugOwner = element._owner;
              }
              return existing;
            }
            break;
          }
          case Block:
            if (enableBlocksAPI) {
              let type = element.type;
              if (type.$$typeof === REACT_LAZY_TYPE) {
                type = resolveLazyType(type);
              }
              if (type.$$typeof === REACT_BLOCK_TYPE) {
                // The new Block might not be initialized yet. We need to initialize
                // it in case initializing it turns out it would match.
                if (
                  ((type: any): BlockComponent<any, any>)._render ===
                  (child.type: BlockComponent<any, any>)._render
                ) {
                  deleteRemainingChildren(returnFiber, child.sibling);
                  const existing = useFiber(child, element.props);
                  existing.type = type;
                  existing.return = returnFiber;
                  if (__DEV__) {
                    existing._debugSource = element._source;
                    existing._debugOwner = element._owner;
                  }
                  return existing;
                }
              }
            }
          // We intentionally fallthrough here if enableBlocksAPI is not on.
          // eslint-disable-next-lined no-fallthrough
          default: {
            if (
              child.elementType === element.type ||
              // Keep this check inline so it only runs on the false path:
              (__DEV__
                ? isCompatibleFamilyForHotReloading(child, element)
                : false)
            ) {
              deleteRemainingChildren(returnFiber, child.sibling);
              const existing = useFiber(child, element.props);
              existing.ref = coerceRef(returnFiber, child, element);
              existing.return = returnFiber;
              if (__DEV__) {
                existing._debugSource = element._source;
                existing._debugOwner = element._owner;
              }
              return existing;
            }
            break;
          }
        }
        // Didn't match.
        deleteRemainingChildren(returnFiber, child);
        break;
      } else {
        // key 不等
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }

    if (element.type === REACT_FRAGMENT_TYPE) {
      const created = createFiberFromFragment(
        element.props.children,
        returnFiber.mode,
        lanes,
        element.key,
      );
      created.return = returnFiber;
      return created;
    } else {
      const created = createFiberFromElement(element, returnFiber.mode, lanes);
      created.ref = coerceRef(returnFiber, currentFirstChild, element);
      created.return = returnFiber;
      return created;
    }
  }
```   

能看出来如果是新的元素节点，直接创建新的 fiber 节点就完事了。否则要进行比较。   

- 遍历所有旧的 fiber 兄弟节点
  - 如果 key 不等，删掉这个 fiber 节点，设置这个节点的 flag 为 deletion，将这个节点添加到父fiber 的 effect 链表中
  - 如果 key 相等
    - 如果 type 相等，删除旧的 fiber 节点的兄弟节点，具体步骤和上面一样，这个时候等同于两个类型相同的节点比较，只不过一个是 ReactElement，一个是 fiber，步骤就是从旧的 fiber 节点创建一个新的 fiber 节点副本，然后返回这个新的节点
    - 如果 type 不等，删掉所有 fiber 兄弟节点，等同于新建流程    


然后是数组格式的 reconcile。    

```tsx
function reconcileChildrenArray(
  returnFiber: Fiber,
  currentFirstChild: Fiber | null,
  newChildren: Array<*>,
  lanes: Lanes,
): Fiber | null {
  let resultingFirstChild: Fiber | null = null;
  let previousNewFiber: Fiber | null = null;

  let oldFiber = currentFirstChild;
  let lastPlacedIndex = 0;
  let newIdx = 0;
  let nextOldFiber = null;
  // 1. 第一次循环: 遍历最长公共序列(key相同), 公共序列的节点都视为可复用
  for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
    // 后文分析
  }

  if (newIdx === newChildren.length) {
    // 如果newChildren序列被遍历完, 那么oldFiber序列中剩余节点都视为删除(打上Deletion标记)
    deleteRemainingChildren(returnFiber, oldFiber);
    return resultingFirstChild;
  }

  if (oldFiber === null) {
    // 如果oldFiber序列被遍历完, 那么newChildren序列中剩余节点都视为新增(打上Placement标记)
    for (; newIdx < newChildren.length; newIdx++) {
      // 后文分析
    }
    return resultingFirstChild;
  }

  // ==================分割线==================
  const existingChildren = mapRemainingChildren(returnFiber, oldFiber);

  // 2. 第二次循环: 遍历剩余非公共序列, 优先复用oldFiber序列中的节点
  for (; newIdx < newChildren.length; newIdx++) {}

  if (shouldTrackSideEffects) {
    // newChildren已经遍历完, 那么oldFiber序列中剩余节点都视为删除(打上Deletion标记)
    existingChildren.forEach(child => deleteChild(returnFiber, child));
  }

  return resultingFirstChild;
}
```   

这里在 App 这里 reconcileChildren 这里，都是直接复用的。   

然后进入 header。   

### begin(Header)   

didReceiveUpdate 应该会置位，进入 updateClassComponent，然后因为他自身没什么变动，update 里面应该也没动静，就正常调用 render，生成后代节点，
然后进行 reconcile，这里两个节点又可以直接复用，进入第一个 h1 的 begin，
hostcomponent 节点，这里基本上 beginWork 没变动，然后进入 completeWork 阶段，问题也不大，进入第二个 h1 的 begin, 然后 complete，
最后回到 Header 的 complete，这里应该要打一个 perform flag，到 button 的 begin，。。。。，到 div 的 begin，进入 div 的 reconcileChildren。   

没注意 Header 是 PureComponent，在 updateClassInstance 中检查 shouldUpdate 的时候会检查是不是 PureComponent ，如果是会返回对 props 和 state 的浅比较结果，这里就是返回 false。    

那就在 finish 中直接 bailOut，返回 null，那就是 Header 的beginWork 后进入 completeWork。    

### begin(Div)    

主要是调和算法。   

由 ABC 变成了 CAX。由于大家第一个 key 就不一致，应该第一次遍历就断了。   

需要走第二次，先弄个 map，然后遍历新的 children，第一个可以复用，直接复用，然后是 A，需要打了 placement 的 flag，然后 X 是新建的，打个 Placement，然后 B 打个 Delete，且在 B 的父级 div 上挂着 effect。   

然后是 3 个 p 的处理，第一个 C 不用管，第二个 A 有 Placement，要挂到 div 上，第三个 X 同样。   

### complete(div)    

div 有个 effect，上挂到 App 上。   

### complete(App)   

把 effect 再挂到 hostRoot 上，结束。   

# 渲染    

- 无论是首次构造或者是对比更新, 最终都会在内存中生成一棵用于渲染页面的fiber树(即fiberRoot.finishedWork).    
- 这棵将要被渲染的fiber树有 2 个特点:
    + 副作用队列挂载在根节点上(具体来讲是finishedWork.firstEffect)
    + 代表最新页面的DOM对象挂载在fiber树中首个HostComponent类型的节点上(具体来讲DOM对象是挂载在fiber.stateNode属性上)

通过上述源码分析, 可以把commitRootImpl的职责概括为 2 个方面:

1. 处理副作用队列. (步骤 1,2,3 都会处理, 只是处理节点的标识fiber.flags不同).
2. 调用渲染器, 输出最终结果. (在步骤 2: commitMutationEffects中执行).

所以无论fiber树结构有多么复杂, 到了commitRoot阶段, 实际起作用的只有 2 个节点:

1. 副作用队列所在节点: 根节点, 即HostRootFiber节点.
2. DOM对象所在节点: 从上至下首个HostComponent类型的fiber节点, 此节点 fiber.stateNode实际上指向最新的 DOM 树.

## 第一部分

```tsx
nextEffect = firstEffect;
do {
    try {
        commitBeforeMutationEffects();
    } catch (error) {
        invariant(nextEffect !== null, 'Should be working on an effect.');
        captureCommitPhaseError(nextEffect, error);
        nextEffect = nextEffect.nextEffect;
    }
} while (nextEffect !== null);
```

```tsx
function commitBeforeMutationEffects() {
  while (nextEffect !== null) {
    const current = nextEffect.alternate;

    const flags = nextEffect.flags;
    if ((flags & Snapshot) !== NoFlags) {
      commitBeforeMutationEffectOnFiber(current, nextEffect);
    }
    if ((flags & Passive) !== NoFlags) {
      // If there are passive effects, schedule a callback to flush at
      // the earliest opportunity.
      if (!rootDoesHavePassiveEffects) {
        rootDoesHavePassiveEffects = true;
        scheduleCallback(NormalSchedulerPriority, () => {
          flushPassiveEffects();
          return null;
        });
      }
    }
    nextEffect = nextEffect.nextEffect;
  }
}
```   



在 effect 上首先是 Content 节点，然后是 App 节点，Content 上有 perform, update，app 也一样，只不过多了 placement。    

content 和 app 这个遍历啥都没做，只有 hostroot 好像有 snapshot，但是我们分析的时候没遇到，这里先按照有，`commitBeforeMutationEffectOnFiber` 也是根据不同的节点类型有不同的操作，由于 snapshot 只有 hostRoot 和 classComponent 上有效果，所以其实也只处理了这两种类型，
在 classComponent 上是调用 getSnapshotBeforeUpdate，在 hostRoot 上是将 React 容器的 html 内容清空。    

所以这里 before 就完成了


## 第二部分

```tsx
nextEffect = firstEffect;
do {
    try {
        commitMutationEffects(root, renderPriorityLevel);
    } catch (error) {
        invariant(nextEffect !== null, 'Should be working on an effect.');
        captureCommitPhaseError(nextEffect, error);
        nextEffect = nextEffect.nextEffect;
    }
} while (nextEffect !== null);
```   

```tsx
function commitMutationEffects(
  root: FiberRoot,
  renderPriorityLevel: ReactPriorityLevel,
) {
  // TODO: Should probably move the bulk of this function to commitWork.
  while (nextEffect !== null) {
    const flags = nextEffect.flags;

    if (flags & ContentReset) {
      commitResetTextContent(nextEffect);
    }

    if (flags & Ref) {
      const current = nextEffect.alternate;
      if (current !== null) {
        commitDetachRef(current);
      }
      if (enableScopeAPI) {
        // TODO: This is a temporary solution that allowed us to transition away
        // from React Flare on www.
        if (nextEffect.tag === ScopeComponent) {
          commitAttachRef(nextEffect);
        }
      }
    }

    const primaryFlags = flags & (Placement | Update | Deletion | Hydrating);
    switch (primaryFlags) {
      case Placement: {
        commitPlacement(nextEffect);
        nextEffect.flags &= ~Placement;
        break;
      }
      case PlacementAndUpdate: {
        // Placement
        commitPlacement(nextEffect);
        // Clear the "placement" from effect tag so that we know that this is
        // inserted, before any life-cycles like componentDidMount gets called.
        nextEffect.flags &= ~Placement;

        // Update
        const current = nextEffect.alternate;
        commitWork(current, nextEffect);
        break;
      }
      case Hydrating: {
        nextEffect.flags &= ~Hydrating;
        break;
      }
      case HydratingAndUpdate: {
        nextEffect.flags &= ~Hydrating;

        // Update
        const current = nextEffect.alternate;
        commitWork(current, nextEffect);
        break;
      }
      case Update: {
        const current = nextEffect.alternate;
        commitWork(current, nextEffect);
        break;
      }
      case Deletion: {
        commitDeletion(root, nextEffect, renderPriorityLevel);
        break;
      }
    }

    nextEffect = nextEffect.nextEffect;
  }
}
```   

第一次遍历，对于 Content 节点，有 Update 节点，commitWork 对于 classComponent 直接返回，什么都不做。    

然后是 App 节点，是PlacementAndUpdate。    

这里 commitPlacement 还挺复杂的。对于这里的 App 来说，就是找到其后代的 div 的 fiber 节点，并将其 stateNode 即 div 元素 append 到 container React 容器中。而 commitWork 啥都不做，所以这里就已经将 DOM 内容填进了页面中。       

## 第三阶段

```tsx
    root.current = finishedWork;

    // The next phase is the layout phase, where we call effects that read
    // the host tree after it's been mutated. The idiomatic use case for this is
    // layout, but class component lifecycles also fire here for legacy reasons.
nextEffect = firstEffect;
do {
    try {
        commitLayoutEffects(root, lanes);
    } catch (error) {
        invariant(nextEffect !== null, 'Should be working on an effect.');
        captureCommitPhaseError(nextEffect, error);
        nextEffect = nextEffect.nextEffect;
    }
} while (nextEffect !== null);
```   

第三阶段也是看类型处理，有作用就 classComponent, hostRoot 和 hostComponent。   

对于 classComponent 来说就是分情况调用 `componentDidMount` 和 `componentDidUpdate`，同时对于有 effect 的 update 来说，还会调用其中的 effect。典型就是 setState 的回调。    

对于 hostRoot 来说就是只处理 update effect。   

对于 hostComponent 来说就是处理 focus。   

到此为止，基本上渲染就完成了。   

# Hook

```tsx

type Update<S, A> = {
    lane: Lane,
    action: A,
    eagerReducer: ((S, A) => S) | null,
    eagerState: S | null,
    next: Update<S, A>,
    priority?: ReactPriorityLevel
}

type UpdateQueue<S, A> = {
    pending: Update<S, A> | null,
    dispatch: (A => any) | null,
    lastRenderedReducer: ((S, A) => S) | null,
    lastRenderedState: S | null,
};

export type Hook = {
    memorizedState: any,
    baseState: any,
    baseQueue: Update<any, any> | null,
    queue: UpdateQueue<any, any> | null,
    next: Hook | null,
}
```    

我们先去看下 beginWork 中对于函数组件的处理:   

```tsx
    case FunctionComponent: {
      const Component = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps =
        workInProgress.elementType === Component
          ? unresolvedProps
          : resolveDefaultProps(Component, unresolvedProps);
      return updateFunctionComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderLanes,
      );
    }
```    

```tsx
function updateFunctionComponent(
  current,
  workInProgress,
  Component,
  nextProps: any,
  renderLanes,
) {
  let nextChildren = renderWithHooks(
      current,
      workInProgress,
      Component,
      nextProps,
      context,
      renderLanes,
    );

   // 更新过程，且没有收到更新的变动
  if (current !== null && !didReceiveUpdate) {
    bailoutHooks(current, workInProgress, renderLanes);
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }

  // React DevTools reads this flag.
  workInProgress.flags |= PerformedWork;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}
```   

renderWithHooks 里面简单看一下的话基本上就是调用了函数生成后代节点。   

```tsx
export function useState<S>(
  initialState: (() => S) | S,
): [S, Dispatch<BasicStateAction<S>>] {
  const dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}

export function useReducer<S, I, A>(
  reducer: (S, A) => S,
  initialArg: I,
  init?: I => S,
): [S, Dispatch<A>] {
  const dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}

export function useRef<T>(initialValue: T): {|current: T|} {
  const dispatcher = resolveDispatcher();
  return dispatcher.useRef(initialValue);
}
```   

简单来说，大部分的 hook 函数都是调用了一个 dispatcher 对象上的对应方法，而这个 dispatcher 又绑定在一个 React 包内部变量的 current 属性上，而在
renderWithHooks 中会根据当前是更新还是初次创建，决定对这个 current 属性赋予不同的值。   

```tsx
  ReactCurrentDispatcher.current =
      current === null || current.memoizedState === null
        ? HooksDispatcherOnMount
        : HooksDispatcherOnUpdate;

  let children = Component(props, secondArg);

const HooksDispatcherOnMount: Dispatcher = {
  readContext,

  useCallback: mountCallback,
  useContext: readContext,
  useEffect: mountEffect,
  useImperativeHandle: mountImperativeHandle,
  useLayoutEffect: mountLayoutEffect,
  useMemo: mountMemo,
  useReducer: mountReducer,
  useRef: mountRef,
  useState: mountState,
  useDebugValue: mountDebugValue,
  useDeferredValue: mountDeferredValue,
  useTransition: mountTransition,
  useMutableSource: mountMutableSource,
  useOpaqueIdentifier: mountOpaqueIdentifier,

  unstable_isNewReconciler: enableNewReconciler,
};

const HooksDispatcherOnUpdate: Dispatcher = {
  readContext,

  useCallback: updateCallback,
  useContext: readContext,
  useEffect: updateEffect,
  useImperativeHandle: updateImperativeHandle,
  useLayoutEffect: updateLayoutEffect,
  useMemo: updateMemo,
  useReducer: updateReducer,
  useRef: updateRef,
  useState: updateState,
  useDebugValue: updateDebugValue,
  useDeferredValue: updateDeferredValue,
  useTransition: updateTransition,
  useMutableSource: updateMutableSource,
  useOpaqueIdentifier: updateOpaqueIdentifier,

  unstable_isNewReconciler: enableNewReconciler,
};
```   

以 mountState 为例：   

```tsx
function mountState<S>(
  initialState: (() => S) | S,
): [S, Dispatch<BasicStateAction<S>>] {
  const hook = mountWorkInProgressHook();
  if (typeof initialState === 'function') {
    // $FlowFixMe: Flow doesn't like mixed types
    initialState = initialState();
  }
  hook.memoizedState = hook.baseState = initialState;
  const queue = (hook.queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: (initialState as any),
  });
  const dispatch: Dispatch<
    BasicStateAction<S>,
  > = (queue.dispatch = (dispatchAction.bind(
    null,
    currentlyRenderingFiber,
    queue,
  ) as any));
  return [hook.memoizedState, dispatch];
}

function mountWorkInProgressHook(): Hook {
  const hook: Hook = {
    memoizedState: null,

    baseState: null,
    baseQueue: null,
    queue: null,

    next: null,
  };

  if (workInProgressHook === null) {
    // This is the first hook in the list
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    // Append to the end of the list
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
```   


待解决的问题

- lane 的流动，从 lane 的生成（updateLane）到 renderLanes，进一步还有
在 fiberRoot 上的各种 lane 的操作。    

- updateHostRoot 中 hostRoot 的 element 在更新时是哪出现的

- fiber 上的 props, state，和类实例上的 props 和 state 又是怎样流动的。   

