# 面试准备

<!-- TOC -->

- [面试准备](#面试准备)
    - [2021-06-29](#2021-06-29)
      - [闭包](#闭包)
      - [eval 命令](#eval-命令)
    - [2021-06-30](#2021-06-30)
      - [数组](#数组)
      - [运算符](#运算符)
      - [Object 对象](#object-对象)
      - [属性描述对象](#属性描述对象)
      - [数组](#数组-1)
      - [HTML](#html)

<!-- /TOC -->

### 2021-06-29

- ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。    
- 网页应用是状态机的概念。
- 语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。
- 语句以分号结尾，一个分号就表示一个语句结束。分号前面可以没有任何内容，JavaScript 引擎将其视为空语句。
- 如果一个变量没有声明就直接使用，JavaScript 会报错，告诉你变量未定义。
- JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，
都会被提升到代码的头部，这就叫做变量提升
- 标识符的命名规则。中文是合法的标识符，可以用作变量名。
- 由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以`<!--和-->`也被视为合法的单行注释。
- 不管条件是否为真，do...while循环至少运行一次，这是这种结构最大的特点。另外，while语句后面的分号注意不要省略。   

```js
top:
  for (var i = 0; i < 3; i++){
    for (var j = 0; j < 3; j++){
      if (i === 1 && j === 1) break top;
      console.log('i=' + i + ', j=' + j);
    }
  }
// i=0, j=0
// i=0, j=1
// i=0, j=2
// i=1, j=0
```    

- number, string, boolean, null, undefined, object, symbol
- JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数。
- 根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。
    + 第1位：符号位，0表示正数，1表示负数
    + 第2位到第12位（共11位）：指数部分
    + 第13位到第64位（共52位）：小数部分（即有效数字）
- 符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。
- 指数部分一共有11个二进制位，因此大小范围就是0到2047。IEEE 754 规定，如果指数部分的值在0到2047之间（不含两个端点），
那么有效数字的第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字这时总是1.xx...xx的形式，
其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript 提供的有效数字最长为53个二进制位。
- 精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-2<sup>53</sup>到2<sup>53</sup>，都可以精确表示。
- 不能精确表示的含义不代表大于这个范围的数都是同一个数，仅仅是因为大于这个范围的数，有效数字无法再准备的表示
出是1还是0，因此数字可能是不准确的。
- 根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，
64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为2<sup>1024</sup>
到2<sup>-1023</sup>（开区间），超出这个范围的数无法表示。
- 如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity。
- 通常来说，有前导0的数值会被视为八进制，但是如果前导0后面有数字8和9，则该数值被视为十进制。
- 0除以0会得到NaN
- 0乘以Infinity，返回NaN；0除以Infinity，返回0；Infinity除以0，返回Infinity。
- Infinity减去或除以Infinity，得到NaN。
- 以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。
    + 小数点前的数字多于21位
    + 小于1且小数点后的零多于5个，即 0.000000xxxxx
- parseInt 如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，
超出这个范围，则返回NaN。如果第二个参数是0、undefined和null，则直接忽略。
- 反斜杠还有三种特殊用法：
    + `\HHH`: 反斜杠后面紧跟三个八进制数（000到377），代表一个字符。HHH对应该字符的 Unicode 码点
    + `\xHH`: `\x`后面紧跟两个十六进制数（00到FF），代表一个字符。HH对应该字符的 Unicode 码点
    + `\uXXXX`: `\u` 后面紧跟四个十六进制数（0000到FFFF），代表一个字符。XXXX对应该字符的 Unicode 码点
- 每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。
- 但是，UTF-16 有两种长度：对于码点在U+0000到U+FFFF之间的字符，长度为16位（即2个字节）；对于码点在U+10000到U+10FFFF之间的字符，
长度为32位（即4个字节），而且前两个字节在0xD800到0xDBFF之间，后两个字节在0xDC00到0xDFFF之间。举例来说，码点U+1D306对应的字符为𝌆，
它写成 UTF-16 就是0xD834 0xDF06。
- 如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。
- 函数的name属性返回函数的名字。
- 函数的length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。
- 函数的toString()方法返回一个字符串，内容是函数的源码。
- 正常模式下，arguments对象可以在运行时修改。严格模式下，arguments对象与函数参数不具有联动关系。也就是说，修改arguments对象不会影响到实际的函数参数。
- arguments对象带有一个callee属性，返回它所对应的原函数。这个属性在严格模式里面是禁用的。

#### 闭包

```js
function f1() {
  var n = 999;
  function f2() {
　　console.log(n); // 999
  }
}
```    

既然f2可以读取f1的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！    

闭包就是函数f2，即能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，
因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，
所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。    

闭包的最大用处有两个，一个是可以读取外层函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。
请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。     

#### eval 命令

- eval命令接受一个字符串作为参数，并将这个字符串当作语句执行。如果参数字符串无法当作语句运行，那么就会报错。
- 如果eval的参数不是字符串，那么会原样返回。
- eval没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。    

### 2021-06-30    

#### 数组   

- length属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员数量会自动减少到length设置的值。清空数组的一个有效方法，就是将length属性设为0。
- 注意，如果数组的某个位置是空位，in运算符返回false。

#### 运算符   

- 余数运算符，运算结果的正负号由第一个运算子的正负号决定。
- `+` 叫数值运算符，作用在于可以将任何值转为数值（与Number函数的作用相同
- 负数值运算符（-），也同样具有将一个值转为数值的功能，只不过得到的值正负相反。连用两个负数值运算符，等同于数值运算符。
- 指数运算符是右结合，而不是左结合。即多个指数运算符连用时，先进行最右边的计算。
- 对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；
否则，将两个运算子都转成数值，再比较数值的大小。
- 相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。
    + 原始类型的值会转换成数值再进行比较。
    + 对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较。
    + undefined和null只有与自身比较，或者互相比较时，才会返回true；与其他类型的值比较时，结果都为false。
- 位运算符
    + 或：`|`
    + 与：`&`
    + 否：`~` 对一个二进制位取反
    + 异或：`^`
    + 左移：`<<`
    + 右移：`>>`
    + 头部补零右移：`>>>`
- 虽然在 JavaScript 内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。
- “异或运算”有一个特殊运用，连续对两个数a和b进行三次异或运算，`a^=b; b^=a; a^=b;`，可以互换它们的值。这意味着，使用“异或运算”
可以在不引入临时变量的前提下，互换两个变量的值。
- 使用 void 运算符时，建议总使用括号，因为 void 运算符的优先性很高。     

#### Object 对象    

- 如果参数是原始类型的值，Object方法将其转为对应的包装对象的实例
- 如果Object方法的参数是一个对象，它总是返回该对象，即不用转换。
- Object构造函数的用法与工具方法很相似，几乎一模一样。使用时，可以接受一个参数，如果该参数是一个对象，则直接返回这个对象；
如果是一个原始类型的值，则返回该值对应的包装对象
- Object.keys方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名。
- Object.getOwnPropertyNames方法与Object.keys类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。
但是 keys 不包括不可枚举属性，但这个包括
- `Object.getOwnPropertyDescriptor()`, `Object.defineProperty()`, `Object.defineProperties()`
- `Object.preventExtensions()`, `Object.isExtensible()`, `Object.seal()`, `Object.isSealed()`, `Object.freeze()`, `Object.isFrozen()`
- `Object.create()`, `Object.getPrototypeOf()`
- `Object.prototype.valueOf()`, `Object.prototype.toString()`, `Object.prototype.toLocaleString()`
`Object.prototype.hasOwnProperty()`, `Object.prototype.isPrototypeOf()`, `Object.prototype.propertyIsEnumerable()`
- 数组、字符串、函数、Date 对象都分别部署了自定义的toString方法，覆盖了Object.prototype.toString方法。
- `[object Object]` 中的第二个 `Object` 表示该值的构造函数
- 由于实例对象可能会自定义 `toString` 方法，覆盖掉 `Object.prototype.toString` 方法，所以为了得到类型字符串，最好直接使用
`Object.prototype.toString` 方法。通过函数的call方法，可以在任意值上调用这个方法，帮助我们判断这个值的类型。

#### 属性描述对象   

```js 
{
    value: 123,
    writable: false,
    enumerable: false,
    configurable: false,
    get: undefined,
    set: undefined,
}
```    

- `Object.defineProperty()` 定义的默认的属性描述符的值都是 false
- 如果原型对象的某个属性的writable为false，那么子对象将无法自定义这个属性。但是，有一个规避方法，就是通过覆盖属性描述对象，
绕过这个限制。原因是这种情况下，原型链会被完全忽视。
- configurable为false时，value、writable、enumerable和configurable都不能被修改了。不过writable只有在false改为true会报错，
true改为false是允许的。
- 至于value，只要writable和configurable有一个为true，就允许改动。（这不啪啪打脸吗）
- Object.preventExtensions方法可以使得一个对象无法再添加新的属性。
- Object.seal方法使得一个对象既无法添加新属性，也无法删除旧属性。
- 用了 seal 方法后，`isExtensilble` 也返回 false
- Object.freeze方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。
- 使用Object.freeze方法以后，Object.isSealed将会返回true，Object.isExtensible返回false。    

#### 数组   

- 数组的valueOf方法返回数组本身。
- join 方法如果数组成员是undefined或null或空位，会被转成空字符串。注意不是直接跳过
- slice 方法第二个参数小于第一个参数，则返回空数组。     

#### HTML   

- `<meta>` 标签的name属性表示元数据的名字，content属性表示元数据的值。它们合在一起使用，就可以为网页指定一项元数据。
- `<meta>` 标签的http-equiv属性用来覆盖 HTTP 回应的头信息字段，content属性是对应的字段内容。
- URL 的各个组成部分，只能使用以下这些字符:
    + 26个英语字母（包括大写和小写）
    + 10个阿拉伯数字
    + 连词号（-）
    + 句点（.）
    + 下划线（_）     
- 此外，还有18个字符属于 URL 的保留字符，只能在给定的位置出现。比如，查询参数的开头是问号（?），也就是说，
问号只能出现查询参数的开头，出现在其他位置就是非法的，会导致网址解析错误。网址的其他部分如果要使用这些保留字符，必须使用它们的转义形式。
- URL 字符转义的方法是，在这些字符的十六进制 ASCII 码前面加上百分号（%）。下面是这18个字符及其转义形式。
- 既不属于合法字符、也不属于保留字符的其他字符（比如汉字），理论上不需要手动转义，可以直接写在 URL 里面，比如www.example.com/中国.html，
浏览器会自动将它们转义，发给服务器。转义方法是使用这些字符的十六进制 UTF-8 编码，每两位算作一组，然后每组头部添加百分号（%）。
- 举例来说，汉字中的 UTF-8 十六进制编码是e4b8ad，每两个字符一组，URL 转义后就为%e4%b8%ad。也就是说，URL 里面凡是有汉字中的地方，都要写成%e4%b8%ad。
- 属性名与标签名一样，不区分大小写
- 全局属性
    + id
    + class
    + title
    + tabindex
    + accesskey: 属性指定网页元素获得焦点的快捷键，该属性的值必须是单个的可打印字符。只要按下快捷键，该元素就会得到焦点。accesskey属性的字符键，
    必须配合功能键，一起按下才会生效。也就是说，快捷键是“功能键 + 字符键”的组合。不同的浏览器与不同的操作系统，功能键都不一样。比如，
    Chrome 浏览器在 Windows 系统和 Linux 系统的快捷键是Alt + 字符键，在 Mac 系统的快捷键是Ctrl + Alt + 字符键。
    + style
    + hidden
    + lang, dir
    + contenteditable, spellcheck 这两个是枚举属性，不是布尔属性，所以建议设置的时候加上值
    + data-
- HTML 允许使用 Unicode 码点表示字符，浏览器会自动将码点转成对应的字符。字符的码点表示法是 `&#N;`（十进制，N代表码点）或者 `&#xN;`
（十六进制，N代表码点），比如，字符a可以写成 `&#97;`（十进制）或者 `&#x61;`z（十六进制）
- 数字表示法的不方便之处，在于必须知道每个字符的码点，很难记忆。为了能够快速输入，HTML 为一些特殊字符，规定了容易记忆的名字，允许通过名字来表示它们，
这称为实体表示法.实体的写法是 `&name;`，其中的name是字符的名子。
- 语义化标签
    + `<header>`
    + `<footer>`
    + `<main>` 一个页面只能有一个 main，main 是顶级标签
    + `<article>`
    + `<aside>`
    + `<section>`
    + `<nav>`
    + `<ins>, <del>`
- srcset 属性，它的值是一个逗号分隔的字符串，每个部分都是一张图像的 URL，后面接一个空格，然后是像素密度的描述符    

```html
<img srcset="foo-320w.jpg,
             foo-480w.jpg 1.5x,
             foo-640w.jpg 2x"
     src="foo-640w.jpg"
>
```    

- 像素密度的适配，只适合显示区域一样大小的图像。如果希望不同尺寸的屏幕，显示不同大小的图像，srcset属性就不够用了，必须搭配sizes属性。
- 第一步，srcset属性列出所有可用的图像。    

```html
<img srcset="foo-160.jpg 160w,
             foo-320.jpg 320w,
             foo-640.jpg 640w,
             foo-1280.jpg 1280w"
     src="foo-1280.jpg">
```    

- 第二步，sizes属性列出不同设备的图像显示宽度。     
- sizes属性的值是一个逗号分隔的字符串，除了最后一部分，前面每个部分都是一个放在括号里面的媒体查询表达式，后面是一个空格，再加上图像的显示宽度。   

```html
<img srcset="foo-160.jpg 160w,
             foo-320.jpg 320w,
             foo-640.jpg 640w,
             foo-1280.jpg 1280w"
     sizes="(max-width: 440px) 100vw,
            (max-width: 900px) 33vw,
            254px"
     src="foo-1280.jpg">
```     

- 第三步，浏览器根据当前设备的宽度，从sizes属性获得图像的显示宽度，然后从srcset属性找出最接近该宽度的图像，进行加载。   
- 假定当前设备的屏幕宽度是480px，浏览器从sizes属性查询得到，图片的显示宽度是33vw（即33%），等于160px。srcset属性里面，正好有宽度等于160px的图片，
于是加载foo-160.jpg。    
- `<picture>`是一个容器标签，内部使用 `<source>` 和 `<img>`，指定不同情况下加载的图像。    

```html
<picture>
  <source media="(max-width: 500px)" srcset="cat-vertical.jpg">
  <source media="(min-width: 501px)" srcset="cat-horizontal.jpg">
  <img src="cat.jpg" alt="cat">
</picture>
```   



