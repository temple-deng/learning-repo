# 0908    

<!-- TOC -->

- [0908](#0908)
  - [shell](#shell)
    - [模式扩展](#模式扩展)
      - [波浪线扩展](#波浪线扩展)
      - [? 扩展](#-扩展)
      - [* 扩展](#-扩展-1)
      - [方括号扩展](#方括号扩展)
      - [大括号扩展](#大括号扩展)
      - [变量扩展](#变量扩展)
      - [子命令扩展](#子命令扩展)
      - [算术扩展](#算术扩展)
    - [引号和转义](#引号和转义)
    - [变量](#变量)
      - [特殊变量](#特殊变量)
    - [脚本入门](#脚本入门)
    - [条件判断](#条件判断)
  - [Storybook P2](#storybook-p2)
    - [编写 stories](#编写-stories)
      - [Decorators](#decorators)
      - [Loaders](#loaders)

<!-- /TOC -->

## shell    

### 模式扩展    

Shell 接收到用户输入的命令以后，会根据空格将用户的输入，拆分成一个个词元（token）。然后，Shell
会扩展词元里面的特殊字符，扩展完成后才会调用相应的命令。    

这种特殊字符的扩展，称为模式扩展（globbing）。其中有些用到通配符，又称为通配符扩展（wildcard
expansion）。Bash 一共提供八种扩展。    

- 波浪线扩展
- `?` 字符扩展
- `*` 字符扩展
- 方括号扩展
- 大括号扩展
- 变量扩展
- 子命令扩展
- 算术扩展    

Bash 是先进行扩展，再执行命令。因此，扩展的结果是由 Bash 负责的，与所要执行的命令无关。命令本身并不存在参数扩展，收到什么参数就原样执行。这一点务必需要记住。   

模式扩展与正则表达式的关系是，模式扩展早于正则表达式出现，可以看作是原始的正则表达式。它的功能没有正则那么强大灵活，但是优点是简单和方便。    

#### 波浪线扩展    

波浪线~会自动扩展成当前用户的主目录。   

```shell
$ echo ~
/home/me
```   

`~user` 表示扩展成用户 user 的主目录。`~+` 会扩展成当前目录。   

#### ? 扩展    

`?` 代表文件路径里面的任意单个字符。   

#### * 扩展    

`*` 代表文件路径里面的任意数量的任意字符，包括零个字符。    

#### 方括号扩展    

`[...]`，`ls [ab].txt`。可以理解为正则里面的字符组吧。    

两种变体 `[^...]`, `[!...]` 这两个功能是等价的。    

还有 `[start-end]` 扩展，类似 `[0-9]`。    

#### 大括号扩展    

`{...}` 分别扩展成括号里面的所有值。    

```shell
$ echo {1,2,3}
1 2 3

$ echo d{a,e,i,u,o}g
dag deg dig dug dog
```    

`{start..end}` 表示扩展成一个连续序列。    

#### 变量扩展   

美元符开头的词视为变量，扩展成变量值。    

#### 子命令扩展    

`$(...)` 扩展成另一个命令的结果    

#### 算术扩展    

`$((...))` 可以扩展成整数运算的结果。    

### 引号和转义    

某些字符在 Bash 里面有特殊含义，如果想要原样输出这些特殊字符，就必须在它们前面加上反斜杠，使其变成普通字符。     

Bash 允许字符串放在单引号或双引号之中，加以引用。    

单引号用于保留字符的字面含义，各种特殊字符在单引号里面，都会变为普通字符。   

双引号比单引号宽松，大部分特殊字符在双引号里面，都会失去特殊含义，变成普通字符。但是，三个特殊字符除外：
美元符号（$）、反引号（`）和反斜杠（\）。这三个字符在双引号之中，依然有特殊含义，会被 Bash 自动扩展。   

### 变量    

Bash 变量分成环境变量和自定义变量两类。    

env命令或printenv命令，可以显示所有环境变量。    

查看单个环境变量的值，可以使用printenv命令或echo命令。

```shell
$ printenv PATH
# 或者
$ echo $PATH
```     

自定义变量是用户在当前 Shell 里面自己定义的变量，仅在当前 Shell 可用。一旦退出当前 Shell，
该变量就不存在了。

set命令可以显示所有变量（包括环境变量和自定义变量），以及所有的 Bash 函数。    

Bash 没有数据类型的概念，所有的变量值都是字符串。    

读取变量的时候，直接在变量名前加上 `$` 就可以了。   

unset命令用来删除一个变量。这个命令不是很有用。因为不存在的 Bash 变量一律等于空字符串，
所以即使unset命令删除了变量，还是可以读取这个变量，值为空字符串。    

用户创建的变量仅可用于当前 Shell，子 Shell 默认读取不到父 Shell 定义的变量。为了把变量传递给子
Shell，需要使用export命令。这样输出的变量，对于子 Shell 来说就是环境变量。      

#### 特殊变量    

- `$?` 上一个命令的退出码
- `$$` 当前 shell 的进程 id
- `$_` 上一个命令的最后一个参数
- `$!` 最近一个后台执行的异步命令的进程 id
- `$0` 当前 shell 名称或脚本名
- `$-` 当前 shell 的启动参数     


### 脚本入门    

脚本的第一行通常是指定解释器，即这个脚本必须通过什么解释器执行。这一行以 `#!` 字符开头，这个字符称为
Shebang，所以这一行就叫做 Shebang 行。   

`#!` 后面就是脚本解释器的位置，Bash 脚本的解释器一般是/bin/sh或/bin/bash。   

### 条件判断   

```shell
if commands; then
  commands
[elif commands; then
  commands...]
[else
  commands]
fi
```     

注意，if关键字后面也可以是一条命令，该条命令执行成功（返回值0），就意味着判断条件成立。
if后面可以跟任意数量的命令。这时，所有命令都会执行，但是判断真伪只看最后一个命令，即使前面所有命令都失败，只要最后一个命令返回0，就会执行then的部分。


if结构的判断条件，一般使用test命令，有三种形式。   

```shell
# 写法一
test expression

# 写法二
[ expression ]

# 写法三
[[ expression ]]
```   

上面三种形式是等价的，但是第三种形式还支持正则判断，前两种不支持。   

上面的expression是一个表达式。这个表达式为真，test命令执行成功（返回值为0）；表达式为伪，
test命令执行失败（返回值为1）。注意，第二种和第三种写法，`[`和 `]` 与内部的表达式之间必须有空格。   


## Storybook P2   

### 编写 stories    

#### Decorators    

```js
// .storybook/preview.js
import React from 'react';
import { ThemeProvider } from 'styled-components';

export const decorators = [
  (Story) => (
    <ThemeProvider theme="default">
      <Story />
    </ThemeProvider>
  )
];
```    

#### Loaders    

Loaders 是一些异步函数，为 story 和 decorator 加载数据。loaders 会在 story 渲染前执行，然后通过
渲染上下文将加载的数据注入到 story 中。    

这个功能是为了解决一下大的 story 的性能问题的，暂略。    
