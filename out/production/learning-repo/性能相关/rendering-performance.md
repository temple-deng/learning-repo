# Rendering Performance

## 简介

### 60fps 与设备刷新率

目前大多数设备的屏幕刷新率为 60 次/秒。其中每个帧的预算时间仅比 16 毫秒多一点
(1 秒/ 60 = 16.66 毫秒)。但实际上，浏览器有整理工作要做，因此您的所有工作需
要在 10 毫秒内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动。 此现象
通常称为卡顿，会对用户体验产生负面影响。    

### 像素管道

您在工作时需要了解并注意五个主要区域。 这些是您拥有最大控制权的部分，也是像素至屏幕管道中的关键点：    

![frame-full](https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-full.jpg)


+ **JavaScript**。一般来说，我们会使用 JavaScript 来实现一些视觉变化的效果。比如用
jQuery 的 `animate` 函数做一个动画、对一个数据集进行排序或者往页面里添加一些 DOM 元素等。
当然，除了 JavaScript，还有其他一些常用方法也可以实现视觉变化效果，比如：CSS Animations、Transitions 和 Web Animation API。
+ **样式计算**。此过程是根据匹配选择器（例如 `.headline` 或 `.nav > .nav__item`）计算出哪些元素应用哪些 CSS 规则的过程。从中知道规则之后，将应用规则并计算每个元素的最终样式。
+ **布局**。在知道对一个元素应用哪些规则之后，浏览器即可开始计算它要占据的空间大小及其在屏幕的位置。网页的
布局模式意味着一个元素可能影响其他元素，例如 `<body>` 元素的宽度一般会影响其子元素的宽度以及树中各处的节点，因
此对于浏览器来说，布局过程是经常发生的。
+ **绘制**。绘制是填充像素的过程。它涉及绘出文本、颜色、图像、边框和阴影，基本上包括元素的每个可视部分。绘制一般是在多个表面（通常称为层）上完成的。
+ **合成**。由于页面的各部分可能被绘制到多层，由此它们需要按正确顺序绘制到屏幕上，以便正确渲染页面。对于与另一
元素重叠的元素来说，这点特别重要，因为一个错误可能使一个元素错误地出现在另一个元素的上层。


管道的每个部分都有机会产生卡顿，因此务必准确了解您的代码触发管道的哪些部分。    

不一定每帧都总是会经过管道每个部分的处理。实际上，不管是使用 JavaScript、CSS 还是网络动画，在实现视觉变化时，管道针对指定帧的运行通常有三种方式：   

1. JS / CSS > 样式 > 布局 > 绘制 > 合成。如果您修改元素的“layout”属性，也就是改变了元素的几何属性（例如宽度、高度、左侧或顶部位置等），那么浏览器将必须检查所有其他元素，然后“自动重排”页面。任何受影响的部分都需要重新绘制，而且最终绘制的元素需进行合成。    
2. JS / CSS > 样式 > 绘制 > 合成。如果您修改“paint only”属性（例如背景图片、文字颜色或阴影等），即不会影响页面布局的属性，则浏览器会跳过布局，但仍将执行绘制。   
3. JS / CSS > 样式 > 合成。如果您更改一个既不要布局也不要绘制的属性，则浏览器将跳到只执行合成。    

## 优化 JavaScript 执行

### 使用 requestAnimationFrame 来实现视觉变化

当屏幕正在发生视觉变化时，您希望在适合浏览器的时间执行您的工作，也就是正好在帧的开头。
保证 JavaScript 在帧开始时运行的唯一方式是使用 `requestAnimationFrame`。严格来说是每次
重绘前。使用 `setTimeout` 或 `setInterval` 来执行动画之类的视觉变化问题是，回调将在帧中
的某个时点运行，可能刚好在末尾，而这可能经常会使我们丢失帧，导致卡顿。    

### 降低复杂性或使用 Web Worker  

## 缩小样式计算的范围并降低其复杂性

通过添加和删除元素，更改属性、类或通过动画来更改 DOM，全都会导致浏览器重新计算元素样式，在很多情况下还会对页面或页面的一部分进行布局（即自动重排）。这就是所谓的计算样式的计算。     

计算样式的第一部分是创建一组匹配选择器，这实质上是浏览器计算出给指定元素应用哪些类、伪选择器和 ID。    

第二部分涉及从匹配选择器中获取所有样式规则，并计算出此元素的最终样式。    

### 降低选择器的复杂性  

在最简单的情况下，您在 CSS 中引用只有一个类的元素：   

```CSS
.title {
  /* styles */
}
```   

但是，随着项目的增长，将可能产生更复杂的 CSS，最终您的选择器可能变成这样：   

```CSS
.box:nth-last-child(-n+1) .title {
  /* styles */
}
```    

为了知道是否需要应用样式，浏览器实际上必须询问“这是否为有 title 类的元素，其父元素恰好是负第 N 个子元素加上 1 个带 box 类的元素？”计算此结果可能需要大量时间，具体取决于所用的选择器和相应的浏览器。     

### 减少要计算样式的元素数量   
