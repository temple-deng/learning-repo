# 查漏补缺

- 字符串的 length 方法和 js 的一样，就是返回 16 字符的长度，在这里叫代码单元，即一个代码单元用 16 位表示，有的字符需要用两个代码单元，一个 char 也就可以装一个代码单元
- 如果要得到实际的长度，即码点的数量，`int cpCount = greeting.codePointCount(0, greeting.length());`
- 获取所有码点 `int[] codePoints = str.codePoints().toArray();` codePoints 方法返回一个流。
- 数组长度是不变的，如果长度会变化，用 List.
- 常见的数组方法：`Arrays.toString()`, `Arrays.copyOf()`, `Arrays.sort()`
- `Arrays.equals()` 数组大小相同，且每个元素都相等。那这里的相等用的是哪个判断，==，还是 equals，感觉是 ==
- 对象都是在堆中，但是引用对象的变量大概率都是在栈中
- 一个方法可以访问所属类的所有对象的私有数据，即 A, B 两个对象，A 里面的方法，是可以直接访问 B 的 private 字段的。
- 编译包里面的类，都要加上全路径的。javac com/dengbo/xxxx, java com.dengbo.xxxx
- 为了使类能够被多个程序共享
  1. 把类文件放到一个目录中，例如 `/home/user/classdir`。对于类 Employee 类，需要放在 `/home/user/classdir/com/dengbo/Employee.java`。
  2. 将 jar 文件放在一个目录中，例如 `/home/user/archives`。
  3. 设置类路径。类路径中的各项之间用 : 分隔，用 . 表示当前目录 `/home/user/classdir:.:/home/user/archive.jar`
  4. 所以这个其实就是 class path 的东西，就和其他的 path 变量一样，应该就类似于找包的时候，可以从这 3 个目录中去找
- 使用 `-classpath` 或者 `--class-path` 指定类路径。`java -classpath /home/user/classdir:.:/home/user/archives/archive.jar MyProg`
- 或者也可以用 CLASSPATH 环境变量。
- 除了类文件和其他资源外，每个 JAR 文件还包含一个清单文件，用于描述归档文件的特殊特性。位于 JAR 文件的 META-INF 目录下的 MANIFEST.MF 文件。但是没太看懂这个文件具体的作用是什么，里面的内容是根据什么东西生成的。
- 执行 jar 文件，java -jar MyProgram.jar，感觉一般是要把文件编译后再打包。
- 方法注释 `@param variable description`, `@return description`, `@throws class description`
- 类注释 `@author name`, `@version version`
- 如果子类的构造器没有显式地调用超类的构造器，将自动地调用超类的无参数构造器。如果超类没有无参数的构造器，会编译报错。
- 只能在继承层次内进行强制类型转换
- 在将超类强制转换成子类之前，应该使用 instanceof 进行检查
- 是可以声明接口的对象变量的。像 List 就是这样吗。
- protected 对于同一个包中的所有类都是可以访问的，不仅限于子类，已经类似于 public 了，只有对于其他包来说，protected 必须只能由子类访问。
- 数组类型也扩展自 Object 类。
- `list.add(3)` 自动装箱 `list.add(Integer.valueOf(3))`, `int n = list.get(i)` 自动拆箱 `int n = list.get(i).intValue()`。
- 枚举的构造函数总是 private。可以把各个枚举值，看成是，对应枚举类的实例，只不过这些实例基本就是不可变的。
- 看描述，理论上可以通过 Class.forName 加载类，这样就没必要再启动时加载所有需要的类。
- Class 类实际上是一个泛型类，例如，Employee.class 的类型是 `Class<Employee>`。但是这会把问题变得更复杂，所以我们一般就使用原始的 Class 类。
- Field, Method, Constructor 三个类，都有一个叫做 getName 的方法，用来返回字段、方法或构造器的名称。Field 还有一个 getType 方法，用来返回描述字段类型的一个对象，这个对象的类型同样是 Class。Method 和 Constructor 类有报告参数类型的方法，Method 类还有一个返回类型的方法。这三个类都有一个名为 getModifiers 的方法，返回一个整数，用不同的 0/1 位描述所使用的修饰符，如 public 和 static。
- Class 类中的 getFields, getMethods, getConstructors 方法将分别返回这个类支持的公共字段、方法和构造函数的数组，其中包括超类的公共成员。getDeclaredFields, getDeclaredMethods, getDeclaredConstructors 方法将返回这个类声明的所有成员，但不包括超类的成员。
- 接口绝不会有实例字段
- `Comparator<String> comp = (first, second) -> first.length() - second.length();`，这还是挺奇怪的，首先接口是不能 new 出对象，那右边这个是算什么对象。lambda 对象？
- object::instanceMethod，等价于向方法传递参数的 lambda 表达式，即假设抽象方法的参数是 x,y...，应该就等价于 object.instanceMethod(x, y, ...)
- Class::instanceMethod，第一个参数会成为方法的隐式参数，即 x,y..., 会成了 x.instanceMethod(y, ...)
- Class::staticMethod，所有参数都是方法的参数
- Integer::new 等价于 `x -> new Integer(x)`
- Integer[]::new 等价于 `x -> new Integer[x]`
- 使用内部类的两个原因
  - 可以对同一个包中的其他类隐藏
  - 内部类方法可以访问定义这个类的作用域中的数据，包括原本私有的数据
- 相当于一个内部类，肯定是只能由外部的这个类的实例或者静态方法创建，那如果是实例创建的，内部类就可以访问到这个实例的 private 内容。
- 普通内部类。局部内部类。匿名内部类 `new SuperType(construction parameters) { inner class methods and data }`，静态内部类
- 由于构造函数名字必须和类名相同，而匿名内部类没有类名，所以，匿名内部类就不能有构造函数。实际上，构造参数要传递给超类构造函数。
- 断言机制允许在测试期间向代码中插入一些检查，而在生产代码中会自动删除这些检查
- `Logger.getGlobal().info("xxxxxx")` 全局日志
- `Logger logger = Logger.getLogger("com.company.app")` 创建独立的日志记录器。
- 日志记录器之间也有层次结构。
- 7 个日志级别，默认情况下只记录前 3 个级别
  - SEVERE
  - WARNING
  - INFO
  - CONFIG
  - FINE
  - FINER
  - FINEST
- `logger.warning()`, `logger.log(Level.FINE, message)`
- 原始类型用第一个限定来替换类型变量，比如 `T extends Comparable & Serializable`，原始类型就被替换成了 Comparable。
- 还是不太懂这个通配符类型，`Pair<? extends Employee>` 和 `Pair<T extends Employee>` 有什么区别，根据 chatGPT 的回答如下
  - `Pair<? extends Employee>` 通常用于方法参数中，以表示这个参数可以接受任何 Employee 或其子类的 Pair 对象。通配符 ? 是一种只读类型，意味着你不能向这个 Pair 对象中添加任何元素，因为你不知道其具体类型。也就是说，我们可以把它按照 `Pair<Employee>` 读取，但是我们无法进行任何的写入操作，因为不知道他是什么类型，它可能是 `Pair<Manager>` 这样的话，如果你写入 Employee 肯定会报错
  - `Pair<T extends Employee>` 通常用于类或方法的泛型定义中，提供更具体的类型信息。你可以在方法内部自由地使用类型 T，因为它在定义时已经被约束为 Employee 或其子类。
  - 这么说感觉还是不太明白。`Pair<? extends Employee>`不能用来声明一个泛型类吗。好像还真不能，你要是用了，那定义的时候其他类型参数出现的地方，你拿什么替换？问号吗，不合法。所以，还确实只是某个单一出现的地方才能用。
- 一般来说，只要正常退出和异常退出两种终止线程的方法。interrupt 可以用来请求终止一个线程。调用这个方法，会设置线程的中断状态。
- Java 中的每个对象都有一个内部锁，如果一个方法声明时有 synchronized 关键字，那么对象的锁将保护整个方法。也就是说，要调用这个方法，线程必须获得内部对象锁。
- 内部对象锁只有一个关联条件，wait 方法将一个线程增加到等待集中，notifyAll/notify 方法可以解除等待线程的阻塞。
- 进入一个同步块，也可以获得某个对象的锁 `synchronized (obj) {  // ... }` 可以获得 obj 的锁。
- InputStream
  - `abstract int read()`
  - `int read(byte[] b)`
  - `int read(byte[] b, int off, int len)`
  - `int readNBytes(byte[] b, int off, int len)`
  - `byte[] readAllBytes()`
  - `long transferTo(OutputStream out)`
  - `long skip(long n)`
  - `int available()`
  - `void close()`
- OutputStream
  - `abstract void write(int n)`
  - `void write(byte[] b)`
  - `void write(byte[] b, int off, int len)`
  - `void close()`
  - `void flush()`
- 某些输入流可以从文件和其他更外部的位置上获取字节，而其他的输入流可以将字节组装到更有用的数据类型中。必须将二者进行组合。
- `var fin = new FileInputStream("file.txt"); var din = new DataInputStream(fin); double x = din.readDouble();`
- FileInputSteam
  - `FileInputStream(String name)`
  - `FileInputStream(File file)`
- FileOutputStream
  - `FileOutputStream(String name)`
  - `FileOutputStream(File file)`
  - `FileOutputStream(String name, boolean append)`
  - `FileOutputStream(File file, boolean append)`
- Paths: 大部分类都有个这种加个 s 的伴生类，貌似一些静态方法都会放到伴生类上，比如 Objects, Arrays
  - `static Path get(String first, String... more)`;
- Path
  - `Path resolve(Path other)`
  - `Path resolve(String other)`
  - `Path.relativize(Path other)`
  - `Path normalize()`
  - `Path toAbsolutePath()`
  - `Path getParent()`
  - `Path getFileName()`
  - `Path getRoot()`
- Files
  - `static bytes[] readAllBytes(Path path)`
  - `static String readString(Path path, Charset charset)`
  - `static List<String> readAllLines(Path path, Charset charset)`
  - `static Path write(Path path, bytes[] contents, OpenOption... options)`
  - `static InputStream newInputStream(Path path, OpenOption... options)`
  - `static OutputStream newOutputStream(Path path, OpenOption... options)`
  - `static Path createFile(Path path, FileAttribute<?>... attrs)`
  - `static Path createDirectory(Path path, FileAttribute<?>... attrs)`
  - `static Path createDirectories(Path path, FileAttribute<?>... attrs)`
  - `static Path createTempFile(Path dir, String prefix, String suffix, FileAttribute<?>... attrs)`
  - `static Path copy(Path source, Path target, CopyOption... options)`
  - `static Path move(Path source, Path target, CopyOption... options)`
  - `static void delete(Path path)`
  - `static boolean deleteIfExists(Path path)`
- Socket
  - `Socket(String host, int port)`
  - `InputStream getInputStream()`
  - `OutputStream getOutputStream()`
  - `void connect(SocketAddress address)`
  - `void connect(SocketAddress address, int timeout)`
  - `void setSoTimeout(int timeout)`
  - `boolean isClosed()`
  - `boolean isConnected()`
- InetAddress
  - `static InetAddress getByName(String host)`
  - `static InetAddress[] getAllByName(String host)`
  - `static InetAddress getLocalHost()`
  - `byte[] getAddress()`
  - `String getHostAddress()`
  - `String getHostName()`
- ServerSocket
  - `ServerSocket(int port)`
  - `Socket accept()`
  - `void close()`
  - `void shutdownOutput()`
  - `void shutdownInput()`
- URL
