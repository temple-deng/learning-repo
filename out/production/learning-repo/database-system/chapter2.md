# 第一部分 关系数据库

<!-- TOC -->

- [第一部分 关系数据库](#第一部分-关系数据库)
- [第 2 章 关系模型介绍](#第-2-章-关系模型介绍)
  - [2.1 关系数据库的结构](#21-关系数据库的结构)
  - [2.3 码](#23-码)
  - [2.5 关系查询语言](#25-关系查询语言)
  - [2.6 关系运算](#26-关系运算)

<!-- /TOC -->

# 第 2 章 关系模型介绍

## 2.1 关系数据库的结构

关系数据库由表的集合构成，每个表有唯一的名字。

prereq 表中的每行表示了两门课程之间的 **联系**：其中一门课程是另一门课程的先修课。作为
另一个例子，我们考察 instructor 表，表中的行可被认为是代表了从一个特定的 ID 到相应的
name, dept_name, salary 值之间的联系。   


一般来说，表中一行代表了一组值之间的一种联系。由于一个表就是这种联系的一个集合，表这个
概念和数学上的关系这个概念是密切相关的。在数学术语中，元组只是一组值的序列。在 n 个值
之间的一种联系可以在数学上用关于这些值的一个 n 元组表示，对应表中的一行。    

在关系模型术语中，**关系**用来指代表，**元祖**用来指代行，**属性**指代的是表中的列。     

对于关系的每个属性，都存在一个允许取值的集合，称为该属性的 **域**。我们要求都所有关系
r 来说，r 的所有属性的域都是原子的。如果域中元素被看做是不可再分的单元，则域是 **原子的**。
重要的问题不在于域本身是什么，而在于我们怎样在数据库中使用域中元素。   

## 2.3 码

**超码**是一个或多个属性的集合，这些属性的组合可以使我们在一个关系中唯一地标识一个元组。    

形式化地描述，设 R 表示关系 r 模式中的属性集合。如果我们说 R 的一个子集 K 是一个超码，
则限制了关系 r 中任意两个不同元组不会在 K 的所有属性上完全相等。    

如果 K 是一个超码，那么 K 的任意超集也是超码。我们通常只对这样的一些超码感兴趣，它们的任意
真子集都不能成为超码。这样的最小超码称为**候选码**。     

几个不同的属性集都可以做候选码的情况是存在的，也就是说可能不仅仅存在一组候选码。注意这些
不同的候选码不见得集合中属性的个数相同。     

我们用**主码**这个术语来代表被数据库设计者选中的、主要用来在一个关系中区分不同元祖的候选码。     

习惯上把一个关系模式的主码属性列在其他属性前面，并且还可能加了下划线。     

一个关系模式(如 r<sub>1</sub>)可能在他的属性中包括另一个关系模式(如 r<sub>2</sub>)的主码。
这个属性在 r<sub>1</sub> 上称作参照 r<sub>2</sub> 的**外码**。关系r<sub>1</sub>也称为
外码依赖的参照关系，r<sub>2</sub>叫做外码的被参照关系。     

## 2.5 关系查询语言

查询语言是用户用来从数据库中请求获取信息的语言。查询语言可以分为过程化的和非过程化的。在**过程化语言**
中，用户指导系统对数据库执行一系列操作以计算出所需结果。在**非过程化语言**中，用户只需描述
所需信息，而不用给出获取该信息的具体过程。      

SQL 即包含过程化的成分，又包括非过程化的成分。    

有一些“纯”查询语言：关系代数是过程化的，而元祖关系演算和域关系演算是非过程化的。关系代数包括一个
运算的集合，这些运算以一个或两个关系为输入，产生一个新的关系作为结果、关系演算使用谓词逻辑
定义所需的结果，但不需给出获取结果的特定代数过程。     

## 2.6 关系运算

所有的过程化关系查询语言都提供了一组运算，这些运算要么施加于单个关系上，要么施加于一对关系
上。这些运算具有一个很好的，并且也是所需的性质：运算结果总是单个的关系。这个性质使得人们
可以模块化的方式来组合几种这样的运算。          

既然 SQL 包含过程化的部分，所以也就有关系运算的功能咯。   

最常用的关系运算是从单个关系中选出满足一些特定谓词（如 salary &gt; 85000）的特殊元组。
其结果是一个新关系，它是原始关系的一个子集。   

另一个常用的运算是从一个关系中选出特定属性（列）。    

**连接** 运算可以通过下述方式来结合两个关系：把分别来自两个关系的元组对合并成单个元组。
有几种不同的方式进行连接。   

**自然连接**，在这种连接形式中，对于来自 instructor 关系的一个元组与 department 关系
中的一个元组来说，如果它们在 dept_name 属性上的取值相同，那它们就是匹配的。所有这样匹配
的元组对都会在连接结果中出现。    

**笛卡尔积** 运算从两个关系中合并元组，但不同于连接运算的是，其结果包含来自两个关系元素的
所有对，无论它们的属性值是否匹配。   

