# 汇编指令总结

<!-- TOC -->

- [汇编指令总结](#汇编指令总结)
  - [信息访问类指令](#信息访问类指令)
  - [数据传送指令](#数据传送指令)
      - [MOV 类](#mov-类)
      - [MOVZ 类](#movz-类)
      - [MOVS 类](#movs-类)
      - [栈操作](#栈操作)
  - [算术和逻辑操作](#算术和逻辑操作)
    - [加载有效地址](#加载有效地址)
    - [一元操作](#一元操作)
    - [二元操作](#二元操作)
    - [移位操作](#移位操作)
    - [特殊的算术操作](#特殊的算术操作)
  - [控制](#控制)
    - [设置条件码：CMP 和 TEST](#设置条件码cmp-和-test)
    - [访问条件码：SET](#访问条件码set)
    - [跳转指令](#跳转指令)
    - [条件传送指令](#条件传送指令)

<!-- /TOC -->

## 信息访问类指令

## 数据传送指令

将数据从一个位置复制到另一个位置。

#### MOV 类

指令 | 效果 | 描述
---------|----------|---------
 movb |  | 传送字节
 movw |  | 传送字
 movl |  | 传送双字
 movq |  | 传送四字
 movabsq  I, R | R ← I | 传送绝对的四字

源可以是立即数、寄存器值或内存中的值。目的可以为寄存器或内存。不过不能都是内存。    

#### MOVZ 类

将较小的源复制到较大的目的时使用，使用零扩展填充剩余字节。     

指令 | 效果 | 描述
---------|----------|---------
 movzbw |  | 将做了零扩展的字节传送到字
 movzbl |  | 将做了零扩展的字节传送到双字
 movzbq |  | 将做了零扩展的字节传送到四字
 movzwl |  | 将做了零扩展的字传送到双字
 movzwq |  | 将做了零扩展的字传送到四字     

为什么没有 movzlq？因为 movl 即可，讲寄存器的时候提过，只处理通用寄存器的 4 个字节时，
会将高位的 4 个字节清零，等价于进行了零扩展。    

#### MOVS 类

将较小的源复制到较大的目的时使用，使用符号扩展填充剩余字节。     

指令 | 效果 | 描述
---------|----------|---------
 movsbw |  | 将做了符号扩展的字节传送到字
 movsbl |  | 将做了符号扩展的字节传送到双字
 movsbq |  | 将做了符号扩展的字节传送到四字
 movswl |  | 将做了符号扩展的字传送到双字
 movswq |  | 将做了符号扩展的字传送到四字     
 movslq |  | 将做了符号扩展的双字传送到四字
 cltq   | %rax &lt;- 符号扩展(%eax) | 将 %eax 符号扩展到 %rax  

#### 栈操作

指令 | 效果 | 描述
---------|----------|---------
 pushq S | R[%rsp] &lt;- R[%rsp] - 8;  M[R[%rsp]] &lt;- S | 将四字压入栈
 popq D | D &lt;- M[R[%rsp]]; R[%rsp] &lt;- R[%rsp] + 8 | 将四字弹出栈

## 算术和逻辑操作

本节给出的所有指令类都有对四种不同大小数据的指令（除了 leaq）。   

### 加载有效地址

指令 | 效果 | 描述
---------|----------|---------
 leaq S, D | D &lt;- &S | 加载有效地址

源必须是内存，目的必须是寄存器。    

### 一元操作

指令 | 效果 | 描述
---------|----------|---------
 INC D | D &lt;- D + 1 | 加 1
 DEC D | D &lt;- D - 1 | 减 1
 NEG D | D &lt;- -D | 取负
 NOT D | D &lt;- ~D | 取补

操作数可以是寄存器也可以是内存位置。   

### 二元操作

指令 | 效果 | 描述
---------|----------|---------
 ADD S, D | D &lt;- D + S | 加
 SUB S, D | D &lt;- D - S | 减
 IMUL S, D | D &lt;- D * S | 乘
 XOR S, D | D &lt;- D ^ S | 异或
 OR S, D | D &lt;- D | S | 或
 AND S, D | D &lt;- D & S | 与

第一个操作数可以是立即数、寄存器或内存，第二个操作数是寄存器或内存。    

### 移位操作

指令 | 效果 | 描述
---------|----------|---------
 SAL k, D | D &lt;- D &lt;&lt; k | 左移
 SHL k, D | D &lt;- D &lt;&lt; k | 左移
 SAR k, D | D &lt;- D &gt;&gt; k | 算术右移
 SHR k, D | D &lt;- D &gt;&gt; k | 逻辑右移

移位量可以是一个立即数，或者放在单字节寄存器 %cl 中。    

### 特殊的算术操作

指令 | 效果 | 描述
---------|----------|---------
 imulq S | R[%rdx]: R[%rax] &lt;- S * R[%rax] | 有符号全乘法
 mulq S | R[%rdx]: R[%rax] &lt;- S * R[%rax] | 无符号全乘法
 clto | R[%rdx]: R[%rax] &lt;- 符号扩展(R[%rax]) | 转换为八字
 idivq S | R[%rdx] &lt;- R[%rdx]: R[%rax] mod S or R[%rdx] &lt;- R[%rdx]:R[%rax] / S | 有符号除法
 divq S | R[%rdx] &lt;- R[%rdx]: R[%rax] mod S or R[%rdx] &lt;- R[%rdx]:R[%rax] / S | 无符号除法    

对于 128 位数的除法来说，将商存储在寄存器 %rax 中，将余数存储在寄存器 %rdx 中。    

对于大多数 64 位除法来说，除数也常常是一个 64 位的值，这个值应该存放在 %rax 中，%rdx
的位应该设置为全 0（无符号运算）或者 %rax 的符号位（有符号运算）。     

这就看出指令的操作间的差异了，除法和产生 128 位的乘法必须要先进行额外的数据传送操作把数据
传送到指定的寄存器中。而且取结果的时候，也要从两个寄存器中取值。   

## 控制

### 设置条件码：CMP 和 TEST

书上说 CMP 和 SUB 类似，而 TEST 和 AND 类似，那 S1 应该可以是立即数，寄存器或内存，
S2 可以是寄存器或内存。    

指令 | 基于 | 描述
---------|----------|---------
 cmpb S1, S2 | S2 - S1 | 比较字节
 cmpw S1, S2 | S2 - S1 | 比较字
 cmpl S1, S2 | S2 - S1 | 比较双字
 cmpq S1, S2 | S2 - S1 | 比较四字
 testb S1, S2 | S1 & S2 | 测试字节
 testw S1, S2 | S1 & S2 | 测试字
 testl S1, S2 | S1 & S2 | 测试双字
 testq S1, S2 | S1 & S2 | 测试四字

### 访问条件码：SET

一条 SET 指令的目的操作数是低位单字节寄存器元素之一，或是一个字节的内存位置，指令会将这个
字节设置成 0 或者 1。    


指令 | 同义名 | 效果 | 设置条件
---------|----------|---------|---------
 sete D | setz | D ← ZF | 相等 / 零
 setne D | setnz | D ← ~ZF | 不等 / 非零
 sets D |  |  D ← SF | 负数
 setns D | | D ← ~ SF | 非负数
 setg D | setnle | D ← ~(SF ^ OF) & ~ZF | 大于（有符号 &gt;）
 setge D | setnl | D ← ~(SF ^ OF) | 大于等于（有符号 &gt;=）
 setl D | setnge | D ← SF ^ OF | 小于（有符号 &lt;）
 setle D | setng | D ← (SF ^ OF) | ZF | 小于等于（有符号 &lt;=）
 seta D | setnbe | D ← ~CF & ~ZF | 超过（无符号 &gt;）
 setae D | setnb | D ← ~CF | 超过或相等（无符号 &gt;=）
 setb D | setnae | D ← CF | 低于（无符号 &lt;）
 setbe D | setna | D ← CF | ZF | 低于或相等（无符号 &lt;=）    

### 跳转指令

jmp 指令是无条件跳转，它可以是直接跳转，即跳转目标是作为指令的一部分编码的；也可以是间接
跳转，即跳转目标是从寄存器或内存位置中读出的。直接跳转是给出一个标号作为跳转目标的，间接
跳转是 * 后面跟一个操作数指示符。    

![jmp-instructions](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/jmp-instructions.png)    

### 条件传送指令

每条指令都有两个操作数：源寄存器或者内存地址 S, 和目的寄存器 R。与不同的 SET 和跳转指令
一样，这些指令的结果取决于条件码的值。源值可以从内存或者源寄存器中读取，但是只有在指定的
条件满足时，才会被复制到目的寄存器中。    

由于其实是数据传送指令，貌似指令类要分成 4 种不同数据大小的指令了。但是汇编器可以从目标
寄存器的名字推断出条件传送指令的操作数长度，其实是不用分大小的。    

![cmov-instructions](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/cmov-instructions.png)    

