# 第 6 章 存储器层次结构

<!-- TOC -->

- [第 6 章 存储器层次结构](#第-6-章-存储器层次结构)
  - [6.1 存储技术](#61-存储技术)
    - [6.1.1 随机访问存储器](#611-随机访问存储器)
    - [6.1.2 磁盘存储](#612-磁盘存储)
    - [6.1.3 固态硬盘](#613-固态硬盘)
  - [6.4 高速缓存存储器](#64-高速缓存存储器)
    - [6.4.1 通用的高速缓存存储器组织结构](#641-通用的高速缓存存储器组织结构)
    - [6.4.2 直接映射高速缓存](#642-直接映射高速缓存)
    - [6.4.3 组相联高速缓存](#643-组相联高速缓存)

<!-- /TOC -->

## 6.1 存储技术

### 6.1.1 随机访问存储器

随机访问存储器(Random-Access Memory, RAM)分为两类：静态的和动态的。静态 RAM(SRAM)比
动态RAM(DRAM)更快，但也贵的多。SRAM 用来作为高速缓存存储器，即可以在 CPU 芯片上，也可以
在片下。DRAM 用来作为主存。     

1. **静态 RAM**    

SRAM 将每个位存储在一个双稳态的存储器单元里。每个单元是用一个六晶体管电路来实现的。这个
电路有这样一个属性，它可以无限期地保持在两个不同的电压配置或状态之一。其他任何状态都是
不稳定的——从不稳定状态开始，电路会迅速地转移到两个稳定状态中的一个。     

由于 SRAM 存储单元的双稳态特性，只要有电，它就会永远地保持它的值，即使有干扰来扰乱电压，
当电压消除时，电路就会恢复到稳定值。    

2. **动态 RAM**    

DRAM 将每个为存储为对一个电容的充电。DRAM 存储器可以制造得非常密集——每个单元由一个电容和
一个访问晶体管组成。但是，与 SRAM 不同，DRAM 存储器单元对干扰非常敏感。当电容的电压被
扰乱之后，它就永远不会恢复了。暴露在光线下会导致电容电压改变。     

3. **传统的 DRAM**    

DRAM 芯片中的单元被分成 d 个超单元，每个超单元都由 w 个 DRAM 单元组成。一个 d * w 的
DRAM 总共存储了 dw 位信息。超单元被组织成一个 r 行 c 列的长方形阵列，这里 rc = d。每个
超单元有形如(i, j)的地址。   

例如，图 6-3 展示的是一个 16 * 8 的 DRAM 芯片的组织，有 d = 16 个超单元，每个超单元
有 w=8 位，r = 4 行, c = 4 列。信息通过称为引脚的外部连接器流入和流出芯片。每个引脚
携带一个 1 位的信号。图 6-3 给出了两组引脚：8个 data 引脚，它们能传送一个字节到芯片或
从芯片传出一个字节，以及 2 个 addr 引脚，它们携带 2 位的行和列超单元地址。注意其实 i,j
是共享引脚的，也就是其实一共只有一组 addr 引脚，一组有 2 个。    

![dram](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/dram.png)    

每个 DRAM 芯片被连接到某个称为 **内存控制器** 的电路，这个电路可以一次传送 w 位到每个
DRAM 芯片或一次从每个 DRAM 芯片传出 w 位。为了读出超单元 (i,j) 的内容，内存控制器将
行地址 i 发送到 DRAM，然后是列地址 j。DRAM 把超单元 (i,j) 的内容发回给控制器作为响应。    

电路设计者将 DRAM 组织成二维阵列而不是线性数组的一个原因是降低芯片上地址引脚的数量。例如，
如果示例的 128 位 DRAM 组织成一个 16 个超单元的线性数组，地址为 0~15，那么芯片会需要 4 个
地址引脚而不是 2 个。二维阵列的缺点是必须分两步发送地址，这增加了访问时间。    

4. **内存模块**    

DRAM 芯片封装在内存模块中，它插到主板的扩展槽上。Core i7 系统使用的 240 个引脚的双列
直插内存模块。它以 64 位为块传送数据到内存控制器和从内存控制器传出数据。    

图 6-5 展示了一个内存模块的基本思想。示例模块用 8 个 64Mbit 的 8M * 8 的DRAM 芯片，
总共存储 64MB。这 8 个芯片的编号为 0~7，每个超单元存储主存的一个字节，而用相应超单元
地址为 (i, j) 的 8 个超单元来表示主存中字节地址 A 处的 64 位字。    

要取出内存地址 A 处的一个 64 位值，内存控制器将 A 转换成一个超单元地址 (i,j)，并将它发送
到内存模块，然后内存模块再将 i 和 j 广播到每个 DRAM。作为响应，每个 DRAM 输出它的 (i,j)
超单元的 8 位内容。模块中的电路收集这些输出，并将它们合并成一个 64 位字，再返回给内存控制器。     

![memory-module](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/memory-module.png)    

5. **增强的 DRAM**    

+ 快页模式 DRAM(Fast Page Model DRAM, FPM DRAM)。
+ 扩展数据输出 DRAM。FPM DRAM 的一个增强的形式。
+ 同步 DRAM(Synchronous DRAM, SDRAM)。就它们与内存控制器通信使用一组显示的控制信号来说，
常规的、FPM 和 EDO DRAM 都是异步的。SDRAM 用与驱动内存控制器相同的外部时钟信号的上升沿
来代替许多这样的控制信号，可以使其比那些异步的存储器更快地输出内容。
+ 双倍数据速率同步 DRAM(DDR SDRAM)作为对 SDRAM 的一种增强，通过使用两个时钟沿作为控制
信号，从而使 DRAM 的速度翻倍。


6. **非易失性存储器**    

PROM(Programmable ROM)只能被编程一次。PROM 的每个存储器单元有一种熔丝，只能用高电流熔断一次。   

可擦写可编程 ROM(Erasable Programmable ROM, EPROM)。对 EPROM 编程是通过使用一种把 1
写入 EPROM 的特殊设备完成的，EPROM 能够被擦除和重编程的次数的数量级可以达到 1000次。
电子可擦除 PROM(Electrically Erasable PROM, EEOROM) 类似于 EPROM，但是它不需要一个
物理上独立的编程设备，因此可以直接在印制电路卡上编程。其可编程的次数的数量级可以达到 100000 次。    

闪存是一类非易失性存储器，基于 EEPROM。   

存储在 ROM 设备中的程序通常被称为 **固件**，当一个计算机系统通电以后，它会运行存储在 ROM
中的固件。一些系统在固件中提供了少量基本的输入和输出函数——例如 PC 的 BIOS 例程。复杂的
设备，像显卡和磁盘驱动控制器，也依赖固件翻译来自 CPU 的 I/O 请求。     

7. **访问主存**    

数据流通过称为总线的共享电子电路在处理器和 DRAM 之间来来回回。    

总线是一组并行的导线，能携带地址、数据和控制信号。取决于总线的设计，数据和地址信号可以共享
同一组导线，也可以使用不同的。同时，两个以上的设备也能共享同一总线。控制线携带的信号会同步
事务，并标识出当前正在被执行的事务的类型。例如，当前关注的这个事务是到主存的吗？还是到
诸如磁盘控制器这样的其他 I/O 设备？这个事务是读还是写？总线上的信息是地址还是数据项。    

考虑当 CPU 执行一个如下加载操作时会发生什么：    

`movq A, %rax`     

这里，地址 A 的内容被加载到寄存器 %rax 中。CPU 芯片上称为 **总线接口** 的电路在总线上
发起读事务。读事务是由三个步骤组成的。首先，CPU 将地址 A 放到系统总线上。I/O 桥将信号
传递到内存总线。接下来，主存感觉到内存总线上的地址信号，从内存总线读地址，从 DRAM 取出
数据字，并将数据写到内存总线。I/O 桥将内存总线信号翻译成系统总线信号，然后沿着系统总线
传递。最后，CPU 感觉到系统总线上的数据，从总线上读数据，并将数据复制到寄存器 %rax。     

![read-transaction](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/read-transaction.png)    

反过来，当 CPU 执行一个像下面这样的存储操作时：   

`movq %rax, A`    

这里，寄存器 %rax 的内容被写到地址 A，CPU 发起写事务。同样，有三个基本步骤。首先，CPU 将
地址放到系统总线上。内存从内存总线读出地址，并等待数据到达。接下来，CPU 将 %rax 中的数据
字复制到系统总线。最后，主存从内存总线读出数据字，并且将这些位存储到 DRAM 中。    

### 6.1.2 磁盘存储

1. **逻辑磁盘块**    

现代磁盘构造复杂，有多个盘面，这些盘面上有不同的记录区。为了对操作系统隐藏这样的复杂性，
现代磁盘将它们1的构造呈现为一个简单的视图，一个 B 个扇区大小的 **逻辑块** 的序列，编号
0,1, ..., B-1。磁盘封装中有一个小的硬件/固件设备，称为 **磁盘控制器**，维护着逻辑块号
和实际磁盘扇区之间的映射关系。    

当操作系统想要执行一个 I/O 操作时，例如读一个磁盘扇区的数据到主存，操作系统会发送一个命令
到磁盘控制器，让它读某个逻辑块号。控制器上的固件执行一个快速表查找，将一个逻辑块号翻译成
一个（盘面，磁道，扇区）的三元组。控制器上的硬件会解释这个三元组，将读/写头移动到适当的
柱面，等待扇区移动到读写头下，将读写头感知到的位放到控制器上的一个小缓冲区中，然后将他们
复制到主存中。    

2. **访问磁盘**    

虽然详细描述 I/O 设备是如何工作的以及如何对它们进行编程超出了我们讨论的范围，但是我们可以
给你一个简要的描述。例如，图 6-12 总结了当 CPU 从磁盘读数据时发生的步骤。    

![read-disk-sector](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/read-disk-sector.png)    

CPU 使用一种称为内存映射 I/O 的技术来向 I/O 设备发射命令。在使用内存映射 I/O 的系统中，
地址空间中有一块地址是为与 I/O 设备通信保留的。每个这样的地址称为一个 I/O 端口。当一个
设备连接到总线时，它与一个或多个端口相关联。     

假设磁盘控制器映射到端口 0xa0。随后，CPU 可能通过执行三个对地址 0xa0 的存储指令，发起
磁盘读：第一条指令是发送一个命令字，告诉磁盘发起一个读，同时还发送了其他的参数，例如当读
完成时，是否中断 CPU。第二条指令指明了应该读的逻辑块号。第三条指令指明应该存储磁盘扇区
内容的主存地址。    

在磁盘控制器收到来自 CPU 的读命令之后，它将逻辑块号翻译成一个扇区地址，读该扇区的内容，
然后将这些内容直接传送到主存，不需要 CPU 的干涉。设备可以自己执行读或者写总线事务而不
需要 CPU 干涉的过程，称为 DMA。     

在 DMA 传送完成，磁盘扇区的内容被安全地存储在主存中以后，磁盘控制器通过给 CPU 发送一个
中断信号来通知 CPU。     

### 6.1.3 固态硬盘

固态硬盘是一种基于闪存的存储技术。一个 SSD 封装由一个或多个闪存芯片和闪存翻译层组成，
闪存芯片替代传统旋转磁盘中的机械驱动器，而闪存翻译层是一个硬件/固件设备，扮演与磁盘控制器
相同的角色，将对逻辑块的请求翻译成对底层物理设备的访问。   

![ssd](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/ssd.png)    

读 SSD 比写要快，一个闪存由 B 个块的序列组成，每个块由 P 页组成。通常，页的大小是 512字节
~ 4KB，块是由 32~128页组成。数据是以页为单位读写的。只有在一页所属的块整个被擦除之后，
才能写这一页。不过，一旦一个块被擦除了，块中每一个页都可以不需要再进行擦除就写一次。在
大约进行 100 000 次重复写之后，块就会磨损坏。一旦一个块磨损坏之后，就不能再使用了。    

## 6.4 高速缓存存储器

L1 高速缓存的访问速度几乎和寄存器一样快，典型地是大约 4 个时钟周期。L2 高速缓存可以在大约
10 个时钟周期内访问到。L3 高速缓存可以在大约 50 个周期内访问到。    

### 6.4.1 通用的高速缓存存储器组织结构

考虑一个计算机系统，其中每个存储器地址有 m 位，形成 M = 2<sup>m</sup> 个不同的地址。
这样一个机器的高速缓存被组织成一个有 S = 2<sup>s</sup> 个高速缓存组的数组。每个组包含
E 个高速缓存行(cache line)。每个行是由一个 B = 2<sup>b</sup> 字节的数据块(block)组成的，
一个有效位(valid bit)指明这个行是否包含有意义的信息，还有 t = m - (b+s) 个标记位，它们
唯一地标志存储在这个高速缓存行的块。   

![cache](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/cache.png)    

奇怪的是如何标志出选中的是哪一个缓存行内？？？     

当一条加载指令指示 CPU 从主存地址 A 中读一个字时，它将地址 A 发送到高速缓存。如果高速缓存
正保存着地址 A 处那个字的副本，它将立即将那个字发回给 CPU。那么高速缓存如何知道它是否包含
地址 A 处那个字的副本呢？高速缓存的结构使得它能够通过简单地检查地址位，找到所请求的字。   

参数 S 和 B 将 m 个地址分为了三个字段，A 中的 s 个组索引位是一个到 S 个组的数组的索引。
一旦我们知道了这个字必须放在哪个组中，A 中的 t 个标记位就告诉我们这个组中的哪一行包含这个
字。然后 b 个块偏移位给出了在 B 个字节的数据块中的字偏移。   

### 6.4.2 直接映射高速缓存

根据每个组的高速缓存行数 E，高速缓存被分为不同的类。每个组只有一行的高速缓存被称为 _直接映射_
高速缓存。    

高速缓存确定一个请求是否命中，然后抽取出被请求的字的过程，分为三步：1)组选择；2)行匹配；
3)字抽取：    

1. 组选择    

从 w 的地址中间抽取出 s 个组索引位。   

2. 行匹配     

由于每个组只有一行，因此这一步很容易，当且仅当设置了有效位，而且高速缓存行中的标记与 w 的
地址中的标记相匹配时，这一行包含 w 的一个副本。    

3. 字选择    

一旦命中，就从 w 中抽取出块偏移位确定位置。    

4. 缓存不命中时的行替换

如果缓存不命中，那么它需要从存储器层次结构中的下一层取出被请求的块，然后将新的块存储在组
索引位指示的组中的一个高速缓存行中。一般而言，如果组中的是有效高速缓存行了，那么必须要驱逐
一个现存的行。    

5. 综合    

假设我们有一个直接映射高速缓存，描述为：(S, E, B, m) = (4, 1, 2, 4)     

换句话说，高速缓存有 4 个组，每个组一行，每个块 2 个字节，而地址是 4 位的（奇怪，那一共
是 8 的字节的数据，3 位地址就够了啊，看下面的意思是额外的一位可以标识有效还是无效）。
我们还假设每个字都是单字节的。     

![cache-line-demo](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/cache-line-demo.png)    

+ 标记位和索引位连起来唯一地标识了内存中的每个块。
+ 因为有 8 个内存块，但是只有 4 个高速缓存组，所以多个块会映射到同一个高速缓存组，例如，
块 0 和 4 都映射到组 0。
+ 映射到同一个高速缓存组的块由标记位唯一地标识。    

### 6.4.3 组相联高速缓存

剩下的先略了。    

