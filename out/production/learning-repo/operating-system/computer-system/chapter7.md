# 第二部分 在系统上运行程序

<!-- TOC -->

- [第二部分 在系统上运行程序](#第二部分-在系统上运行程序)
- [第 7 章 链接](#第-7-章-链接)
  - [7.1 编译器驱动程序](#71-编译器驱动程序)
  - [7.2 静态链接](#72-静态链接)
  - [7.3 目标文件](#73-目标文件)
  - [7.4 可重定位目标文件](#74-可重定位目标文件)
  - [7.5 符号和符号表](#75-符号和符号表)
  - [7.6 符号解析](#76-符号解析)
    - [7.6.1 链接器如何解析多重定义的全局符号](#761-链接器如何解析多重定义的全局符号)
    - [7.6.2 与静态库链接](#762-与静态库链接)
    - [7.6.3 链接器如何使用静态库来解析引用](#763-链接器如何使用静态库来解析引用)
  - [7.7 重定位](#77-重定位)
    - [7.7.1 重定位条目](#771-重定位条目)
    - [7.7.2 重定位符号引用](#772-重定位符号引用)
  - [7.8 可执行目标文件](#78-可执行目标文件)
  - [7.9 加载可执行目标文件](#79-加载可执行目标文件)
  - [7.10 动态链接共享库](#710-动态链接共享库)
  - [7.11 从应用程序中加载和链接共享库](#711-从应用程序中加载和链接共享库)
  - [7.12 位置无关代码](#712-位置无关代码)

<!-- /TOC -->

# 第 7 章 链接

链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到
内存并执行。链接可以执行于 _编译时_，也就是在源代码被翻译成机器代码时；也可以执行于 _加载时_，
也就是程序被 _加载器_ 加载到内存并执行时；甚至执行于 _运行时_，也就是由应用程序来执行。
在现代操作系统中，链接是由叫做 _链接器_ 的程序自动执行的。    

链接器在软件开发中扮演一个关键的角色，因为它们使得分离编译成为可能。我们不用将一个大型的
应用程序组织为一个巨大的源文件，而是可以将它分解为更小、更好管理的模块，可以独立地修改和
编译这些模块。当我们改变这些模块中的一个时，只需简单地重新编译它，并重新链接应用，而不必
重新编译其他文件。   

## 7.1 编译器驱动程序

```c
// code/link/main.c
int sum(int *a, int n);

int array[2] = {1, 2};

int main() {
  int val = sum(array, 2);
  return val;
}
```    

```c
// code/link/sum.c
int sum(int *a, int n) {
  int i, s = 0;

  for (i = 0; i < n; i++) {
    s += a[i];
  }
  return s;
}
```    

大多数编译系统提供编译器驱动程序，它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。    

## 7.2 静态链接

像 Linux LD 程序这样的 _静态链接器_ 以一组可重定位目标文件和命令行参数作为输入，生成一个
完全链接的、可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码
和数据节(section)组成，每一节都是一个连续的字节序列。指令在一节中，初始化了的全局变量在
另一节中，而未初始化的变量又在另外一节中。     

为了构造可执行文件，链接器必须完成两个主要任务：    

+ **符号解析**(symbol resolution)。目标文件定义和引用符号，每个符号对应于一个函数、一个
全局变量或一个静态变量。符号解析的目的是将每个符号引用正好和一个符号定义关联起来。
+ **重定位**(relocation)。编译器和汇编器生成从地址 0 开始的代码和数据节。链接器通过把
每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得
它们指向这个内存位置。链接器使用汇编器产生的 _重定位条目_ 的详细指令，不加甄别地执行这样
的重定位。     

## 7.3 目标文件

目标文件有三种形式：   

+ **可重定位目标文件**。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并
起来，创建一个可执行目标文件。
+ **可执行目标文件**。包含二进制代码和数据，其形式可以被直接复制到内存并执行。
+ **共享目标文件**。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进
内存并链接。    

编译器和汇编器生成可重定位目标文件（包括共享目标文件）。链接器生成可执行目标文件。从技术上
来说，一个目标模块就是一个字节序列，而一个目标文件就是一个以文件形式存放在磁盘中的目标模块。    

目标文件是按照特定的目标文件格式组织的，各个系统的目标文件格式都不相同。Unix 使用的是 a.out
格式，Windows 使用的是 PE 格式，Mac 使用的是 Mach-O 格式，现代 Linux 和 Unix 使用的是
ELF 格式。    

## 7.4 可重定位目标文件

图 7-3 展示了一个典型的 ELF 可重定位目标文件格式。ELF 头(ELF header)以一个 16 字节的序列
开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF 头剩下的部分包含帮助链接器
语法分析和解释目标文件的信息。其中包括 ELF 头的大小、目标文件的类型（如可重定位、可执行
或者可共享）、机器类型（如x86-64）、节头部表（section header table）的文件偏移，以及
节头部表中条目的大小和数量。不同节的位置和大小是由节头部表描述的，其中目标文件中每个节
都有一个固定大小的条目。    

![elf](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/elf.png)    

夹在 ELF 头和节头部表之间的都是节。一个典型的 ELF 可重定位目标文件包含下面几个节：    

+ .text：已编译程序的机器代码
+ .rodata：只读数据，比如 printf 语句中的格式串和开关语句的跳转表
+ .data：已初始化的全局和静态 C 变量。局部 C 变量在运行时被保存在栈中，既不出现在 .data
节中，也不出现 .bss 节中
+ .bss：未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量。在目标文件中
这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了
空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配
这些变量，初始值为 0
+ .symtab：一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。和编译器中的符号表
不同，.symtab 符号表不包含局部变量的条目
+ .rel.text：一个 .text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改
这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地
函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略。
+ .rel.data：被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，
如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。    
+ .debug：一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局
变量，以及原始的 C 源文件。
+ .line：原始 C 源程序中的行号和 .text 节中机器指令之间的映射
+ .strtab：一个字符串表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的节
名字。字符串表就是以 null 结尾的字符串的序列。    

## 7.5 符号和符号表

每个可重定位目标模块 m 都有一个符号表，它包含 m 定义和引用的符号的信息。在链接器的上下文
中，有三种不同的符号：   

+ 由模块 m 定义并能被其他模块引用的 _全局符号_。全局链接器符号对应于 _非静态的 C 函数和全局变量_。
+ 由其他模块定义并被模块 m 引用的 _全局符号_。这些符号称为 _外部符号_，对应于在其他模块中
定义的非静态 C 函数和全局变量。
+ 只被模块 m 定义和引用的 _局部符号_。它们对应于带 static 属性的 C 函数和全局变量。这些
符号在模块 m 中任何位置都可见，但是不能被其他模块引用。   

有趣的是，定义为带有 C static 属性的局部变量时不在栈中管理的。相反，编译器在 .data 或
.bss 中为每个定义分配空间。    

> C 程序员使用 static 属性隐藏模块内部的变量和函数声明，就像你在 JAVA 和 C++ 中使用
> pubilc 和 private 声明一样。在 C 中，源文件扮演模块的角色。任何带有 static 属性声明的
> 全局变量或者函数都是模块私有的。类似地，任何不带 static 属性声明的全局变量和函数都是
> 公共的，可以被其他模块访问。    

符号表包含一个条目的数组，图 7-4 展示了每个条目的格式：    

```c
typedef struct {
  int    name;        /* String table offset */
  char   type:4,      /* Function of data (4 bits) */
         binding:4;   /* Local or global (4 bits) */
  char   reserved;    /* Unused */
  short  section;     /* Section header index */
  long   value;       /* Section offset or absolute address */
  long   size;        /* Object size in bytes */
} Elf64_Symbol;
```    

name 是字符串表中的字节偏移，指向符号的以 null 结尾的字符串名字。value 是符号的地址。
对于可重定位模块来说，value 是据定义目标的节的其实位置的偏移。对于可执行目标文件来说，该
值是一个绝对运行时地址。size 是目标的带下，type 通常要么是数据，要么是函数。符号表还可以
包含各个节的条目，以及对应原始源文件的路径名的条目。所以这些目标的类型也有所不同。binding
字段表示符号是本地的还是全局的。    

每个符号都被分配到目标文件的某个节，由 section 字段表示，该字段也是一个到节头部表的索引。
有三个特殊的伪节，条目在节头部表中时没有条目的：ABS 代表不该被重定位的符号；UNDEF 代表
未定义的符号，也就是在本目标模块中引用，但是却在其他地方定义的符号；COMMON 表示还未被分配
位置的未初始化的数据目标。对于 COMMON 符号，value 字段给出对齐要求，size 给出最小的大小。    

现代 GCC 版本根据以下规则来将可重定位目标文件中的符号分配到 COMMON 和 .bss 中：   

+ COMMON：未初始化的全局变量
+ .bss：未初始化的静态变量，以及初始化为 0 的全局或静态变量     

## 7.6 符号解析

链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号
定义关联起来。对那些和引用定义在相同模块中的局部符号的引用，符号解析是非常简单明了的。
编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要
确保它们拥有唯一的名字。    

不过，对全局符号的引用解析就棘手的多。当编译器遇到一个不是在当前模块中定义的符号（变量或
函数名）时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器
处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条错误信息并终止。    

### 7.6.1 链接器如何解析多重定义的全局符号

在编译时，编译器向汇编器输出每个全局符号，或者是 **强** 或者是 **弱**，而汇编器把这个信息
隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局
变量是弱符号。    

根据强弱符号的定义，Linux 链接器使用下面的规则来处理多重定义的符号名：   

+ 不允许有多个同名的强符号
+ 如果一个强符号和多个弱符号同名，那么选择强符号
+ 如果有多个弱符号同名，那么从这些弱符号中任意选择一个    

### 7.6.2 与静态库链接

实际上，所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为
**静态库**，它可以用作链接器的输入，当链接器构造一个输出的可执行文件时，它只复制静态库
里被应用程序引用的目标模块。    

在 Linux 系统中，静态库以一种称为 _存档_(archive) 的特殊文件格式存放在磁盘中。存档文件
是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。    

### 7.6.3 链接器如何使用静态库来解析引用

在符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位
目标文件和存档文件。在这次扫描中，链接器维护一个可重定位目标文件的集合 E，一个未解析的符号
集合 U，以及一个在前面输入文件中已定义的符号集合 D。    

+ 对于命令行上的每个输入文件 f，链接器会判断 f 是一个目标文件还是一个存档文件。如果 f 是
一个目标文件，那么链接器把 f 添加到 E，修改 U 和 D 来反映 f 中的符号定义和引用，并继续
下一个输入文件。
+ 如果 f 是一个存档文件，那么链接器就尝试匹配 U 中未解析的符号和由存档文件成员定义的符号。
如果某个存档文件成员 m，定义了一个符号来解析 U 中的一个引用，那么就将 m 加到 E 中，并且
链接器修改 U 和 D 来反映 m 中的符号定义和引用。此时，任何不包含在 E 中的成员目标文件都
简单地被丢弃，而链接器将继续处理下一个输入文件。    
+ 如果当链接器完成对命令行上输入文件的扫描后，U 是非空的，那么链接器就会输出一个错误并
终止。否则，它会合并和重定位 E 中的目标文件，构建输出的可执行文件。    

## 7.7 重定位

一旦链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义关联起来。此时，
链接器就知道它的输入目标模块中的代码节和数据节的确切大小。现在就可以开始重定位步骤了，在
这个步骤中，将合并输入模块，并为每个符号分配运行时地址。重定位由两步组成：    

+ **重定位节和符号定义**。在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。
例如，来自所有输入模块的 .data 节被全部合并成一个节，这个节成为输出的可执行目标文件的 .data
节。然后链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块
定义的每个符号。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址。
+ **重定位节中符号引用**。在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得
它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为 **重定位条目**
的数据结构。     

### 7.7.1 重定位条目

无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个 **重定位条目**，告诉链接器在
将目标文件合并成可执行文件时如何修改这个引用。代码的重定位条目放在 .rel.text 中。已初始化
数据的重定位条目放在 .rel.data 中。    

图 7-9 展示了 ELF 重定位条目的格式。offset 是需要被修改的引用的节偏移。symbol 标识被修改
引用应该指向的符号。type 告知链接器如何修改新的引用。addend 是一个有符号常数，一些类型
的重定位要使用它对被修改引用的值做偏移调整。    

```c
typedef struct {
  long  offset;    /* Offset of the reference to relocate */
  long  type: 32,  /* Relocation type */
        symbol:32; /* Symbol table index */
  long  addend;    /* Constant part of relocation expression */
} Elf64_Rela;
```     

ELF 定义了 32 种不同的重定位类型，有些相当神秘。我只关系其中两种最基本的重定位类型：   

+ R_X86_64_PC32。重定位一个使用 32 位 PC 相对地址的引用。
+ R_X86_64_32。重定位一个使用 32 位绝对地址的引用。通过绝对寻址，CPU 直接使用在指令中
编码的 32 位值作为有效地址。    

### 7.7.2 重定位符号引用

图 7-10 展示了链接器的重定位算法的伪代码。第一行和第二行在每个节 s 以及与每个节相关联的
重定位条目 r 上迭代执行。假设每个节 s 是一个字节数组，每个重定位条目 r 是一个类型为
Elf64_Rela 的结构。另外，还假设当算法运行时，链接器已经为每个节和每个符号都选择了运行时
地址。第 3 行计算的是需要被重定位的 4 字节引用的数组 s 中的地址。    

![relocation-algorithm](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/relocation-algorithm.png)    

让我们来看看链接器如何用这个算法来重定位 7.1 节中程序的引用：    

```
<main>:
0:   48 83 ec 08                sub $0x8, %rsp
4:   be 02 00 00 00             mov $0x2, %esi
9:   bf 00 00 00 00             mov $0x0, %edi   // %edi = &array
                    a: R_X86_64_32 array         // Relocation entry
e:   e8 00 00 00 00             callq 13 <main+0x13>   // sum
                    f: R_X86_64_PC32 sum-0x4      // Relocation entry
13:  48 83 c4 08                add $0x8, %rsp
17:  c3                         retq
```    

main 函数引用了两个全局符号：array 和 sum。为每个引用，汇编器产生一个重定位条目，显示在
引用的后面一行上。     

1. **重定位 PC 相对引用**   

call 指令开始于节偏移 0xe 的地方，包括 1 字节的操作码 0xe8，后面跟着是对目标 sum 的 32
位PC 相对引用的占位符。    

相应的重定位条目 r 由 4 个字段组成：   

```c
r.offset = 0xf;
r.symbol = sum;
r.type = R_X86_64_PC32;
r.addend = -4;
```    

这些字段告诉链接器修改开始于偏移量 0xf 处的 32 位 PC 相对引用，这样在运行时它会指向 sum
例程。现在，假设链接器已经确定：   

`ADDR(s) = ADDR(.text) = 0x4004d0`    

和 `ADDR(r.symbol) = ADDR(sum) = 0x4004e8`    

使用图 7-10 中的算法，链接器首先计算出引用的运行时地址：   

```
refaddr = ADDR(s) + r.offset
        = 0x4004d0 + 0xf
        = 0x4004df
```   

然后，更新该引用，使得它在运行时指向 sum 程序：   

```
*refptr = (unsigned) (ADDR(r.symbol) + r.addend - refaddr)
        = (unsigned) (0x4004e8 + (-4) - 0x4004df)
        = (unsigned) (0x5)
```    

在得到的可执行目标文件中，call 指令有如下的重定位的形式：   

`4004de: e8 05 00 00 00    callq 4004e8`    

当 CPU 执行 call 指令时，PC 的值为 0x4004e3，即紧随在 call 指令之后的指令的地址。为了
执行这条指令，CPU 执行以下的步骤：   

1. 将 PC 压入栈中
2. PC ← PC + 0x5 = 0x4004e8    

这里的 -4 其实好像的意思是 32 位地址是 4 个字节。   

2. **重定位绝对引用**   

mov 指令将 array 地址复制到寄存器 %edi 中。mov 指令开始于节偏移量 0x9 的位置，包括
1 字节操作码 0xbf，后面跟着对 array 的 32 位绝对引用的占位符。   

对应的占位符条目 r 包含 4 个字段：   

```
r.offset = 0xa
r.symbol = array
r.type = R_X86_64_32
r.addend = 4
```    

这些字段告诉链接器要修改从偏移量 0xa 开始的绝对引用，这样在运行时它会指向 array 的第一个
字节。现在，假设链接器已经确定：   

`ADDR(r.symbol) = ADDR(array) = 0x601018`   

链接器使用算法修改了引用：   

```
*refptr = (unsigned) (ADDR(r.symbol) + r.addend)
        = (unsigned) (0x601018 + 0)
        = (unsigned) (0x601018)
```    

## 7.8 可执行目标文件

图 7-13 概括了一个典型的 ELF 可执行文件中的各类信息。    

![elf-executable](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/elf-executable.png)    

ELF 可执行文件被设计得很容易加载到内存，可执行文件的连续的片被映射到连续的内存段。程序
头部表描述了这种映射关系。    

## 7.9 加载可执行目标文件

任何 Linux 程序都可以通过调用 execve 函数来调用加载器。加载器将可执行目标文件中的代码和
数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个将程序
复制到内存并运行的过程叫做加载。    

每个 Linux 程序都有一个运行时内存映像，类似于图 7-15 中所示。在 Linux x86-64 中，代码
段总是从地址 0x400000 处开始，后面是数据段。运行时堆在数据段之后，通过调用 malloc 库
向上增长。堆后面的区域是为共享模块保留的。用户栈总是从最大合法用户地址(2<sup>48</sup> - 1)
开始，向较小内存增长。栈以上的区域，是为内核中的代码和数据保留的。    

![program-memory](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/program-memory.png)    

实际上，由于 .data 段有对齐要求，所以代码段和数据段之间是由间隙的。同时，在分配栈、共享
库和堆段运行时地址的时候，链接器还会使用地址空间布局随机化。虽然每次程序运行时这些区域的
地址都会改变，它们的相对位置不变。    

## 7.10 动态链接共享库

共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的重新链接
起来。这个过程称为 **动态链接**，是由一个叫做 **动态链接器** 的程序来执行的。共享库也
称为 **共享目标**，在 Linux 中通常用 .so 后缀来表示。    

共享库是以两种不同的方式来“共享”的。首先，在任何给定的文件系统中，对于一个库只有一个 .so
文件。所有引用该库的可执行目标文件共享这个 .so 文件中的代码和数据，而不是像静态库的内容
那样被复制和嵌入到引用它们的可执行的文件中。其次，在内存中，一个共享库的 .text 节的一个
副本可以被不同的正在运行的进行共享。   

![dynamic-library](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/dynamic-library.png)    

为了构造共享库 libvector.so，我们调用编译器驱动程序，给编译器和链接器如下特殊指令：   

`linux> gcc -shared -fpic -o libvector.so addvec.c multvec.c`    

-fpic 选项指示编译器生成与位置无关的代码，-shared 选项指示链接器创建一个共享的目标文件。
一旦创建了这个库，随后就要将它链接到程序中：    

`linux> gcc -o prog21 main2.c ./libvector.so`    

这样就创建了一个可执行目标文件 prog21，而此文件的形式使得它在运行时可以和 libvector.so
链接。基本的思路是当创建可执行文件时，静态执行一些链接，然后在程序加载时，动态完成链接过程。
此时，没有任何 libvector.so 的代码和数据节真的被复制到可执行文件 prog21 中。反之，链接器
复制了一些重定位和符号表信息，它们使得运行时可以解析对 libvector.so 中代码和数据的引用。    

当加载器加载和运行可执行文件 prog21 时，它利用 7.9 节讨论过的技术，加载部分链接的可执行
文件 prog21。接着，它注意到 prog21 包含一个 .interp 节，这一节包含动态链接器的路径名，
动态链接器本身就是一个共享目标。加载器不会像它通常所做地那样将控制传递给应用，而是加载和
运行这个动态链接器。然后，动态链接器通过执行下面的重定位完成链接任务：   

+ 重定位 libc.so 的文本和数据到某个内存段
+ 重定位 libvector.so 的文本和数据到另一个内存段
+ 重定位 prog21 中所有对由 libc.so 和 libvector.so 定义的符号的引用    

最后，动态链接器将控制传递给应用程序。从这个时刻开始，共享库的位置就固定了，并且在程序执行
的过程中都不会改变。   

## 7.11 从应用程序中加载和链接共享库

上一节我们讨论了应用程序被加载后执行前时，动态链接器加载和链接共享库的情景。然而，应用程序
还可能在它运行时要求动态链接器加载和链接某个共享库，而无需在编译时将那些库链接到应用中。    

## 7.12 位置无关代码

现代系统以这样一种方式编译共享模块的代码块，使得可以把它们加载到内存的任何位置而无需链接器
修改。      

可以加载而无需重定位的代码称为 **位置无关代码**(Position-Independent Code, PIC)。用户
对 GCC 使用 -fpic 选项指示 GNU 编译系统生成 PIC 代码。    

