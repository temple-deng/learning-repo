# 操作系统还原

<!-- TOC -->

- [操作系统还原](#操作系统还原)
- [第 0 章 一些你可能正感到迷惑的问题](#第-0-章-一些你可能正感到迷惑的问题)
  - [0.4 软件是如何访问硬件的](#04-软件是如何访问硬件的)
  - [0.5 应用程序是什么](#05-应用程序是什么)
  - [0.8 代码中为什么分为代码段，数据段](#08-代码中为什么分为代码段数据段)
  - [0.9 物理地址、逻辑地址、有效地址、线性地址、虚拟地址](#09-物理地址逻辑地址有效地址线性地址虚拟地址)
  - [0.19 大端序，小端序](#019-大端序小端序)
  - [0.20 BIOS 中断、Linux 中断的区别](#020-bios-中断linux-中断的区别)
  - [0.21 Section 和 Segment 的区别](#021-section-和-segment-的区别)
  - [0.24 如何控制 CPU 的下一条指令](#024-如何控制-cpu-的下一条指令)
  - [0.25 指令集、体系结构、微架构](#025-指令集体系结构微架构)
  - [0.26 库函数是用户进程和内核的桥梁](#026-库函数是用户进程和内核的桥梁)
  - [0.28 MBR、EBR、DBR 和 OBR 各是什么](#028-mbrebrdbr-和-obr-各是什么)
- [第 1 章 部署环境](#第-1-章-部署环境)
  - [1.3 安装 bochs](#13-安装-bochs)
- [第 2 章 编写 MBR 主引导记录](#第-2-章-编写-mbr-主引导记录)
  - [2.1 计算机的启动过程](#21-计算机的启动过程)
  - [2.2 软件接力第一棒：BIOS](#22-软件接力第一棒bios)
    - [2.2.1 实模式下的 1MB 内存布局](#221-实模式下的-1mb-内存布局)
    - [2.2.2 BIOS 是如何苏醒的](#222-bios-是如何苏醒的)
    - [2.2.3 为什么是 0x7c00](#223-为什么是-0x7c00)
  - [2.3 让 MBR 先飞一会儿](#23-让-mbr-先飞一会儿)
    - [2.3.1 神奇好用的 $ 和 $$，令人疑惑的 section](#231-神奇好用的--和-令人疑惑的-section)
    - [2.3.2 NASM 的简单用法](#232-nasm-的简单用法)
    - [2.3.3 MBR](#233-mbr)

<!-- /TOC -->

# 第 0 章 一些你可能正感到迷惑的问题

## 0.4 软件是如何访问硬件的

硬件在输入输出上大体分为串行和并行，相应的接口也就是串行接口和并行接口。    

访问外部硬件有两个方式：   

1. 将某个外设的内存映射到一定范围的地址空间内，CPU 通过地址总线访问该内存区域时会落到
外设的内存中，这种映射让 CPU 访问外设的内存就如同访问主板上的物理内存一样。
2. 外设是通过 IO 接口与 CPU 通信的，CPU 访问外设，就是访问 IO 接口，由 IO 接口将信息
传递给另一端的外设。    

## 0.5 应用程序是什么

应用程序要用某种语言编写，而语言又是编译器来提供的。其实根本就没有什么语言，有的只是
编译器。是编译器决定怎样解释某种关键字及某种语法。语言只是编译器和大家的约定，只要写入
这样的代码，编译器便将其翻译成某种机器指令，翻译成什么样取决于编译器的行为，和语言无关。   

编译器提供了一套库函数，库函数中又有封装的系统调用，这样的代码集合称之为运行库。C 语言的
运行库称为 C 运行库，就是所谓的 CRT(C Runtime Library)。    

用户态与内核态是对 CPU 来讲的，是指 CPU 运行在用户态（特权 3 级）还是内核态（特权 0 级），
很多人误以为是对用户进程来讲的。    

用户进程陷入内核态是指：由于内部或外部中断发生，当前进程被暂时终止执行，其上下文本内核的
中断程序保存起来后，开始执行一段内核的代码。是内核的代码，不是用户程序在内核的代码，用户
代码怎么可能在内存中存在，所以 “用户态和内核态” 是对 CPU 来说的。    

## 0.8 代码中为什么分为代码段，数据段

将数据和代码分开的好处有三点。   

第一，可以为它们赋予不同的属性。    

例如数据本身是需要修改的，所以数据就需要有可写的属性。程序中的代码是不能修改的，这样就
要求代码段具备只读的属性，真要是在运行过程中程序的下一条执行被随意修改，谁知道会产生
什么样的灾难。    

第二，为了提高 CPU 内部缓存的命中率。    

缓存起作用的原因是程序的局部性原理。在 CPU 内部也有缓存机制，将程序中的指令和数据分离，
这有利于增强程序的局部性。CPU 内部有针对数据和针对指令的两种缓存机制，因此，将数据和代码
分开存储将使程序运行得更快。    

第三，节省内存。    

程序中存在一些只读的部分，比如代码，将一个程序的多个副本同时运行时，没必要在内存中同时
存在多个相同的代码段，这将浪费有限的物理内存资源，只要将这一个代码段共享就可以了。     

在保护模式下，有这样的一个数据，它叫全局描述符表（Global Descriptor Table, GDT），这个
表中的每一项称为 **段描述符**。在段描述符中有段的属性位。    

操作系统在让 CPU 进入保护模式之前，首先要准备好 GDT，也就是要设置好 GDT 的相关项，填写
好段描述符。    

## 0.9 物理地址、逻辑地址、有效地址、线性地址、虚拟地址

物理地址就是物理内存真正的地址，相当于内存中每个存储单元的门牌号，具有唯一性。不管在什么
模式下，不管什么虚拟地址、线性地址，CPU 最终都要以物理地址去访问内存，只有物理地址才是
内存访问的终点站。    

在实模式下，“段基址 + 段内偏移地址” 经过段部件的处理，直接输出的就是物理地址，CPU 可以
直接用此地址访问内存。    

而在保护模式下，“段基址 + 段内偏移地址”称为 **线性地址**，不过，此时的段基址已经不再是
真正的地址了，而是一个称为选择子。它本质上是个索引，类似于数组下标，通过这个索引便能
在 GDT 中找到相应的段描述符，在该描述符中记录了该段的起始、大小等信息，这样便得到了
段基址。若没有开启地址分页功能，此线性地址就被当做物理地址来用，可直接访问内存。若开启
可分页功能，此线性地址又多了一个名字，就是虚拟地址（虚拟地址、线性地址在分页机制下都是
一回事）。虚拟地址要经过 CPU 页部件转换成具体的物理地址，这样 CPU 才能将其送上地址总线
去访问内存。     

无论在实模式还是保护模式下，段内偏移地址又称为有效地址，也称为逻辑地址。    

![0-5-address](https://raw.githubusercontent.com/temple-deng/markdown-images/master/system/0-5-address.png)    

## 0.19 大端序，小端序

1. 小端字节序是数值的低字节放在内存的低地址处，数值的高字节放在内存的高地址
2. 大端字节序是数值的低字节放在内存的高地址处，数值的高字节放在内存的低地址    

看看这两种字节序的优势：   

1. 小端：因为低位在低字节，强制转换数据类型时不需要再调整字节了。
2. 大端：有符号数，其字节最高位不仅表示数值本身，还起到了符号的作用。符号位固定为第一
字节，也就是最高位占据最低地址，符号直接可以取出来，容易判断正负。    

网络字节序就是大端字节序，所以在 x86 架构上的程序在发送网络数据时，要转换字节顺序。   

## 0.20 BIOS 中断、Linux 中断的区别

BIOS 和 DOS 都是存在于实模式下的程序，由它们建立的中断调用都是建立在中断向量表（Interrupt
Vector Table, IVT）中的。它们都是通过软中断指令 `int 中断号` 来调用的。   

注意其实这里说了，BIOS 也是普通的程序，它们自然可以访问内存，使用 CPU 执行机器指令。    

中断向量表中的每个中断向量大小是 4 字节。这 4 字节描述了一个中断处理例程的段基址和段内
偏移地址。因为中断向量表的长度是 1024 字节，故该表最多容纳 256 个中断向量处理程序。计算机
启动之初，中断向量表中的中断例程是由 BIOS 建立的，它从物理内存地址 0x0000 处初始化并在
中断向量表中添加各种处理例程。    

每个外设，包括显卡、键盘、各种控制器等，都有自己的内存（主板也有自己的内存，BIOS 就存放在
里面），不过这种内存都是只读存储器 ROM。硬件自己的功能调用例程及初始化代码就存放在这 ROM
中。根据规范，第 1 个内存单元的内容是 0x55，第 2 个存储单元是 0xAA，第 3 个存储单元是该
ROM 中以 512 字节为单位的代码长度。从第 4 个存储单元起就是实际代码了，直到第 3 个存储单元
所示的长度为止。    

从内存地址 0xA0000 开始到 0xFFFFF 这部分内存中，一部分是专门用来做映射的，如果硬件存在，
硬件自己的 ROM 会被映射到这片内存中的某处。    

BIOS 在运行期间会扫描 0xC0000 到 0xE0000 之间的内存，若在某个区域发现前两个字节是 0x55
和 0xAA 时，意味着该区域对应的 ROM 中有代码存在，在对该区域做累加和检查，若结果与第 3 个
字节的值相符，说明代码无误，就从第 4 个字节进入。这时开始执行硬件自带的累成以初始化硬件自身，
最后，BIOS 填写中断向量表中相关项，使他们指向硬件自带的例程。    

Linux 内核是在进入保护模式后才建立中断例程的，不过在保护模式下，中断向量表已经不存在了，
取而代之的是中断描述符表（Interrupe Descriptor Table, IDT）。该表与中断向量表的区别会
在讲解中断时详细介绍。所以在 Linux 下执行的中断调用，访问的中断例程是在中断描述符表中，
已不在中断向量表中。    

Linux 系统调用时通过 `int 0x80` 指令进入一个中断程序后再根据 eax 寄存器的值来调用不同的
子功能函数的。     

## 0.21 Section 和 Segment 的区别

在汇编源码中，通常用语法关键字 section 或 segment 来表示一段区域，它们是编译器提供的
伪指令，作用是相同的，都是在程序中 “逻辑地” 规划一段区域，此区域便是节。链接器将目标文件
中属性相同的节合并成一个大的 section 集合，此集合便成为 segment，也就是段，此段便是
我们平时所说的可执行程序内存空间中的代码段和数据段。      

## 0.24 如何控制 CPU 的下一条指令

在 x86 体系结构的 CPU 中，也就是 INTEL 或 AMD 公司的桌面处理器，程序计数器 PC 并不是
单一的某种寄存器，它是一种寄存器的组合，指的是段寄存器 CS 和指令指针寄存器 IP。   

假设我们的指令格式最大支持三个寄存器参数和一个立即数参数。其中操作码和各寄存器操作数各占
1 字节，立即数部分占 4 字节。各条指令并不是完全按照此格式填充，不同的指令有不同参数，只有
操作码部分是固定的，其他操作数部分是可选的。当 CPU 在译码阶段识别出操作码后，CPU 自然
知道该指令需要什么样的操作数，这是写死在硬件电路中的，所以不同的指令其机器码长度很可能
不一致。    

## 0.25 指令集、体系结构、微架构

指令集是一套约定，里面规定的是有哪些指令、指令的二进制编码、指令格式等，如何实现这套约定，
是硬件自己的事情。在 Inter 的 CPU 上运行的软件也能够在 AMD 的 CPU 上运行，原因就是他们
共用了一套指令集，也就是对二进制编码达成了共识。它们各自实现的方式，就叫微架构。    

总结一下，指令集是具体的一套指令编码，微架构是指令集的物理实现方式。    

## 0.26 库函数是用户进程和内核的桥梁

头文件中一般仅仅有函数声明，这个声明告诉编译器至少两件事：   

1. 函数返回值类型、参数类型及个数，用来确定分配的栈空间
2. 该函数是外部函数，定义在其他文件，现在无法为其分配地址，需要在链接阶段将该函数体所在的
目标文件一同链接时再安排地址。    

## 0.28 MBR、EBR、DBR 和 OBR 各是什么

计算机在接电之后运行的是 BIOS，BISO 只完成一些简单的检测或初始化工作，然后将 CPU 使用权
交给 MBR，为了方便 BIOS 找到 MBR，MBR 必须在固定的位置等待，因此 MBR 位于整个硬盘最开始
的扇区。   

在 MBR 引导扇区中的内容是：    

1. 446 字节的引导程序及参数
2. 64 字节的分区表
3. 2 字节结束标记 0x55 和 0xAA   

BIOS 直到 MBR 在 0 盘 0 道 1 扇区，这是约定好的，因此它会将 0 盘 0 道 1 扇区中的 MBR
引导程序加载到物理地址 0x7c00，然后跳过去执行，这样 BIOS 就将控制权交给了 MBR。   

MBR 引导程序会遍历分区表，在 4 个分区中找到合适的 “次引导程序”，这个次引导程序就是操作
系统提供的加载器，但是各分区都有可能存在操作系统，MBR 也不知道操作系统在哪里。    

为了让 MBR 知道哪里有操作系统，我们在分区时，如果想在某个分区中安装操作系统，就用分区工具
将该分区设置为活动分区，设置活动分区的本质就是把分区表中该分区对应的分区表项中的活动标记
为 0x80。MBR 知道 “活动分区” 意味着该分区中存在操作系统，这也是约定好的。活动分区标记
位于分区表项最开始的 1 字节，其值要么是 0x80，要么为 0。    

为了 MBR 方便找到活动分区上的内核加载器，内核加载器的入口地址也必须在固定的位置，这个位置
就是各分区最开始的扇区，这也是约定好的。该扇区也称为操作系统引导扇区，其中的引导程序称为
操作系统引导记录 OBR，即 OS Boot Record。在 OBR 扇区的前 3 个字节存放了跳转指令，
这同样是约定。

OBR 是从 DBR 遗留下来的，DBR 是 DOS Boot Record，也就是 DOS 操作系统的引导程序，DBR
中的内容大概是：   

1. 跳转指令，使 MBR 跳转到引导代码
2. 厂商信息、DOS 版本信息
3. BIOS 参数块 BPB，即 BIOS Parameter Block
4. 操作系统引导程序
5. 结束标记 0x55, 0xAA   

在 DOS 时代只有 4 个分区，不存在扩展分区，这 4 个分区都相当于主分区，所以各主分区最开始
的扇区称为 DBR 引导扇区。后来有了扩展分区之后，无论分区是主分区，还是逻辑分区，为了兼容，
分区最开始的扇区都作为 DOS 引导扇区。   

当初为了解决分区数量限制的问题才有了扩展分区，EBR 是扩展分区中为了兼容 MBR 才提出的概念，
只要是兼容 MBR 中的分区表。为扩展分区存储分区表的扇区称为 EBR，即 Expand Boot Record。
因此它与 MBR 结构相同，只是位置不同，EBR 位于各子扩展分区中最开始的扇区（注意，各主分区
和各逻辑分区中最开始的扇区是操作系统引导扇区）。   

![mbr-obr-ebr](https://raw.githubusercontent.com/temple-deng/markdown-images/master/system/mbr-obr-ebr.png)    

# 第 1 章 部署环境

## 1.3 安装 bochs

```shell
./configure \
--prefix=/your_path/bochs \
--enable-debugger \
--enable-disasm \
--enable-iodebug \
--enable-x86-debugger \
--with-x \
--with-x11
```   

`--prefix=/your_path/bochs` 用来指定安装目录，`enable-debugger` 打开 bochs 自己的调试器。
`--enable-disasm` 使 bochs 支持反汇编。`--enable-iodebug` 启用 io 接口调试器。
`--enable-x86-debugger` 支持 x86 调试器，`--with-x` 使用 x windows，`--with-x11`
使用 x11 图形用户接口。    

然后 `make install`


# 第 2 章 编写 MBR 主引导记录

## 2.1 计算机的启动过程

操作系统在加载程序时，是需要某个加载器来讲用户程序存储到内存中的。其实 “加载器” 这只是
人为起的名字，本质上它就是一堆函数组成的模块。从按下主机上的 power 键后，第一个运行的
软件是 BIOS。于是产生了三个问题。   

1. 它是由谁加载的
2. 它被加载到哪里
3. 它的 cs:ip 是谁来更改的    

## 2.2 软件接力第一棒：BIOS

### 2.2.1 实模式下的 1MB 内存布局

Inter 8086 有 20 条地址线，故其可以访问 1MB 的内存空间，即 2 到 20 次方 = 1048576 = 1MB，
地址范围若按十六进制来表示，是 0x00000 到 0xFFFFF。     


起始 | 结束 | 大小 | 用途
---------|----------|---------|---------
 FFFF0 | FFFFF | 16B | BIOS 入口地址，此地址也属于 BIOS 代码，同样属于顶部的 64KB，只是为了强调其入口地址才单独贴出来。此处 16 字节的内容是跳转指令 `jmp f000: e05b`
 F0000 | FFFEF | 64KB-16B | 系统 BIOS 范围是 F0000-FFFFF 共 64KB，为说明入口地址，将最上面的 16 字节从此处去掉了，所以此处终止地址是 0xFFFEF
 C8000 | EFFFF | 160KB | 映射硬件适配器的 ROM 或内存映射式 IO
 C0000 | C7FFF | 32KB | 显示适配器 BIOS
 B8000 | BFFFF | 32KB | 用于文本模式显示适配器
 B0000 | B7FFF | 32KB | 用于黑白显示适配器
 A0000 | AFFFF | 64KB | 用于彩色显示适配器
 9FC00 | 9FFFF | 1KB | EBDA(Extended BIOS Data Area)扩展 BIOS 数据区
 7E00 | 9FBFF | 约 608 KB | 可用区域
 7C00 | 7DFF | 512B | MBR 被 BIOS 加载到此处，共 512 字节
 500 | 7BFF | 约 30KB | 可用区域
 400 | 4FF | 256B | BIOS Data Area(BIOS 数据区)
 000 | 3FF | 1KB | Interrupt Vector Table（中断向量表）

内存地址 0-0x9FFFF 的空间范围是 640KB，这片地址对应到了 DRAM，也就是插到主板上的内存条。    

顶部的 0xF0000-0xFFFFF，这 64KB 的内存是 ROM。这里面存的就是 BIOS 的代码。BIOS 的主要
工作是检测、初始化硬件，怎么初始化？硬件自己提供了一些初始化的功能调用，BIOS 直接调用就好了，
除此之外，BIOS 建立中断向量表，这样就可以通过 `int 中断号` 来实现相关的硬件调用，当然
BIOS 建立的这些功能就是对硬件的 IO 操作，也就是输入输出，但由于就 64 KB 大小的空间，
不可能把所有硬件的 IO 操作实现的面面俱到。   

在 CPU 眼里，为什么我们插在主板上的物理内存不是它眼里“全部的内存”。    

地址总线宽度决定了可以访问的内存空间大小，如 16 位机的地址总线为 20 位，其地址范围是 1MB，
32 位地址总线宽度是 32 位，其地址范围是 4GB。    

归根结底的原因是这样的：在计算机中，除了插在主板上的内存条需要地址总线访问，还有一些访问
同样是需要地址总线来访问，若把全部的地址总线指向物理内存，那其他设备该如何访问？基于这个原因，
只好在地址总线上提前预留出来一些地址空间给这些外设用，这片连续的地址给显存，这片连续的
地址给磁盘控制器等。留够了之后，地址总线上其余可用的地址再指向 DRAM。     

总之，表示地址的那串数字是地址总线的输入，相当于其参数，和内存条没关系，CPU 能够访问一个
地址，这是地址总线给做的映射，相当于给该地址分配了一个存储单元，而该存储单元要么落在某个
ROM 中，要么落到了某个外设的内存中，要么落到了物理内存条上。   

### 2.2.2 BIOS 是如何苏醒的

BIOS 本身是个程序，程序要执行，就要有个入口地址才行，此入口地址便是 0xFFFF0。知道了 BIOS
在哪里后，CPU 如何去执行它，即 CPU 中的 cs:ip 值是如何组合成 0xFFFF0 的。    

由于在实模式下，段地址需要乘以 16 后才能与偏移地址相加，求出的和便是物理地址，CPU 便
拿此地址直接用了。   

在开机的一瞬间，也就是接电的一瞬间，CPU 的 cs:ip 寄存器被强制初始化为 0xF000: 0xFFF0。
由于开机的时候处于实模式，再重复一遍加深印象，在实模式下的段基址要乘以 16，也就是左移
4 位，于是 0xF000: 0xFFF0 的等效地址。上面说过了，此地址便是 BIOS 的入口地址。    

### 2.2.3 为什么是 0x7c00

BIOS 最后一项工作是校验启动盘中位于 0 盘 0 道 1 扇区的内容。硬盘扇区的表示法有两种，
我们描述 0 盘 0 道 1 扇区用的便是其中的一种：CHS 方法，即柱面 Cylinder 磁道 Header
扇区 Sector（另外一种 LBA 方式），“0盘” 说的是 0 磁头，因为一张盘是有上下两个盘面的，
一个盘面对应一个磁头，所有用磁头来表示盘面。“0道” 是指 0 柱面，柱面 Cylinder 指的是所有
盘面上、编号相同的磁道的集合。在 CHS 方式中扇区的编号是从 1 开始的。   

## 2.3 让 MBR 先飞一会儿

由于我们的系统是 x86 平台，所以是小端序，故 MBR 最后两个字节内容是 0xAA55。    

### 2.3.1 神奇好用的 $ 和 $$，令人疑惑的 section

$ 和 $$ 是编译器 NASM 预留的关键字，用来表示当前行和本 section 的地址，起到了标号的作用，
它是 NASM 提供的，并不是 CPU 原生支持的。    

汇编语言中的标号是程序员 “显式地” 写在明处的，如：   

```
...
code_start:
    mov ax, 0
```    

code_start 这个标号被 NASM 认为是一个地址，此地址便是 `mov ax, 0` 这条指令所在的地址，
即其指令机器码存放的内存位置是 code_start。code_start 只是个标记，CPU 并不认识，和伪
指令类似，它是假的，CPU 不认。所以 NASM 会用其安排的地址来替换标号 code_start，到了
CPU 手中，已经被替换为有意义的数字形式的地址。    

$ 属于 “隐式地” 藏在本行代码前的标号，也就是编译器给当前行安排的地址，看不到却又无处不在。
如果上面的例子改为：   

```
...
code_start:
    jmp $
...
```   

这就和 `jmp code_start` 是等效的。$ 和 code_start 是同一个值。    

$$ 指代本 section 的起始地址，此地址同样是编译器给安排的。   

$ 和 $$ 默认情况下，它们的值是相对于本文件开头的偏移量。至于实际安排的是多少，还要看我们
是否在 section 中添加了 vstart。这个关键字可以影响编译器安排地址的行为，如果该 section
用了 vstart=xxxx 修饰，$$ 的值则是此 section 的虚拟起始地址 xxxx。$ 的值是以 xxxx 为
起始地址的顺延。如果使用了 vstart 关键字，想获得本 section 在文件中的真实偏移量（真实地址）
该怎么做？NASM 编译器提供了这个方法。    

section.节名.start。    

如果没有定义 section，NASM 默认全部代码同为一个 section，起始地址为 0。   

### 2.3.2 NASM 的简单用法

```
nasm -f <format> <filename> [-o <output>]
```    

bin 是默认输出格式。   

### 2.3.3 MBR

注意这里的汇编代码好像都是 Inter 格式的。以 MOV 为例，就是 `mov D, S`。        

代码2-1(c2/a/boot/mbr.S)    

```asm
;主引导程序
;-----------------------------------------------------------------
SECTION MBR vstart=0x7c00
    mov ax, cs
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov fs, ax
    mov sp, 0x7c00

; 清屏利用 0x60 号功能，上卷全部行，则可清屏
;------------------------------------------------------------------
;INT 0x10    功能号: 0x06     功能描述: 上卷窗口
;输入:
;AH 功能号= 0x60
;AL = 上卷的行数(如果为0, 表示全部)
;BH = 上卷行属性
; (CL, CH) = 窗口左上角的 (X,Y) 位置
; (DL, DH) = 窗口右下角的 (X,Y) 位置
; 无返回值:
    mov ax, 0x600
    mov bx, 0x700
    mov cx, 0           ; 左上角: (0, 0)
    mov dx, 0x184f      ; 右下角: (80, 25),
                        ; VGA 文本模式中, 一行只能容纳 80 个字符, 共 25 行
                        ; 下标从 0 开始, 所以 0x18=24, 0x4f=79
    int 0x10            ; int 0x10

;;;;;;;;;;;;;;; 下面这三行代码获取光标位置    ;;;;;;;;;;;;;
; .get_cursor 获取当前光标位置, 在光标位置出打印字符
    mov ah, 3           ; 输入: 3 号子功能是获取光标位置，需要存入 ah 寄存器
    mov bh, 0           ; bh 寄存器存储的是待获取光标的页号

    int 0x10            ; 输出: ch=光标开始行, cl=光标结束行
                        ; dh=光标所在行号, dl=光标所在列号

;;;;;;;;;;;;;; 获取光标位置结束 ;;;;;;;;;

;;;;;;;;;;;;;; 打印字符串 ;;;;;;;;;;;;;;;
    ; 还是用 10h 中断, 不过这次调用 13 号子功能打印字符串
    mov ax, message
    mov bp, ax              ; es:bp 为串首地址, es 此时与 cs 一致
                            ; 开头时已经为 sreg 初始化

    ; 光标位置要用到 dx 寄存器中内容, cx 中的光标位置可忽略
    mov cx, 5               ; cx 为串长度, 不包括结束符 0 的字符个数
    mov ax, 0x1301          ; 子功能号 13 显示字符及属性, 要存入 ah 寄存器
                            ; al 设置写字符方式 ah = 01: 显示字符串, 光标跟随移动
    mov bx, 0x2             ; bh 存储要显示的页号, 此处是第 0 页
                            ; bl 中时字符属性, 属性黑底绿字
    int 0x10                ; 执行 BIOS 0x10 号中断
;;;;;;;;;;;;;; 打印字符串结束 ;;;;;;;;;

    jmp $                   ; 使程序悬停在此

    message db "1 MBR"
    times 510-($-$$) db 0
    db 0x55,0xaa
```    

0x10 中断是最为强大的 BIOS 中断了，调用的方法是把功能号送入 ah 寄存器，其他参数按照
BIOS 中断手册的要求放在适当的寄存器中，随后执行 `int 0x10` 即可。    

第 3 行的 `vstart=0x7c00` 表示本程序在编译时，告诉编译器，把我的起始地址编译为 0x7c00。    

第 4-8 行是用 cs 寄存器的值去初始化其他寄存器，由于 BIOS 是通过 `jmp 0: 0x7c00` 跳转
到 MBR 的，故此时 cs 为 0。对于 ds, es, fs,gs 这类 sreg，CPU 不能直接给他们赋值，没有
从立即数到段寄存器的电路实现，只能通过其他寄存器来中转，这里我们用的是通用寄存器 ax 来
中转。     

第 9 行是初始化栈指针，在 CPU 上运行的程序得遵从 CPU 的规则，MBR 也是程序，是程序就要
用到栈。目前 0x7cc 以下暂时是安全的区域，就把它当作栈来用。    

第 11-28 行是清屏。因为在 BIOS 工作中，会有一些输出，如检测硬件的结果信息。为了让大家看
清楚我们在 MBR 中的输出字符串，故先把 BIOS 的输出清掉。    

第 30-35 行是做打印前的工作，先获取光标位置，目的是避免打印字符混乱，覆盖别人的输出。   

第 55 行执行了死循环，$ 是本行指令的地址，这属于伪指令，是汇编器在编译期间分配的地址。
`jmp` 是个近跳转，$ 是 `jmp` 自己的地址，于是跳到自己所在的地址再执行自己，于是跳到自己
所在的地址再继续执行跳转，这样便实现了死循环。     

第 57 行是定义打印的字符串。   

第 58 行的 $$ 是本 section 的起始地址，故 $-$$ 是本行到本 section 的偏移量。本扇区内
前 512-2=510 字节要填满，用 510 字节减去上面通过 $-$$ 得到的偏移量，其结果便是本扇区
内的剩余量，也就是要填充的字节数。`times 510-($-$$) db 0` 是在用 0 将本扇区剩余空间填充。    

Last Update: 2018.11.22
