# 第 4 章 保护模式入门

<!-- TOC -->

- [第 4 章 保护模式入门](#第-4-章-保护模式入门)
  - [4.1 保护模式概述](#41-保护模式概述)
    - [4.1.1 为什么要有保护模式](#411-为什么要有保护模式)
    - [4.1.2 实模式不是 32 位 CPU，变成了 16 位](#412-实模式不是-32-位-cpu变成了-16-位)
  - [4.2 初见保护模式](#42-初见保护模式)
    - [4.2.1 保护模式之寄存器扩展](#421-保护模式之寄存器扩展)
    - [4.2.2 保护模式之寻址扩展](#422-保护模式之寻址扩展)
  - [4.3 全局描述符表](#43-全局描述符表)
    - [4.3.1 段描述符](#431-段描述符)
    - [4.3.2 全局描述符表 GDT、局部描述符表 LDT 及选择子](#432-全局描述符表-gdt局部描述符表-ldt-及选择子)
    - [4.3.4 保护模式的开发，CRO 寄存器的 PE 位](#434-保护模式的开发cro-寄存器的-pe-位)
  - [4.4 处理器微架构简介](#44-处理器微架构简介)
    - [4.4.1 流水线](#441-流水线)
    - [4.4.2 乱序执行](#442-乱序执行)
  - [4.6 保护模式之内存段的保护](#46-保护模式之内存段的保护)
    - [4.6.1 向段寄存器加载选择子时的保护](#461-向段寄存器加载选择子时的保护)
    - [4.6.2 代码段和数据段的包含](#462-代码段和数据段的包含)
- [第 5 章 保护模式进阶，向内核迈进](#第-5-章-保护模式进阶向内核迈进)
  - [5.2 启用内存分页机制](#52-启用内存分页机制)
    - [5.2.2 一级页表](#522-一级页表)
    - [5.2.3 二级页表](#523-二级页表)
  - [5.4 特权级深入浅出](#54-特权级深入浅出)
    - [5.4.1 特权级](#541-特权级)
    - [5.4.2 TSS 简介](#542-tss-简介)
    - [5.4.3 CPL 和 DPL](#543-cpl-和-dpl)
    - [5.4.4 门、调用门与 RPL 序](#544-门调用门与-rpl-序)
    - [5.4.6 RPL](#546-rpl)

<!-- /TOC -->

## 4.1 保护模式概述

### 4.1.1 为什么要有保护模式

1. 实模式下操作系统和用户程序属于同一个特权级
2. 用户程序所引用的地址都是指向真实的物理地址
3. 用户程序可以自由地修改段基址    
4. 访问超过 64KB 的内存区域时要切换段基址
5. 一次只能运行一个程序
6. 共 20 条地址线，最大可用内存为 1MB

### 4.1.2 实模式不是 32 位 CPU，变成了 16 位

32 位 CPU 具有保护模式和实模式两种运行模式，可以兼容实模式下的程序，兼容实模式，是指能够
正确处理好实模式下的程序，并不是说在实模式下运行时就完全变成了纯 16 位的 CPU。    

## 4.2 初见保护模式

### 4.2.1 保护模式之寄存器扩展

CPU 发展到 32 位后，地址总线和数据总线也发展到 32 位，其寻址空间达到了 2 的 32 次方，4GB。   

除段寄存器外，通用寄存器、指令指针寄存器、标志寄存器都由原来的 16 位扩展到了 32 位。   

偏移地址还和实模式下的一样，但段基址可不是简单的一个地址的事了，为了更加安全，需要添加
额外的约束条件，这些约束条件便是对内存段的描述信息。由于信息太多了，用一个寄存器保存不下，
所以使用额外的数据结构 —— **全局描述符表**，表中每一个表项称为 **段描述符**，其大小为 64 位，
用来描述各个内存段的起始地址、大小、权限等信息。该全局描述符表很大，所以放在了内存中，由 GDTR
寄存器指向它就行。    

这样，段寄存器中保存的再也不是段基址了，里面保存的内容叫 **选择子**，用这个选择子来索引 GDT
中的段描述符。    

由于访问内存中的段描述符是一个及其耗费时间的操作，在保护模式中，为了提高获取段信息的效率，
对段寄存器使用了缓存技术，将段信息用一个寄存器来缓存，这就是 **段描述符缓冲寄存器**
(Descriptor Cache Registers)。对程序员而言是不可见的。CPU 每次将获取到的段信息，整理
成可用的形式后，存入段描述符缓冲寄存器，以后每次访问相同的段时，就直接读取该段寄存器对应
的描述符缓冲寄存器。    

此时的 32 位 CPU 有三种模式：实模式（开机的时候）、虚拟8086模式（兼容实模式程序）、保护模式。    

### 4.2.2 保护模式之寻址扩展

在保护模式下的内存寻址中，基址寄存器不再只是 bx, bp，而是所有 32 位的通用寄存器，变址
寄存器也是一样，不再只是 si, di，而是除 esp 之外的所有 32 位通用寄存器，偏移量由实模式
的16 位变成了 32 位，并且，还可以对变址寄存器乘以一个比例因子。    

## 4.3 全局描述符表

### 4.3.1 段描述符

该结构是 8 字节大小。    

![segment-descriptor](https://raw.githubusercontent.com/temple-deng/markdown-images/master/system/segment-descriptor.png)    

段界限表示段边界的扩展最值，即最大扩展到多少或最小扩展到多少。扩展方向只有上下两种。对于
数据段和代码段，段的扩展方向是向上，即地址越来越高，此时的段界限用来表示段内偏移的最大值。
对于栈段，段的扩展方向向下，即地址越来越低，此时的段界限用来表示段内偏移的最小值。段界限
用 20 个二进制位来表示。只不过此段界限只是个单位量，它的单位要么是字节，要么是 4KB，这是
由描述符中的 G 位来指定的。故段的大小要么是 1MB，要么是 4GB。    

如果 G 位为 0，表示段界限粒度大小为 1 字节。   

段描述符低 32 位的前 16 位用来存储段界限的前 0-15 位，后 16 位用来存储段基址的 0-15 位。   

高 32 位 0-7 位是段基址的 16-23,24-31 位是段基址的 24-31 位。    

8-11 位是 TYPE 字段共 4 位，用来指定本描述符的类型。一个段描述符，在 CPU 眼里分为两大类，
要么描述的是 **系统段**，要么描述的是 **数据段**，这是由 S 位决定的，用它指示是否是系统段。在 CPU
眼里，凡是硬件运行需要用到的东西都可称之为系统，凡是软件（操作系统也属于软件，CPU 眼里，它
与用户程序无区别）需要的东西都称为数据，无论是代码，还是数据还是栈，它们都作为硬件的输入，
都是给硬件的数据，所以代码段在段描述符中也属于段。S 为 0 时表示系统段。TYPE 字段要和 S
字段配合在一起才能确定段描述符的确切类型。   

什么是系统段？各种称为 “门” 的结构便是系统段，也就是硬件系统需要的结构，如调用门、任务门。
简而言之，门的意思就是入口，它通往一段程序。   

![type](https://raw.githubusercontent.com/temple-deng/markdown-images/master/system/type.png)    

表中的 A 位表示 Accessed 位，这是由 CPU 来设置的，每当该段被 CPU 访问过后，CPU 就将此
置 1。所以，创建一个新段描述符时，应该将此位置 0.   

C 表示一致性代码段，也称依从代码段，Conforming。一致性代码段是指如果自己是转移的目标段，
并且自己是一致性代码段，自己的特权级一定要高于当前特权级，转移后的特权级不与自己的 DPL
为主，而是与转移前的低特权级一致，也就是听从、依从转移前的低特权级。C 为 1 时表示该段
是一致性代码段。       

R 表示可读。X 表示可执行。E 用来标志段的扩展方向，E 为 0 表示向上扩展。 W 表示是否可写。   

段描述符的第 13-14 位是 DPL 字段。Descriptor Privilege Level，即描述符的特权级。   

第 15 位是 P 字段，Present 即段是否存在。如果段存在于内存中，P 为 1，否则 P 为 0。   

第 21 位为 L 字段，用来设置是否是 64 位代码段，L 为 1 表示 64 位代码段。   

第 22 位是 D/B 字段，用来指示有效地址（段内偏移地址）及操作数的大小。   

对于代码段来说，此位是 D 位，若 D 为 0，表示指令中的有效地址和操作数都是 16 位。    

对于栈段来说，此位是 B 位，用来指定操作数的大小，此操作数涉及到栈指针寄存器的选择及栈的
地址上限。   

### 4.3.2 全局描述符表 GDT、局部描述符表 LDT 及选择子

全局体现在多个程序都可以在里面定义自己的段描述符，是公用的。GDTR 是个 48 位的寄存器。    

![gdtr](https://raw.githubusercontent.com/temple-deng/markdown-images/master/system/gdtr.png)    

有专门的指令用来对 GDTR 进行初始化，即 lgdt。`lgdt 48位内存数据`。    

这 48 位内存数据划分为两部分，其实前 16 位是 GDT 以字节为单位的界限值，所以这 16 位相当于
GDT 的字节大小减 1。后 32 位是 GDT 的起始地址。由于 GDT 的大小是 16 位二进制，其表示的
范围是 65536 字节。每个描述符大小是 8 字节，故 GDT 中最多可容纳的描述符数量是
65536/8=8192。    

由于段寄存器是 16 位，所以选择子也是 16 位，在其低 2 为即 0-1 位用来存储 RPL。第 2 位是
TI 位，即 Table Indicator，用来指示选择子是在 GDT 中还是 LDT 中索引描述符。TI 为 0 表示
在 GDT 中索引描述符；选择子的高 13 位，用此值在 GDT 中索引描述符。    

由于选择子的索引值部分是 13 位，即 2 的 13 次方是 8192，故最多可以索引 8192 个段，这和
GDT 中最多定义 8192 个描述符是吻合的。    

局部描述符表，叫 LDT，Local Descriptor Table，它是 CPU 厂商在硬件一级原生支持多任务而
创造的表，按照 CPU 的设想，一个任务对应一个 LDT，其实在现代操作系统中很少有用 LDT 的。    

CPU 厂商建议每个任务的私有内存段都应该放到自己的段描述符表中，也就是 LDT。LDT 也位于内存中，
其地址需要先被加载到某个寄存器中，即 LDTR。    

### 4.3.4 保护模式的开发，CRO 寄存器的 PE 位

CR0 寄存器的第 0 位，即 PE 位，Protection Enable，此位用于启用保护模式，是保护模式的
开关。    

```asm
mov eax, cr0
or eax, 0x00000001
mov cr0, eax
```   

## 4.4 处理器微架构简介

### 4.4.1 流水线

指令执行单元 EU 是执行指令的唯一部件，一次只能执行一个指令。CPU 中的各部分也是同时只能
做一件事，但他们是并行工作。CPU 的执行执行过程分为取指，解码，执行。每个步骤都是独立
执行，CPU 可以一边执行指令，一边取指，一边解码。    

CPU 在遇到无条件转移指令时，会清空流水线。    

### 4.4.2 乱序执行

乱序执行，是指在 CPU 中运行的指令并不能按照代码中的顺序执行，而是按照一定的策略打乱顺序
执行，也许后面的指令先执行，当然，得保证指令之间不具有相关性。    

## 4.6 保护模式之内存段的保护

### 4.6.1 向段寄存器加载选择子时的保护

当引用一个内存段时，实际上就是往段寄存器中加载一个选择子，为了避免出现非法引用内存段的情况，
在这时候，处理器会在以下几方面做出检查。   

首先根据选择子的值验证段描述符是否超越界限。判断的标准是选择子一定要小于等于 GDT 或 LDT
中描述符的个数。    

段描述符中还有 TYPE 字段，在进行完选择子检查过后，就要检查段的类型了：   

+ 只有可执行段才能加载到 CS 中
+ 只具备执行属性的段不能加载到处 CS 外的段寄存器中
+ 只有可写的段才能加载到 SS 中
+ 至少具备可读属性的段才能加载到 DS, ES, FS, GS 中

检查完 TYPE 后，还会检查段是否存在，通过 P 位还确认段是否存在，如果为 1，就可以将选择子
载入段寄存器了，同时段描述符缓冲寄存器也会更新为选择子对应的段描述符的内容，随后处理器将
段描述符的 A 置 1。如果 P 为 0，处理器抛出异常，自动转去执行异常处理程序。   

### 4.6.2 代码段和数据段的包含

对于代码段和数据段来说，CPU 每访问一个地址，都要确认该地址不能超过其所在内存段的范围。   

# 第 5 章 保护模式进阶，向内核迈进

## 5.2 启用内存分页机制

### 5.2.2 一级页表

尽管在保护模式中段寄存器中的内容已经是选择子，但选择子最终就是为了要找到段基址，其内存
访问核心基址依然是 “段基址： 段内偏移地址”，这两个地址在相加之后才是绝对地址，也就是我们
所说的线性地址，此线性地址在分段机制下被 CPU 认为是物理地址，直接拿来就能用。   

如果打开了分页机制，段部件输出的线性地址就不再等同于物理地址了，称之为虚拟地址。此虚拟地址
对应的物理地址需要在页表中查找，这项查找工作是由页部件自动完成的。    

1. 分页机制打开前要将页表地址加载到控制寄存器 CR3 中，这是启用分页机制的先决条件之一。
2. 虽然内存分页机制的作用是将虚拟地址转换成物理地址，但其转换过程相当于在关闭分页机制下
进行，过程中所涉及到的页表及页表项地址，它们的地址都被 CPU 当做最终的物理地址直接送上
地址总线。    

### 5.2.3 二级页表

为什么还要二级页面：   

1. 一级页表中最多可容纳 1M 个页表项，每个页表项是 4 字节，如果页表项全满的话，便是 4MB
大小
2. 一级页表中所有页表项必须要提前建好，原因是操作系统要占用 4GB 虚拟地址空间的高 1GB，
用户进程要占用低 3GB
3. 每个进程都有自己的页表，进程一多，光是页表占用空间就很可观了    

归根结底，我们要解决的是：不要一次性将全部页表项建好，需要时动态创建页表项。   

将一级页表中的 1M 个页表项，拆分到 1024 个 1K 个页表项的二级页表中，每个二级页表 4K 大小。   

有个页目录表来专门存储这些页表，每个页表的物理地址都在 **页目录表** 中都以 **页目录项**
(Page Directory Entry, PDE) 的形式存储，页目录项大小同页表项一样，都用来描述一个物理
页的物理地址，其大小都是 4 字节，而且最多有 1024 个页表，所以页目录表也是 4KB 大小，
同样也是标准页的大小。   

![pde](https://raw.githubusercontent.com/temple-deng/markdown-images/master/system/pde.png)    

+ P, Preset，存在位
+ RW, Read/Write，1 表示可读可写，0 表示可读不可写
+ US, User/Supervisor，普通用户/超级用户位。若为 1，表示处于 User 级，任意级别特权的
程序都可以访问该页。若为 0，特权级别为 3 的程序不允许访问该页，该页只允许特权级别为 0,1,2
的程序访问。
+ PWT, Page-level Write-Through，页级通写位，也称页级写透位。若为 1 表示此项采用通写
方式，表示该页不仅是普通内存，还是高速缓存
+ PCD, Page-level Cache Disable，若为 1 表示该页启用高速缓存
+ A, Accessed
+ D, Dirty，此项仅对页表项有效
+ PAT, Page Attribute Table
+ G, Global。该页在高速缓存 TLB 中一直保存，那就是全局页。    

启用分页机制，要按顺序做好三件事：   

1. 准备好页目录表及页表
2. 将页表地址写入控制寄存器 CR3
3. 寄存器 CR0 的 PG 位置1

## 5.4 特权级深入浅出

### 5.4.1 特权级

整个计算机世界可以分为两部分，访问者和受访者。访问者是动态的，具有能动性，它主动去访问
各种资源，受访者是静态的，他就是被访问的资源。访问者的特权级可以变，受访者的特权级不能变。     

建立特权机制是为了通过特权检查合法性，整个计算机的特权检查，都是发生在 “访问者” 在访问
“受访者” 的一刹那，实际上就是检查访问者的特权级和受访者的特权级是否匹配。    

### 5.4.2 TSS 简介

TSS，Task State Segment。    

![tss](https://raw.githubusercontent.com/temple-deng/markdown-images/master/system/tss.png)    

TSS 是每个任务都有个结构，它用于一个任务的标识，相当于任务的身份证。这 104 字节只是 TSS
的最小尺寸，根据需要，还可以再接上个 IO 位图。   

完整的一个任务可以分为用户部分和内核部分，实质上是被分成了 3 特权级的用户程序和 0 特权级的
内核程序，这两部分加在一起才是能让处理器完整运行的程序，也就是说完整的任务要历经这两种特权
的变换。    

任务是由处理器执行的，任务在特权级变换时，本质上是处理器的当前特权级在变换，由一个特权级
变成了另外一个特权级。这就开始涉及栈的问题了，处理器规定，处理器在不同特权级下，应该用
不同特权级的栈，原因是如果在同一个栈中容纳所有特权级的数据时，这种交叉引用会使得栈变得
混乱。    

一共 4 个特权级，因此一个任务最多有 4 个栈。    

特权级转移分为两类，一类是由中断门、调用门等手段实现低特权级转向高特权级，另一类则相反，
是由调用返回指令从高特权级返回到低特权级，这是唯一一种能让处理器降低特权级的情况。    

对于第 1 种——特权级由低到高的情况，由于不知道目标特权级对应的栈地址在哪里，所以要提前把
目标栈的地址记录在某个地方，当处理器向高特权级转移时再从中取出来加载到 SS 和 ESP 中以
更新栈，这个保存的地方就是 TSS。处理器会自动地从 TSS 中找到对应的高特权级栈地址。    

对于第 2 种——由高特权级返回低特权级的情况，处理器是不需要在 TSS 中去寻找低特权级目标栈的。
当处理器在由低向高特权级转移时，它自动地把当时低特权级的栈地址（SS 和 ESP）压入了转移后
的高特权级所在的栈中。    

### 5.4.3 CPL 和 DPL

RPL 代表 **请求特权级**，指令“请求”，“访问”其他资源的能力等级便称之为请求特权级，指令放在代码
段中，所以就用代码段寄存器 CS 中选择子的 RPL 位表示代码请求别人资源能力的等级。位于 CS
寄存器选择子低 2 位的值不仅称为请求特权级，又称为处理器的当前特权级，也就是说处理器的
当前特权级是 CS.RPL。    

在 CPU 中运行的是指令，其运行过程中的指令总会属于某个代码段，该代码段的特权级，也就是
代码段描述符中的 DPL，便是当前 CPU 所处的特权级，这个特权级称为 **当前特权级**，即
CPL(Current Privilege Level)，它表示处理器正在执行的代码的特权级别。处一致性代码段外，
转移后的目标代码段的 DPL 是将来处理器的当前特权级 CPL。    

当处理器从一个特权级的代码段转移到另一个特权级的代码段上执行时，由于两个代码段的特权级不
一样，这就是当前特权级 CPL 改变的原因。当处理器的特权级检查的条件通过后，新代码段的 DPL
就变成了处理器的 CPL，也就是目标代码段描述符的 DPL 将保存在代码段寄存器 CS 中的 RPL 位。    

DPL 是段描述符所代表的内存区域的 “门槛” 权限，访问者能否迈过此门槛访问到本描述符所代表的
资源，其特权级至少要等于这个门槛，访问者特权能否大于该门槛？这要看受访资源时代码还是数据。

访问者任何时候都不允许访问比自己特权更高的资源。在不涉及 RPL 的前提下，下面要分情况讨论。   

+ 对于受访者位数据段来说：    

只有访问者的权限大于等于该 DPL 表示的最低权限才能够继续访问，比如 DPL 为 1 的段描述符，
只有特权级为 0,1 的访问者才有资格访问他所代表的资源。    

+ 对于受访者为代码段来说：   

只有访问者的权限等于该 DPL 表示的 DPL 表示的最低权限才能够继续访问，即只能平级访问。
为什么不能从高到低呢？因为低特权级代码能做的事，高特权级自然也能做。    

不过也有一个例外，就是处理器从中断处理程序返回到用户态的时候。这是唯一一种处理器从高特权级
到低特权级运行的情况。   

如果处理器仅能平移代码段的话，另外三个特权级的代码将没有机会运行。因此，处理器提供了多种
方式用于从低特权级转移到高特权代码。    

一致性代码段用来实现从低特权级的代码向高特权级的代码的转移。一致性代码段是指如果自己是转移
后的目标段，自己的特权级（DPL）一定要大于等于转移前的 CPL。    

一致性代码段的一大特点是转移后的特权级不以自己的特权级(DPL)为主，而是与转移前的低特权级一致。
也就是说，处理器遇到目标段为一致性代码段时，并不会将 CPL 用该目标段的 DPL 替换。    

这种转移本身并没有提升特权级，只是可以跑到特权级更高的代码段中去执行指令，对计算机而言
并未因特权级升高而产生潜在危险，所以在特权级检查过程中，请求者的 RPL 并不参与。   

### 5.4.4 门、调用门与 RPL 序

处理器只有通过 “门结构” 才能由低特权级转移到高特权级。门结构是什么呢？就是记录一段程序
起始地址的描述符。    

描述符有多种，一致性代码段，虽然它里面全是代码，但它本身是内存段，并不是指具体的一段
例程，所以可以用 “段描述符” 来 “描述”。还有一种称为 “门描述符” 的结构，用来描述一段程序。    

![gate](https://raw.githubusercontent.com/temple-deng/markdown-images/master/system/gate.png)    

除了任务门外，其他三种门都是对应到一段例程，即对应一段函数，而不是像描述符对应的是一片
内存区域。任何程序都属于某个内存段，所以程序确切的地址必须用 “代码段选择子 + 段内偏移量”
来描述，可见，门描述符基于段描述符，例程是用段描述符来给出基址的。    

任务门描述符可以放在 GDT, LDT 和 IDT 中，调用门可以位于 GDT, LDT 中，中断门和陷阱门
仅位于 IDT 中。    

任务门、调用门都可以用 call 和 jmp 指令直接调用，原因是这两个门描述符都位于描述符表中，
陷阱门和中断门只存在于 IDT 中，因此不能主动调用，只能由中断信号来触发调用。    

1. 调用门：call 和 jmp 指令后接调用门选择子为参数，以调用函数例程的形式实现从低特权向高
特权转移，可用来实现系统调用。call 指令使用调用门可以实现向高特权转移，jmp 指令只能平级转换
2. 中断门：以 int 指令主动发中断的形式实现从低特权向高特权转移，Linux 系统调用便用此中断门
实现
3. 陷阱门：以 int3 指令主动发中断的形式实现从低特权向高特权转移，这一般是编译器在调试时用
4. 任务门：任务以任务状态段 TSS 为单位，用来实现任务切换，它可以借助中断或指令发起。当中断
发生时，如果对应的中断向量号是任务门，则会发起任务切换。也可以像调用门那样，用 call 或
jmp 指令后接任务门的选择子或任务 TSS 的选择子。    

门的 “门槛” 是访问者特权级的下限，访问者的特权级再低也不能比门描述符的特权级 DPL 低，否则
访问者连门都进不去。门描述符的 DPL 特权级要低于或等于当前特权级 CPL。    

门的 “门框” 是访问者特权级的上限，访问者的特权级再高也不能比门描述符中目标程序所在代码段
的 DPL 高，否则本身的特权级就比目标代码特权级高的话，就不用使用门了。进门之后，处理器将
以目标代码段 DPL 为当前特权级 CPL。    

操作系统可以利用调用门实现一些系统功能（但现代操作系统用调用门实现系统调用并不是主流，
一般是用中断门实现系统调用），用户程序需要系统服务时可以调用该调用门以获得内核帮助。
参数最初是由用户进程以压栈的形式提交给调用门的，也就说参数是保存在用户栈中，处理器在固件
上实现参数的自动复制，即，将用户进程压在 3 特权级栈中的参数自动复制到 0 特权级栈中。    

### 5.4.6 RPL

当用户进程通过调用门陷入内核后，处理器的特权级变为 0 级，如果特权检查仅仅靠 CPL 和 DPL
的话，这时候处理器可以访问并获得任何资源。这时如果用户程序提交的内核数据段选择子作为数据
段，用户进程必然会获取到内核的数据数据，这等于内核完全暴露。    

出现问题的原因是：受访者不知道访问者的真实身份。    

RPL 解决了这个问题，在进行特权检查时，数值上 CPL &gt;= DPL 并且 RPL &gt;= DPL。    

有了 RPL 之后，下面讲一下现在特权检查的步骤。    

DPL 相当于权限的门槛，它代表进入本描述符所对应内存区域的最低权限，任何想迈过这个门槛的人，
它的 RPL 和 CPL 权限必须都要大于等于 DPL。    

特权级检查实际上就是让 CPU 检查数值上 CPL &lt;= DPL && RPL &lt;= DPL 是否成立。    

总结下不通过调用门、直接访问一般数据和代码时的特权检查规则，对于受访者位代码段时：   

+ 如果目标位非一致性代码段，要求：数值上 CPL=RPL=目标代码段 DPL
+ 如果目标位一致性代码段，要求：数值上 CPL &gt;= 目标代码段 DPL && RPL &gt;= 目标代码段 DPL   

对于受访者位数据段时：   

+ 数值上 CPL &lt;= 目标数据段 DPL && RPL &lt;= 目标数据段 DPL    

栈段的特权检查比较特殊，因为在各个特权级下，处理器都要有相应的栈，也就是说栈的特权要和 CPL
相同。即 CPL=RPL=目标段DPL    

处理器对于通过门的特权检查，公式为：   

+ 数值上 DPL_GATE &gt;= CPL &gt;= DPL_CODE
+ RPL &lt;= DPL_GATE

Last Update: 2018.11.24