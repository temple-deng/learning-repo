# 第 5 章 输入 / 输出


<!-- TOC -->

- [第 5 章 输入 / 输出](#第-5-章-输入--输出)
  - [5.1 I/O硬件原理](#51-io硬件原理)
    - [5.1.1 I/O 设备](#511-io-设备)
    - [5.1.2 设备控制器](#512-设备控制器)
    - [5.1.3 内存映射 I/O](#513-内存映射-io)
    - [5.1.4 直接存储器存取](#514-直接存储器存取)
    - [5.1.5 重温中断](#515-重温中断)
  - [5.2 I/O 软件原理](#52-io-软件原理)
    - [5.2.1 I/O 软件的目标](#521-io-软件的目标)
    - [5.2.2 程序控制 I/O](#522-程序控制-io)
    - [5.2.3 中断驱动 I/O](#523-中断驱动-io)
    - [5.2.4 使用 DMA 的 I/O](#524-使用-dma-的-io)
  - [5.3 I/O 软件层次](#53-io-软件层次)
    - [5.3.1 中断处理程序](#531-中断处理程序)
    - [5.3.2 设备驱动程序](#532-设备驱动程序)
    - [5.3.3 与设备无关的 I/O 软件](#533-与设备无关的-io-软件)
  - [5.4 盘](#54-盘)
  - [5.5 时钟](#55-时钟)
    - [5.5.1 时钟硬件](#551-时钟硬件)
    - [5.5.2 时钟软件](#552-时钟软件)
  - [5.6 中断详解](#56-中断详解)
    - [5.6.1 Linux 中断机制](#561-linux-中断机制)
      - [5.6.1.1 中断控制器](#5611-中断控制器)
      - [5.6.1.2 中断描述符](#5612-中断描述符)
    - [5.6.2 中断处理流程](#562-中断处理流程)
  - [5.7 用户界面：键盘、鼠标和监视器](#57-用户界面键盘鼠标和监视器)
    - [5.6.1 输入软件](#561-输入软件)

<!-- /TOC -->

除了提供抽象（例如，进程、地址空间和文件）以外，操作系统还要控制计算机的所有I/O设备。操作系统必须
向设备发送命令，捕捉中断，并处理设备的各种错误。它还应该在设备和系统的其他部分之间提供简单且易于
使用的接口。如果有可能，这个接口对于所有设备都应该是相同的，这就是所谓的设备无关性。     

## 5.1 I/O硬件原理

### 5.1.1 I/O 设备

I/O 设备大致可以分为两类：**块设备**和 **字符设备**。块设备把信息存储在固定大小的块中，每个块有
自己的地址。所有传输以一个或多个完整的块为单位。块设备的基本特征是每个块都能独立于其他块而读写。     

字符设备以字符为单位发送或接受一个字符流。字符设备是不可寻址的，也没有任何寻道操作。    

这种分类方法并不完美，有些设备就没有包括进去，例如，时钟既不是块可寻址的，也不产生字符流。它所做
的工作就是按照预先规定好的时间间隔产生中断。    

### 5.1.2 设备控制器

I/O 设备一般由机械部件和电子部件两部分组成。通常可以将这两部分分开处理，以提供更加模块化和更加通用
的设计。电子部件称作 **设备控制器** 或 **适配器**，可能是主板上的芯片，也可能是设备中的印刷电路板。
机械部件则是设备本身。     

看这个意思是，设备控制器可能是主板提供的，也可以是设备本身提供的。比如说 USB、SATA 之类通用
接口的设备控制器可能就是主板提供的。   

等等，注意一下，设备控制器和设备驱动器是不同的，但是这里可以简单的把设备驱动器与设备本身看作一体，
然后驱动程序是针对设备控制器的程序。    

控制器卡上通常有一个连接器，通向设备本身的电缆可以插入到这个连接器中。很多控制器可以操作2个、4个甚至
8个相同的设备。     

控制器与设备之间的接口通常是一个很低层次的接口。例如，磁盘可以按每个磁道2000000个扇区，每个扇区
512字节进行格式化。然而，实际从驱动器出来的却是一个串行的位（比特）流，它以一个 **前导符**开始，
接着是一个扇区中的4096位，最后是一个检验和，也称为 **错误校正码**。前导符是在对磁盘进行格式化时
写上去的，它包括柱面数和扇区号、扇区大小以及类似的数据，此外还包括同步信息。       

控制器的任务是把串行的位流转换为字节块，并进行必要的错误校正工作。字节块通常通常首先在控制器内部的
一个缓冲区中按位进行组装，然后在对校验和进行教养，在证明字节块没有错误后，再将它复制到主存中。    

### 5.1.3 内存映射 I/O

每个控制器有几个寄存器用来与 CPU 进行通信。通过写入这些寄存器，操作系统可以命令设备发送数据、接受数据、
开启或关闭，或者执行某些其他操作。通过读取这些寄存器，操作系统可以了解设备的状态，是否准备好接收一个新的命令。    

除了这些控制寄存器之外，许多设备还有一个操作系统可以读写的数据缓冲区。     

那么问题来了，CPU 如何与这些寄存器和缓冲区通信。有两种可选的方案，一种是每个寄存器被分配一个 I/O 端口
号，这是一个8位或16位的整数。所有 I/O 端口形成 I/O 端口空间，并且收到保护使得普通的用户程序不能对其
访问。使用一条特殊的 I/O 指令，例如 `IN REG, PORT`，CPU可以读取控制寄存器PORT 中的内容并将
结果存入到CPU寄存器 REG 中。早期计算机都是以这种方式运行的。    

第二个方案是将所有控制寄存器映射到内存空间中，每个控制寄存器被分配唯一的一个内存地址。并且不会有内存
分配这一地址。这样的系统称为 **内存映射I/O**。另外还有一种混合的方案，即数据缓冲区采用内存映射I/O，
而控制寄存器则具有单独的端口。x86 采用这一体系结构。    

这些方案的具体工作流程是：当CPU 想要读一个字的时候，不论从内存中读入还是从 I/O 端口读入，它都要将需要的地址
放到总线上的地址线上，然后在总线的一条控制线上置起一个 READ 信号。还要用到第二条信号线来表明需要的是
I/O 空间还是内存空间，如果是内存空间，内存将响应请求。如果是 I/O 空间，I/O 设备将响应请求。如果只有内存
空间，那么每个内存模块和每个I/O 设备都将地址线和它所服务的地址范围进行比较，如果地址落在这一范围
之内，它就会响应请求。    

两种方案有各自的优缺点，映射的优点有：不需要用汇编来调用特殊的I/O 指令，所以驱动可以用C写（C 
里面没有执行 IN/OUT 指令的方法，所以如果不采用内存映射，则必须用汇编来写驱动），不需要额外
的保护方案防止用户访问I/O 设备。缺点是当前的计算机会使用高速缓存，这些缓存对I/O 设备的缓存是灾难性的。而且
由于只存在内存地址，所以在查找到底是内存地址还是I/O 地址时会很麻烦。    

### 5.1.4 直接存储器存取

无论一个 CPU 是否有内存映射 I/O，它都需要寻址设备控制器以便与它们交换数据。CPU 可以从 I/O 控制器
每次请求一个字节的数据，但是这样做浪费 CPU 时间，所以经常用到一种称为 **直接存储器存取**(Direct Memory Access)
的不同方案。    

只有硬件有 DMA 控制器时操作系统才能使用 DMA，有时DMA 控制器集成到I/O 设备控制器之中，不过更加普遍的
是只在主板上有一个 DMA 控制器，由它调控多个设备的数据传送。    

无论 DMA 控制器在物理上处于什么地方，它都能够独立于 CPU 访问系统总线，它包含若干个可以被 CPU 读写
的寄存器，其中包含一个内存地址寄存器、一个字节计数寄存器和一个或多个控制寄存器。控制寄存器指定要使用的 I/O
端口，传送方向、传送单位（每次一个字节或每次一个字）以及在一次突发传送中要传送的字节数。    

以读磁盘为例，解释以下 DMA 的工作原理。在没有DMA 时，控制器首先从磁盘驱动器串行地读出数据后，放入
内部缓冲区，进行校验。然后产生一个中断，当操作系统开始运行时，它重复地从控制器的缓冲区中一次一个
字节或一个字的读取该块的信息，并将其存入内存中。   

那这种情况下每次读字节都需要 CPU 的干预咯？   

有了 DMA 之后，就是这样的。首先，CPU 通过设置 DMA 控制器的寄存器对它进行编程，所以 DMA
控制器知道将上面数据传送到什么地方（第1步）。DMA 控制器还要向磁盘控制器发出一个命令，通知它从磁盘读数据到其内部
的缓冲区中，并且对校验和进行校验。如果数据有效，DMA 就可以开始传送过程了。   

DMA 控制器通过在总线上发出一个读请求到磁盘控制器而发起 DMA 传送（第2步）。一般情况下，要写的内存地址在总线
的地址线上，所以当磁盘控制器从其内部缓冲区中读取下个字的时候，它知道将字写在什么地方。于是在一个
标准总线周期内，磁盘将数据写入到内存中（第3步），当每次写操作完成后，磁盘控制器在总线上发出一个应答
信号到 DMA（第4步），DMA 步增写入的内存地址，步减写入的字节数，重复2~4步直到写入所有字节。这时，
DMA 将中断 CPU 通知其传送完成。    

DMA 控制器也有简单和复杂之分，前面提到的是最简单，比较复杂一点的有多组寄存器，可以一次处理多路传送。    

许多总线能够以两种模式操作：每次一字模式和块模式。某些 DMA 控制器也能够以这两种模式操作。在前一个模式中，
操作如上所述：DMA 控制器请求传送一个字并且得到这个字，如果 CPU 也想使用总线，必须等待，这一机制称为**周期窃取**，
轻微地延迟 CPU。在块模式中，DMA 控制器通知设备获取总线，发起一连串的传送，然后释放总线，这一操作形式
称为**突发模式**，缺点很明显，长期占用总线会阻塞 CPU 和其他设备。    

但我们之前使用的是 **飞越模式**，DMA 让设备控制器将数据直接传送到内存（这应该就是上述两种模式之一啊）。
另外，某些 DMA 还有其他的模式，让设备控制器将字发送给 DMA 控制器，DMA 控制器然后发起第 2 个总线
请求将该字写到它应该去的任何地方。采用这种方案，每传送一个字需要一个额外的总线周期，但是更加
灵活，因为它可以把数据甚至直接写到另一个设备中。    

### 5.1.5 重温中断

在硬件层面，中断的工作如下。当一个 I/O 设备完成交给它的工作时，它就产生一个中断，它通过在分配给它的一条总线信号线
上置起信号产生中断，该信号被主板上的中断控制器芯片检测到，由中断控制器芯片决定做什么。    

如果没有其他中断悬而未决，中断控制器将立刻对中断进行处理。如果有另一个中断正在处理中，或者另一个设备
在总线上具有更高优先级的一条中断请求线上同时发出中断请求，该设备将暂时不被理睬。在这种情况下，该设备
将继续在总线上置起中断信号，直到得到 CPU 服务。    

为了处理中断，中断控制器在地址线上放置一个数字表明哪个设备需要关注，并且置起一个中断 CPU 的信号。   

中断信号导致 CPU 停止当前正在做的工作并且开始做其他的事情。地址线上的数字被用来指向一个称为中断
向量的表格的索引，以便读取一个新的程序计数器。这一程序计数器指向相应的中断服务过程的开始。   

中断服务开始运行后，它立刻通过将一个确定的值写到中断控制器的某个 I/O 端口来对中断做出应答。这一应答告诉
中断控制器可以自由地发出另一个中断。通过让 CPU 延迟这一应答直到它准备好处理下一个中断，就可以避免与多个
几乎同时发生的中断相牵涉的竞争状态。    

由于现代 CPU 的流水线设计和超标量CPU（就是取指、解码、执行分成3个单元以及多核 CPU 咯），在保存时如何
保存当前进程的状态是一个大问题，因为你很难确定执行了哪些指令执行了哪些没有执行，流水线
比如说3个单元速度不一致，那么可能3个单元中的指令有重叠，那当前指令的执行与否就很难判断（流水线还好把，多核就比较惨了）。    

将机器留在一个明确状态的中断称为 **精确中断**。精确中断具有4个特性：     

1. PC（程序计数器）保存在一个已知的地方
2. PC 所指向的命令之前的所有指令已经完全执行
3. PC 所指向的命令之后的所有指令都没有执行
4. PC 所指向的指令的执行状态是已知的     

## 5.2 I/O 软件原理

### 5.2.1 I/O 软件的目标

第一个目标是 **设备独立性**，即软件可以访问任意的 I/O 设备而无需事先指定设备。     

第二个是 **统一命名**，一个文件或一个设备的名字应该是一个简单的字符串或一个整数，它不应依赖于设备。所有设备
和文件都采用相同的方式——路径名进行寻址。    

第三个是 **错误处理**，设备驱动程序应该能够处理一些硬件解决不了的问题。    

第四个是 **同步** （即阻塞）和**异步** （即中断驱动）传输。    

第五个是 **缓冲**，数据离开一个设备之后通常不能直接存放到其最终的目的地。     

第六个是共享设备和独占设备的问题。    


### 5.2.2 程序控制 I/O   

I/O 可以采用三种不同的方式来实现，即程序控制I/O，中断驱动I/O和使用DMA的I/O，最简单的形式就是让
CPU 做全部工作，即 **程序控制I/O**。    

以向打印机输出一段要打印的字符为例说明程序控制I/O的流程，首选操作系统将字符串数据复制到内核空间，
然后检查打印机当前是否可用，如果不可用就一直等到其可用，如果可用，将第一个字符输出到打印机的寄存器中。
之后操作系统继续轮询检查打印机是否准备好了接受另一个字符，直到所有字符打印完成，控制返回到用户进程。
在这种情况下，CPU 要不断查询设备以了解它是否就绪准备接收另一个字符。这一行为进程称为**轮询**或**忙等待**。    

缺点很明显，一直占据 CPU，浪费时间。    

### 5.2.3 中断驱动 I/O

这一种的话 CPU 在将数据复制内核空间后会查询打印机的状态，不管可不可用 CPU 会在处理后运行调度程序
执行下一个进程，而每次打印机准备好接收下一个字符时就发出一个中断，然后CPU 暂停当前进程开始处理中断。     

### 5.2.4 使用 DMA 的 I/O

这一种的话无非是让 DMA 来代替 CPU 一直给打印机提供字符。     

## 5.3 I/O 软件层次

I/O 软件通常组成四个层次。    


用户级I/O 软件（应该就是普通的应用程序了） |
---------|
与设备无关的操作系统软件 |
设备驱动程序 |
中断处理程序 |
硬件 |     

### 5.3.1 中断处理程序

当中断发生时，中断处理程序将做它必须要做的全部工作以便对中断进行处理，然后，它可以将启动中断的驱动程序
解除阻塞，中断的最终结果是使先前被阻塞的驱动程序现在能够继续运行。    

然而现实并没有这么简单，操作系统还有很多其他要做的工作，下面的一系列步骤简单介绍了这些工作，这些步骤在硬件
中断完成之后必须在软件中执行的。

1. 保存没有被中断硬件保存的所有寄存器。
2. 为中断服务过程设置上下文，可能包括设置TLB、MMU和页表。
3. 为中断服务过程设置堆栈。
4. 应答中断控制器，如果不存在集中的中断控制器，则再次开放中断。
5. 将寄存器从它们被保存的地方（可能是某个堆栈）复制到进程表中。
6. 运行中断服务过程，从发出中断的设备控制器的寄存器中提取信息。
7. 选择下一次运行的哪个进程，如果中断导致某个被阻塞的高优先级进程变为就绪，则可能选择它现在就运行。（这里其实中断可以说是
就处理完了吧）
8. 为下一次要运行的进程设置 MMU 上下文。也许还需要设置某个 TLB。
9. 装入新进程的寄存器，包括其 PSW。
10. 开始运行新进程。     

### 5.3.2 设备驱动程序

每个设备驱动程序通常处理一种类型的设备，或者至多处理一类紧密相关的设备，不过有些时候，极其不同的设备却
基于相同的底层技术，例如 USB。此处的技巧是 USB 驱动程序通常是堆栈式的，就像网络中的 TCP/IP 栈。    

为了访问设备的硬件（意味着访问设备控制器的寄存器），设备驱动程序通常必须是操作系统内核的一部分，至少对
目前的体系结构是如此。    

因为操作系统的设计者知道由外人编写的驱动程序代码片断将被安装在操作系统的内部，所以需要一个体系结构来允许
这样的安装。这意味着要有一个定义明确的模型，规定驱动程序做什么事情以及如何与操作系统的其余部分相互作用。   

大多数操作系统都定义了一个所有块都必须支持的标准接口，并且还定义了另一个所有字符设备都必须支持的标准接口。这些接口
由许多过程组成，操作系统的其余部分可以调用它们让驱动程序工作。    

### 5.3.3 与设备无关的 I/O 软件   

虽然 I/O 软件中有一些是设备特定的，但是其他部分 I/O 软件是与设备无关的。设备驱动程序和与设备无关的软件
之间确切界限依赖于具体系统（和设备），因为对于一些本来应按照与设备无关方式实现的功能，出于效率和其他原因，
实际上是由驱动程序来实现的。表中所示的功能典型地由与设备无关的软件实现。    


设备驱动程序的统一接口 |
---------|
 缓冲 |
 错误报告 |
 分配与释放专用设备 |
 提供与设备无关的块大小 |    


+ **设备驱动程序的统一接口**    

在为所有类似的驱动程序设计相同接口的方法中，对于每一种设备类型，例如磁盘和打印机，操作系统定义一组
驱动程序必须支持的函数。驱动程序通常包含一张表格，这张表格具有针对这些函数指向驱动程序自身的指针。当驱动程序
装载时，操作系统记录下这张函数指针表的地址，所以当操作系统需要调用一个函数时，它可以通过这张表格发出
间接调用。     

+ **缓冲**    

在内核空间创建两个缓冲区并且让中断处理程序将字符放到这两个缓冲区中，当第一个缓冲区填满后，将包含用户缓冲
区的页面调入内存，将内核缓冲区的内容复制到用户缓冲区，在这段时间中，使用第二个缓冲区缓冲数据，这种
缓冲模式称为**双缓冲**。    

缓冲的另一种形式是**循环缓冲区**。它由一个内存区域和两个指针组成，一个指针指向下一个空闲的字，新的数据
可以放置到此处。另一个指针指向缓冲区中数据的第一个字，该字尚未被取走。在许多情况下，当添加数据时，硬件将
推进第一个指针，而操作系统在取走并处理完数据时推进第二个指针。两个指针都是环绕的，当它们到达顶部时
将回到底部。    

剩下的先略了。     

## 5.4 盘

略。    

## 5.5 时钟

时钟又称为定时器，由于各种各样的原因决定了它对于任何多道程序设计系统的操作都是至关重要的。时钟负责
维护时间，并且防止一个进程垄断 CPU，此外还有其他的功能。    

### 5.5.1 时钟硬件

在计算机里通常使用两种类型的时钟，这两种类型的时钟与人们使用的钟表和手表有相当大的差异。比较简单的时钟被连接
到110V 或 220v 的电源线上，这样每个电压周期产生一个中断，频率是50Hz 或 60Hz。这些时候过去曾经占据统治
地位，但是如今非常罕见。   

另一种类型的时钟由三个部件构成：晶体振荡器、计数器和存储寄存器。当把一个石英晶体适当地切割并且安装在
一定的电压之下时，它就可以产生非常精确的周期性信号，典型的频率范围是几百兆赫兹，具体的频率值与所选晶体有关。
使用电子器件可以将这一基础信号乘以一个小的整数来获得高达1000MHz 甚至更高的频率（这他妈究竟是怎么
做到的）。在任何一台
计算机都可以找到至少一个这样的电路，它给计算机的各种电路提供同步信号。该信号被送到计数器，使其递减
计数至0。当计数器为0时，产生一个 CPU 中断。    

可编程时钟通常有几种操作模式。在 **一次完成模式**下，当时钟启动时，它把存储寄存器的值复制到计数器中，
然后，来自晶体的每一个脉冲使计数器减1.当计数器变为0时，产生一个中断，并停止工作，直到软件再一次显示地
启动它。在 **方波模式下**，当计数器变为0并且产生中断之后，存储寄存器的值自动复制到计数器中，并且整个过程
无限期地再次重复下去。这些周期性的中断称为 **时钟滴答**（clock tick）。    

可编程时钟的的优点是其中断频率可以由软件控制，如果采用 5000MHz 的晶体，那么计数器将2ns 脉动一次。
对于 32 位的寄存器来说，中断可以独立被编程为从 2ns 时间间隔发生一次到 8.6s 时间间隔发生一次。
可编程时钟芯片通常包含两个或三个独立的可编程时钟。   

为了防止计算机的电源被切断时丢失当前时间，大多数计算机有一个电池供电的备份时钟。然后系统启动的时候
读取电池（备份）时钟。如果没有备份时候的话，我们可能必须在开机后通过网络获取当前时间，然后再设置系统时钟和
备份时钟，当然也可以手动设置时钟，当然系统时钟和电池时钟必须保持同步。         

### 5.5.2 时钟软件

时钟硬件所做的全部工作是根据已知的时间间隔产生中断。涉及时间的其他所有工作都必须由软件——时钟驱动程序完成。
时钟驱动程序的确切任务因操作系统而异，但通常包括下面的大多数任务：   

1. 维护日时间
2. 防止进程超时运行
3. 对 CPU 的使用情况记账
4. 处理用户进程提出的 alarm 系统调用
5. 为系统本身的各个部分提供监视定时器
6. 完成概要剖析、监视和统计信息收集    

维护时间，在每个时钟滴答将计数器加 1 即可。唯一需要注意的是日时间计数器的位数，对于一个频率为 60Hz
的时钟来说，32 位的计数器仅仅2 年就会溢出。因此，系统不可能在 32 位寄存器中按照自 1970.1.1 以来
的时钟滴答数来保存实际时间。    

可以采用三种方法来解决这一问题。第一种方法是采用 64 位寄存器，但这样会使维护计算器的代价变高，因为
1秒内要做很多次维护计数器的工作（这就很高了吗，32 位不也这样吗）。第二种是以秒为单位维护时间，而不是
时钟滴答，该方法使用一个辅助计数器来对时钟滴答计数，直至累计完至一秒（一个是 1 秒的计数器，一个是
过了多少秒的计数器）。    

第三种方式是对时钟滴答计数，但是这一计数工作是相对于系统引导的时间，而不是相对于一个固定的外部时间。
当读入备份时钟或者用户实际输入时间时，系统引导时间就从当前日时间开始计算，并且以任何方便的形式存放
在内存中。    

时钟的第二个功能是防止进程超时运行。每次启动一个进程，调度程序设置一下计数器（或者应该是那个寄存器吧），
然后时钟就不断地递减计数器，知道计数器为 0 了，产生中断，调用程序调用下一进程。    

时钟的第三个功能是 CPU 记账。最精确的记账方法时，每当一个进程启动时，便启动一个不同于主系统定时
器的辅助定时器，当进程终止时，读出这个定时器的值就可以知道进程运行多少时间。    

在许多系统中，进程可以请求操作系统在一定的时间间隔之后向它报警。警报通常是信号、中断、消息或者
类似的东西。系统必须用一个物理时钟来模拟多个虚拟时钟。通过在一个链表中把所有未完成的时钟按时间
排序链接在一起。链表中每个表项指出在前一个信号之后多少时钟滴答引发下一个信号。    

每一次滴答，将头结点的信号计数器减一。当计数器变为 0 的时候，就引发与链表中第一个表项相对应的信号，
并将这一表项从链表中删除，然后将下一个信号设置为现在处于链表头的表项的取值。     

## 5.6 中断详解

在 CPU 的运行过程中，有两种特殊机制能够使 CPU 暂时放弃当前执行的代码，跳转到相应的处理例程上
进行处理的事件。这两种机制就是 **中断**和 **异常**。  

+ 同步中断是当指令执行时由 CPU 控制单元产生，之所以称为同步，是因为只有在一条指令执行完毕后
CPU 才会发出中断，而不是发生在代码指令执行期间，比如系统调用。     
+ 异步中断是指由其他硬件设备依照 CPU 时钟信号随机产生，即意味着中断能够在指令之间发生，例如键盘中断。      

根据 Intel 官方资料，同步中断称为异常（exception），异步中断被称为中断（interrupt）。      

中断可分为可屏蔽中断（Maskable interrupt）和非屏蔽中断（Nomaskable interrupt）。
异常可分为故障（fault）、陷阱（trap）、终止（abort）三类。      

从广义上讲，中断可分为四类：中断、故障、陷阱、终止。这些类别之间的异同点请参看表:     

| 类别 | 原因 | 异步/同步 | 返回行为 |
|---------|----------|---------|--------- |
| 中断 | 来自 I/O 设备的信号 | 异步 | 总是返回到下一条指令 |
| 陷阱 | 有意的异常 | 同步 | 总是返回到下一条指令 |
| 故障 | 潜在可恢复的错误 | 同步 | 返回到当前指令 |
| 终止 | 不可恢复的错误 | 同步 | 不会返回 |


### 5.6.1 Linux 中断机制

#### 5.6.1.1 中断控制器

中断控制器是连接设备和 CPU 的桥梁，一个设备产生中断后，需要经过中断控制器的转发，才能最终
到达 CPU。时代发展至今，中断控制器经历了 PIC(Programmable Interrupt Controller，可编程中断控制器) 和
APIC (Advanced Programmable Interrupt Controller，高级可编程中断控制器) 两个阶段。
前者在 UP(Uni-processor,单处理器) 上威震四方，随着 SMP (Symmetric Multiple Processor,对称多处理器)
的流行，APIC 已广为流行并将最终取代 PIC。      

一个8295A(PIC)上有如下的管脚：    

+ IR0~IR7 (Interrupt Request0~7，用于连接设备)
+ INT (连接 CPU，当有中断请求时，拉高该管脚以通知 CPU 中断的到来)
+ INTA (连接 CPU，CPU 通过该管脚应答中断请求，并通知 PIC 提交中断的 vector 到数据线)
+ CS (片选，用于将两个 8259A 串联成可连接 15 个设备的 PIC)    

8259A 中的寄存器：   

+ ICW: Initialization Command Word,初始化命令寄存器,用于初始化 8259A
+ OCW: Operation Command Word,操作命令字,用于控制 8259A
+ IRR: Interrupt Request Register,中断请求寄存器,共 8bit,对应 IR0~IR7 八个中断管脚。
当某个管脚的中断请求到来后,若该管脚没有被屏蔽,IRR 中对应的 bit 被置1。表示 PIC 已经收到
设备的中断请求,但还未提交给 CPU。
+ ISR: Interrupt Service Register,服务中寄存器,共 8bit,每 bit 意义同上。当 IRR 中的
某个中断请求被发送给 CPU 后,ISR 中对应的 bit 被置1。表示中断已发送给 CPU,但 CPU 还未处理完。
+ IMR: Interrupt Mask Register,中断屏蔽寄存器,共 8bit,每 bit 意义同上。用于屏蔽中断。
当某 bit 置1时,对应的中断管脚被屏蔽。      

PIC 的每个管脚具有优先级，连接号码较小的设备具有较高的中断优先级。    

在 PIC 默认的 Full Nested 模式下，通过 PIC 发起中断的流程如下：    

+ 一个或多个 IR 管脚上产生电平信号,若对应的中断没有被屏蔽,IRR 中相应的 bit 被置1。
+ PIC 拉高 INT 管脚通知 CPU 中断发生。
+ CPU 通过 INTA 管脚应答 PIC,表示中断请求收到。
+ PIC 收到 INTA 应答后,将 IRR 中具有最高优先级的 bit 清零,并设置 ISR 中对应的 bit。
+ CPU 通过 INTA 管脚第二次发出脉冲,PIC 收到后计算最高优先级中断的 vector,并将它提交到数据线上。
+ 等待 CPU 写 EOI (End of Interrupt)。收到 EOI 后,ISR 中最高优先级的 bit 被清零。
如果 PIC 处于 AEOI 模式,当第二个 INTA 脉冲收到后,ISR 中最高优先级的 bit 自动清零。    

PIC 还有优先级轮转模式，即 PIC 在服务完一个管脚之后将其优先级临时降低，并升高未服务管脚的优先级，
以实现类似轮询的模式，避免一个管脚持续发出中断导致其他设备“饿死”。     

CPU 到系统总线上读取中断芯片(如 8259A)提供的中断向量号，然后调用中断向量号对应的中断处理函数。      

#### 5.6.1.2 中断描述符

在异常 / 中断发生时，CPU 需要进行相应处理。这就需要一张描述收到什么中断/异常时执行什么行为的表，
称为中断描述符表(IDT, Interrupt Descriptor Table)。每项被称为 gate ，一共有 256 项。  

Linux 使用与 Intel 稍有不同的分类，把中断描述符分为五类：    

+ 中断门（interrupt gate）：用户态的进程不能访问Intel中断门（门的DPL字段为0）。
所有的Linux中断处理程序都通过中断门激活，并全部限制在内核态。`set_intr_gate(n, addr)`该系统
调用在 IDT 的第 n 个表项插入一个中断门。门中的段选择符设置成内核代码的段选择符，偏移量设置为
中断处理程序的地址 addr，DPL 字段设置为 0.
+ 系统门（system gate）：用户态的进程可以访问Intel陷阱门（门的DPL字段为3）。通过系统门来
激活三个Linux异常处理程序，它们的向量是4，5及128，因此，在用户态下，可以发布into、bound及
int $0x80三条汇编语言指令。`set_system_gate(n,addr)`
+ 系统中断门（system interrupt gate）：能够被用户态进程访问的Intel中断门（门的DPL字段为3）。
与向量3相关的异常处理程序是由系统中断门激活的，因此，在用户态可以使用汇编语言指令int3。
`set_system_intr_gate(n,addr)`
+ 陷阱门（trap gate）：用户态的进程不能访问的一个Intel陷阱门（门的DPL字段为0）。
大部分Linux异常处理程序都通过陷阱门来激活。`set_trap_gate(n,addr)`
+ 任务门（task gate）：不能被用户态进程访问的Intel任务门（门的DPL字段为0）。
Linux对“Double fault”异常的处理程序是由任务门激活的。`set_task_gate(n,gdt)`     


![idtr](https://raw.githubusercontent.com/temple-deng/markdown-images/master/operating-system/idtr.png)   

查询时，从 IDTR 拿到 base address ，加上向量号 * IDT entry size，即可以定位到对应的表项(gate)。     

在 32 位下，IDT 的一个表项长为 8 bytes，表项(gate)中主要包含 segment selector、offset
和 DPL 。segment selector 和 offset 用于找到处理异常/中断的 handler ，而 DPL 全称 
Descriptor Privilege Level，用于权限控制。    

### 5.6.2 中断处理流程

当执行了一条指令后，CS和eip这对寄存器包含下一条将要执行的指令的逻辑地址。在处理那条指令之前，
控制单元会检查在运行前一条指令时是否已经发生了一个中断或异常。如果发生了一个中断或异常，
那么控制单元执行下列操作：     

1. 确定与中断或异常关联的向量i （0 ≤ i ≤ 255）
2. 读由 IDTR 寄存器指向的 IDT表中的第i项（在下面的分析中，我们假定IDT表项中包含的是一个中断
门或一个陷阱门）。
3. 从 GDTR 寄存器中获得 GDT 的基址，利用 IDT 中保存的段选择符 segment selector 在GDT 中
查找段描述符，这个描述符指定中断或异常处理程序所在段的基地址。
4. 确信中断是由授权的（中断）发生源发出的。首先将当前特权级CPL（存放在cs寄存器的低两位）与
段描述符（存放在GDT中）的描述符特权级DPL比较，如果CPL大于DPL,就产生一个“General protection”异常。
5. 检查是否发生了特权级的变化，也就是说，CPL是否不同于所选择的段描述符的DPL。如果是，控制单元
必须开始使用与新的特权级相关的栈。
6. 如果故障已发生，用引起异常的指令地址装载CS和eip寄存器，从而使得这条指令能再次被执行。
7. 在栈中保存eflags、CS及eip的内容。
8. 如果异常产生了一个硬件出错码，则将它保存在栈中。
9. 装载cs和eip寄存器，其值分别是IDT表中第i项门描述符的段选择符和偏移量字段。这些值给出了中断
10. 或者异常处理程序的第一条指令的逻辑地址。     

控制单元所执行的最后一步就是跳转到中断或者异常处理程序。换句话说，处理完中断信号后，控制单元所
执行的指令就是被选中处理程序的第一条指令。      

## 5.7 用户界面：键盘、鼠标和监视器

### 5.6.1 输入软件

用户输入主要来自键盘和鼠标，在个人计算机上，键盘包含一个嵌入式微处理器，该微处理器通过一个特殊的
串行端口与主板上的控制芯片通信。每当一个键被按下的时候都会产生一个中断，并且每当一个键被释放的时候
还会产生第二个中断。每当发生这样的键盘中断时，键盘驱动程序都要从键盘相关联的 I/O 端口提取信息，，
以了解发生了什么事情。   

**键盘软件**    

I/O 端口中的数字是键的编号，称为 **扫描码**，而不是 ASCII 码。键盘所拥有的键不超过 128 个，所以
只需 7 位表示键的编号。当键按下时，第 8 位设为 0，当键释放时，第 8 位设为 1.    

跟踪每个键的状态（按下或弹起）是驱动程序的任务。所以，硬件所做的全部工作是给出键被按下和释放的
中断，其他的事情由软件来做。   

