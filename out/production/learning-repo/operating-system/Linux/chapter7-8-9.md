# 第 7 章 Linux 磁盘和文件系统管理

<!-- TOC -->

- [第 7 章 Linux 磁盘和文件系统管理](#第-7-章-linux-磁盘和文件系统管理)
  - [7.1 认识Linux 文件系统](#71-认识linux-文件系统)
    - [7.1.1 Linux 的 EXT2 文件系统](#711-linux-的-ext2-文件系统)
    - [7.1.2 与目录树的关系](#712-与目录树的关系)
    - [7.1.3 EXT2/EXT3/EXT4 文件的存取与日志式文件系统的功能](#713-ext2ext3ext4-文件的存取与日志式文件系统的功能)
    - [7.1.4 Linux 文件系统的运行](#714-linux-文件系统的运行)
    - [7.1.5 XFS 文件系统](#715-xfs-文件系统)
  - [7.2 文件系统的简单操作](#72-文件系统的简单操作)
    - [7.2.1 实体链接与符号链接](#721-实体链接与符号链接)
  - [7.3 磁盘的分区、格式化、检验与挂载](#73-磁盘的分区格式化检验与挂载)
    - [7.3.1 观察磁盘分区状态](#731-观察磁盘分区状态)
    - [7.3.2 磁盘分区](#732-磁盘分区)
    - [7.3.3 磁盘格式化](#733-磁盘格式化)
- [第 8 章 文件与文件系统](#第-8-章-文件与文件系统)
  - [8.2 Linux 系统常见的压缩指令](#82-linux-系统常见的压缩指令)
  - [8.3 打包命令：tar](#83-打包命令tar)
  - [8.4 XFS 文件系统的备份与还原](#84-xfs-文件系统的备份与还原)
  - [8.5 光盘写入工具](#85-光盘写入工具)
    - [8.5.1 mkisofs：创建镜像文件](#851-mkisofs创建镜像文件)
- [第 9 章 Vim](#第-9-章-vim)
  - [9.1 vi 的使用](#91-vi-的使用)
    - [9.1.1 快捷键](#911-快捷键)

<!-- /TOC -->

## 7.1 认识Linux 文件系统

我们都知道磁盘分区完毕后还需要进⾏格式化（format），之后操作系统才能够使⽤这个⽂件系统。为什么
需要进⾏“格式化”呢？这是因为每种操作系统所设置的⽂件属性/权限并不相同，为了存放这些⽂件所需的数据，
因此就需要将分区进⾏格式化，以成为操作系统能够利⽤的“⽂件系统格式（filesystem）”。   

在传统的磁盘与文件系统中，一个分区就是一个只能够被格式化成为一个文件系统，所以可以说一个
文件系统就是一个分区。但由于新技术的利用，例如 LVM 和 RAID，这些技术可以将一个分区格式
化为多个文件系统，也能将多个分区合成一个文件系统。但是其实我觉得他这里也其实可以说如果我们没用
LVM 或者 RAID 之类的技术，那么其实还是一个分区一个文件系统。   

那其实格式化就是安装文件系统。  

操作系统中的文件数据除了文件实际内容外，通常含有非常多的属性。例如 Linux 操作系统的文件
权限与文件属性。文件系统通常会将这两部分的数据分别存放在不同的区块，权限与属性放置到 **inode**
中，至于实际数据则放置到 **data block** 区块中。另外，还有一个超级区块 **superblock**
会记录整个文件系统的整体信息，包括 inode 和 block 的总量，使用量，剩余量等。    

每个 inode 与 block 都有编号，三个部分的意义如下：     

+ superblock：记录此 filesystem 的整体信息，包括 inode/block 的总量、使用量、剩余量，以及
文件系统的格式与相关信息等
+ inode：记录文件的属性，一个文件占用一个 inode，同时记录此文件的数据所在的 block 编号
+ block：实际记录文件的内容，若文件太大时，会占用多个 block。     

由于每个 inode 和 block 都有编号，每个文件都会占用一个 inodde，inode 内则有文件数据放置的
block 号码。因为，我们可以知道的是，如果能够找到文件的 inode 话，那么自然就会知道这个文件所
放置的数据的block 号码，当然也就能够读出该文件的实际数据了。     

### 7.1.1 Linux 的 EXT2 文件系统

文件系统通常会一开始就将 inode 和 block 规划好，除非重新格式化（或者利⽤ resize2fs 等指令变
更⽂件系统⼤⼩），否则 inode 和 block 固定后就不再变动。但是如果我们的文件系统高达几百 GB，
那么将所有 inode 和 block 通通放置在一起是很不明智的决定，因为 inode 和 block 的数量太庞大，
不容易管理。     

因此，EXT2 文件系统在格式化的时候基本上是区分为多个区块群组(block group)的，每个区块群组都有
独立的 inode/block/superblock 系统。    

![ext2 filesystem](https://github.com/temple-deng/learning-repo/blob/master/pics/ext2-filesystem.png)    

**data block**    

data block 是用来放置文件内容数据的地方，在 EXT2 文件系统中所支持的 block 大小有 1K，2K及
4K 三种，在格式化时 block 的大小就固定了，且每个 block 都有编号。    

**inode table**   

基本上，inode 记录的文件数据至少有下面这些：    

- 该文件的读取模式(read/write/execute)
- 该文件的拥有者和群组
- 该文件的容量
- 该文件创建或状态改变的时间 ctime
- 最近一次读取时间 atime
- 最近修改的时间 mtime
- 定义文件特性的 flag，如 Set UID
- 该文件内容的指向    

除此之外，inode 还有以下特点：     

+ 每个 inode 大小均固定为 128 Bytes，最新的 ext4 和 xfs 可设置到 256 Bytes
+ 每个文件都仅会占用一个 inode
+ 因此，文件系统能够创建的文件数量与 inode 数量有关
+ 系统读取文件时需要先找到 inode，并分享 inode 所记录的权限与使用者是否符合    

inode 要记录的数据⾮常多，但偏偏又只有 128B ⽽已，⽽ inode 记录⼀个 block 号码要花掉 4B。
为此系统将 inode 记录 block 号码的区域定义为12个直接，⼀个间接，⼀个双间接与⼀个三间接记录区。   

![inode](https://github.com/temple-deng/learning-repo/blob/master/pics/inode.jpg)      

上图最左边为 inode 本身，里面有12个直接指向 block 号码的位置，所谓的间接记录就是用一个 block
来当做记录 block 号码的记录区，双间接和三间接以此类推。    

**superblock**    

superblock 是记录整个文件系统相关信息的地方，没有 superblock，就没有文件系统了，其记录的信息主要有：    

+ block 和 inode 的总量
+ 未使用与已使用的 inode/block 数量
+ block 与 inode 的大小（block 为1, 2, 4K, inode 为 128Bytes 或 256Bytes
+ 文件系统的挂载时间、最近一次写入数据的时间、最近一次检验磁盘的时间等文件系统的相关信息
+ 一个 valid bit 数值，若此文件系统已被挂载，则 valid bit 为0，若未被挂载，则 valid bit 为1。    

事实上除了第一个 block group 内会含有 superblock 之外，后续的 block group 不一定含有
superblock，而若含有 superblock 则该 superblock主要是做为第一个 block group 内
superblock 的备份。   

**filesystem description**      

这个区段可以描述每个 block group 的开始与结束的 block 号码，以及说明每个区段（superblock,
bitmap, inodemap, data block）分别介于哪一个 block 号码之间。     

**block bitmap**   

如果想要新增文件时总会用到 block。通过 bitmap 来获取空 block 的号码。     

**inode bitmap**   

与 block bitmap 类似的功能，只是记录使用和未使用的 inode 号码。     

### 7.1.2 与目录树的关系

当我们在 Linux 的文件系统创建一个目录时，文件系统会分配一个 inode 与至少一块 block 给该目录。
其中，inode 记录该目录的相关权限与属性，并可记录分配到的那块 block 号码，而 block 则是记录在
这个目录下的文件名与该文件名占用的 inode 号码数据。    

### 7.1.3 EXT2/EXT3/EXT4 文件的存取与日志式文件系统的功能

假设我们想要新增一个文件，此时文件系统的行为是：   

1. 先确定使用者对要新增文件的目录是否具有 w 与 x 的权限，若有的话才能新增
2. 根据 inode bitmap 找到没有使用的 inode 号码，并将新文件的权限/属性写入
3. 根据 block bitmap 找到没有使用中的 block 号码，并将实际的数据写入 block 中，且更新 inode
的block 指向数据
4. 将刚刚写入的 inode 和 block 数据同步更新 inode bitmap 与 block bitmap，并更新 superblock
的内容     

日志式文件系统的操作：   

1. 预备：当系统要写入一个文件时，会先在日志记录区块中记录某个文件准备要写入的信息
2. 实际写入：开始写入文件的权限与数据；开始更新 metadata 的数据
3. 结束：完成数据与 metadata 的更新后，在日志记录区块当中完成该文件的记录     

在这样的程序当中，万⼀数据的纪录过程当中发⽣了问题，那么我们的系统只要去检查⽇志记录区块，就可以
知道哪个⽂件发⽣了问题，针对该问题来做⼀致性的检查即可，⽽不必针对整块 filesystem 去检查。   

### 7.1.4 Linux 文件系统的运行

Linux 异步写入：当系统载入一个文件到内存后，如果该文件没有被变动过，则在内存区段的文件数据会被
设置为干净(clean)的。但如果内存中的文件数据被变动过了，此时内存中的数据会被设置为脏的(dirty)。
此时所有的动作都还在内存中执行，并没有写入到磁盘总。系统会不定时的将内存中设置为“Dirty” 的数据写会磁盘。     

### 7.1.5 XFS 文件系统

Ext 文件系统家族对于文件格式化的处理方面，采用的是预先规划出所有 inode/block/metadata 等数据，
未来系统可以直接取用，不需要进行动态配置的做法。但是这样开始格式化的时候会超慢。   

xfs 文件系统在数据的分布上，主要规划为三个部分，一个数据区（data section），一个文件系统活动
登录区（log section）以及一个实时运行区（realtime section），这三个区的内容如下：    

**data section**    

基本上，数据区和我们之前谈到的 ext 文件系统一样，包括 inode/data block/superblock 等数据，
都放置在这个区块。这个数据与 ext 的 block group 类似，也是分为多个存储群组来分别放置文件系统
所需要的数据。每个存储群组都包含了：（1）整个文件系统的 superblock（2）剩余空间的管理机制（3）
inode的分配与跟踪。此外，inode和block都是系统需要用到时，才动态配置产生，所以格式化很快。    

此外，xfs 的 block 和 inode 有多种不同的容量可供设置，block容量可由 512B-64K,inode 容量
则是 256B-2M。    

**文件系统活动登录区**   

在登录区这个区域主要被用来记录文件系统的变化，其实有点像是日志区。文件的变化会在这里记录下来，
直到该变化完整的写入到数据区后，记录才被终结。    

**实时运行区**     

当有文件要被创建时，xfs 会在这个区段里面找一个到数个 extent 区块，将文件放置到这个区块内，等到
分配完毕后，再写入到 data section 的 inode 与 block 去。这个 extent 区块的大小得要在格式化
的时候就先指定，最小值是 4K 最大可到 1G。话说这里所谓的分配是指什么操作，就是正常的写入吗，那岂不是
创建一个文件要在硬盘上写两次，这个效率岂不是很低。      

```shell
# xfs_info 挂载点/设备文件名
```     

## 7.2 文件系统的简单操作

+ `df`：列出文件系统的整体磁盘使用量
+ `du`：评估文件系统的磁盘使用量（常用在推估目录所占容量）    

```shell
# df [-ahikHTm] [文件名或目录名]

-a：列出所有的文件系统，包括系统特有的 /proc 等文件系统
-k：以 KBytes 的容量显示各文件系统
-m：以 MBytes 的容量显示各文件系统
-h：以人们易读的 GB，MB，KB的格式显示
-H：以 M=1000K 取代 M=1024K 的进位方式
-T：连同该分区的文件系统类型也列出
-i：不用磁盘容量，而以 inode 的数量来显示
```    

```shell
#du [-ahskm] filename/dirname

-a：列出所有的文件与目录容量，因为默认仅统计目录下面的文件量而已
-h：以人类易读的容量格式显示
-s：列出总量而已，而不列出每个目录的占用容量
-S：不包括子目录下的总计，与 -s 有点差别
-k：以 KB
-m：以 MB 格式     
```     

### 7.2.1 实体链接与符号链接

+ hard link，实体链接，硬链接     

由于硬链接相当于在目录的 block 中添加一笔记录，指向一个已存在的 inode 号码，因此是只能在单一文件系统中进行的，不能跨文件系统，此外也不能创建一个目录的硬链接。     

+ Symbolic Link，符号链接     

符号链接就是在创建一个独立的文件，而这个文件会让数据的读取指向它 link 的那个文件的文件名。      

```shell
# ln [-sf] 来源文件 目标文件

-s：如果不加任何参数就进行链接，那就是 hard link，至于 -s 就是符号链接
-f：如果目标文件存在，就主动将目标文件移除后再创建
```  

我们创建一个新的目录时, “新的目录的 link 数为 2 ,而上层目录的 link 数则会增加 1 ”。     

## 7.3 磁盘的分区、格式化、检验与挂载

当在系统中新增一颗磁盘，需要以下的操作：    

1. 对磁盘进行分区，以创建可用的分区
2. 对分区进行格式化，以创建系统可用的文件系统
3. 若想要仔细一点，则可对刚刚创建好的文件系统进行检验
4. 在 Linux 系统上，需要创建挂载点，即目录，并将其挂载上来

### 7.3.1 观察磁盘分区状态

+ `lsblk` 列出系统上的所有磁盘列表    

`lsblk` 可以看成 "list block device" 的意思。    

```shell
$ lsblk [-dfimpt] [device]

-d：仅列出磁盘本身，并不会列出该磁盘的分区数据
-f：同时列出该磁盘内的文件系统名称
-i：使用 ASCII 的线段输出
-m：同时输出设备在 /dev 下面的权限数据（rwx数据）
-p：列出该设备的完整文件名
-t：列出该磁盘设备的详细数据
```    

输出的信息含义如下：   

+ NAME：设备的文件名
+ MAJ:MIN：其实核心认识的设备都是通过这两个代码来熟悉的，分别是主要：次要设备代码(major:minor?)
+ RM：是否为可卸载设备(removable device)，如光盘等
+ SIZE：容量
+ RO：是否为只读设备
+ TYPE：是磁盘(disk)、分区(part)还是只读存储器(rom)
+ MOUNTPOINT：挂载点    

UUID是全域单一识别码（universally unique identifier），Linux会将系统内所有的设备都给予一个唯一的识别码，这个识别码可以用来挂载或者使用。可以使用 `blkid` 命令查看。    

+ `parted` 列出磁盘的分区表类型与分区信息    

```shell
# parted device_name print
```     

### 7.3.2 磁盘分区

MBR 分区表请使用 fdisk 分区，GPT 分区请使用 gdisk 分页。    

```shell
$ gdisk 设备名称
$ fdisk 设备名称
```    

### 7.3.3 磁盘格式化

格式化创建文件系统的命令是 `mkfs`，如果要创建 xfs 文件系统，就使用 `mkfs.xfs`：    

```shell
# mkfs.xfs [-b bsize] [-d params] [-i params] [-l params] [-L label] [-f] \
           [-r params] 设备名称（应该是分区名称才准确）

-b：后面接的是 block 容量
-d：后面接的是终于的 data section 相关参数值，主要的值有：
    agcount=数值  ：设置几个存储群组的意思
    agsize=数值   ：每个存储群组多少容量的意思，通常 agcount/agsize 设置一个即可
    file         ：指的是格式话的设置是个文件而不是个设备的意思，例如虚拟磁盘
    size=数值    ：data section 的容量
    su=数值      ：当有 RAID 时，那个 stripe 数值的意思
    sw=数值      ：当有RAID时，用于存储数据的磁盘容量
    sunit=数值   ：与su相当，不过单位使用的是“几个 sector(512Bytes大小)”的意思
    swidth=数值  ：就是 su*sw 的数值,但是以“几个 sector(512Bytes大小)”来设置
-f：如果设备内已经有文件系统,则需要使用这个 -f 来强制格式化才行
-i：与 inode 有关的设置，主要的设置值有：
    size=数值    ：最小是256B，最大是2K
    internal=[0|1]：log 设备是否为内置。默认1内置，如果用外部设备，使用下面设置
    logdev=device ：log设备
    size=数值 :指定这块登录区的容量,通常最小得要有 512 个 block,大约 2M 以上才行
-L:后面接这个文件系统的标头名称 Label name 的意思
-r：指定 realtime section 的相关设置值,常见的有:
   extsize=数值  :就是那个重要的 extent 数值,一般不须设置,但有 RAID 时,
   最好设置与 swidth 的数值相同较佳!最小为 4K 最大为 1G 。
```     

# 第 8 章 文件与文件系统

## 8.2 Linux 系统常见的压缩指令

+ *.Z：compress 程序压缩的文件
+ *.zip：zip程序压缩的文件
+ *.gz：gzip 程序压缩的文件
+ *.bz2：bzip2 程序压缩的文件
+ *.xz：xz 程序压缩的文件
+ *.tar：tar 程序打包的数据，并没有压缩过
+ *.tar.gz：tar 程序打包的文件，其中并且经过 gzip 的压缩
+ *.tar.bz2：tar程序打包的文件，并且经过 bzip2 的压缩
+ *.tar.xz：tar程序打包的文件，经过 xz 的压缩     

gzip 可以解开 compress, zip 与 gzip 等软件所压缩的文件。至于 gzip 所创建的压缩文件为 *.gz 的文件名。     

```shell
$ gzip [-cdtv#] filename

-c：将压缩的数据输出到屏幕上，可通过数据流重定向处理
-d：解压缩的参数
-t：可以用来检验一个压缩文件的一致性
-v：可以显示出原文件/压缩文件的压缩比等信息
-#：#为数字的意思，代表压缩等级，-1最快，但是压缩比最差，-9最慢，但是压缩比最后，默认是 -6。
```   

要注意压缩后源文件就没了，解压缩后压缩文件也会没了，看这样貌似不能重命名啊。    

cat/more/less 可以使用不同的方式来读取纯文本文件,那个 zcat/zmore/zless 则可以对应于 cat/more/less 的方式来读取纯文本文件被压缩后的压缩文件。    

```shell
$ bzip2 [-cdkzv#] filename

-c,-d：略，同gzip。
-k：保留原始文件，而不会删除原始的文件
-z：压缩的参数，默认值，可以不加
-v：可以显示出压缩比
-#：同gzip
```    

同理，使用bzcat/bzmore/bzless/bzgrep。     

```shell
$ xz [-dtlkc#] filename

-l：列出压缩文件的相关信息
其他的同 bzip2
```   

同理有xzcat/xzmore/xzless/xzgrep。    

## 8.3 打包命令：tar

```shell
$ tar [-zjJ] [cv] [-f 新文件名] 待打包的filename  -> 打包与压缩
$ tar [-zjJ] [tv] [-f 既有的 tar 文件名] -> 查看
$ tar [-zjJ] [xv] [-f 既有的 tar 文件名] [-C 目录] -> 解压缩到指定目录

-c：创建打包文件，使用 -v 来查看打包的文件名
-t：查看打包文件的内容含有哪些文件名
-x：解打包或解压缩的功能，可以搭配 -C 在指定目录解开
    特别留意的是 -c, -t, -x 不可同时出现在一串命令行中

-z：通过 gzip 的支持进行压缩解压缩
-j：通过 bzip2 的支持进行压缩解压缩
-J：通过 xz 的支持进行压缩解压缩
    同理 z, j, J 也不能一起出现
-v：将正在处理的文件名显示出来
-f filename：要被处理的文件名
-C 目录：解压缩到特定的目录

-p：保留备份数据的原本权限与属性,常用于备份(-c)重要的配置文件
-P：保留绝对路径,亦即允许备份数据中含有根目录存在之意;
--exclude=FILE:在压缩的过程中,不要将 FILE 打包
```    

## 8.4 XFS 文件系统的备份与还原

xfsdump 除了进行文件系统的完整备份，还可以进行累积备份。使用 `xfsdump` 需要注意以下的限制：    

+ `xfsdump` 不支持没有挂载的文件系统备份
+ `xfsdump` 必须使用 root 的权限才能操作
+ `xfsdump` 只能备份 XFS 文件系统
+ `xfsdump` 备份下来的数据只能用 `xfsrestore` 解析
+ `xfsdump` 是通过文件系统的 UUID 来分辨各个备份文件的，因此不能备份两个具有相同 UUID 的文件系统。    

```shell
# xfsdump [-L S_label] [-M M_label] [-l #] [-f 备份文件] 待备份数据
# xfsdump -I

-L：xfsdump 会记录每次备份的 session 标头，这里可以填写针对此文件系统的简易说明
-M：xfsdump 可以记录存储媒体的标头，这里可以填写此媒体的简易说明
-l：指定等级，有0~9 共10个等级，默认为0，即完整备份
-f：类似 tar，后面接产生的文件
-I：从 /var/lib/xfsdump/inventory 列出目前备份的信息状态
```    

`xfsdump` 默认仅支持文件系统的备份，并不支持特定目录的备份，所以不能区备份某个目录。    

`xfsdump -l 0 -L boot_all -M boot_all -f /srv/boot.dump /boot` 备份 /boot 文件系统。一定得要进行过完整备份后 (-l 0) 才能够继续有其他累积备份 (-l 1~9)。     

```shell
# xfsrestore -I  -> 用来查看备份文件数据
# xfsrestroe [-f 备份文件] [-L S_label] [-s] 待复原目录，单一文件全系统复原
# xfsrestore [-f 备份文件] -r 待复原目录  -> 通过累积备份文件来复原系统
# xfsrestore [-f 备份文件] -i 待复原目录  -> 进入互动模式

-I：跟 xfsdump 相同的输出，查询备份数据
-f：后面接的就是备份文件
-L：就是 session 的label name
-s：需要接某特定目录
-r：如果使用文件来存储备份数据，那这个就不需要使用，如果是一个磁带内带有多个文件，就要用来累积复原
-i：进入互动模式
```    

`# xfsrestore -f /srv/boot.dump -L boot_all /boot` 直接覆盖的复原。也可以指定到别的目录，再手动覆盖的复原。不过直接复原的结果是，同名的文件会被覆盖，但是新的文件会被保留。    

`-s` 的话好像是可以指定恢复备份系统中的某个目录。    

## 8.5 光盘写入工具

### 8.5.1 mkisofs：创建镜像文件

```shell
$ mkisofs [-o 镜像文件] [-Jrv] [-V vol] [-m file] 待备份文件 -graft-point isodir=systemdir

-o：后面接你想要产生的那个镜像文件文件名
-J：产生相容于 Windows 机器的文件名结构，可增加文件名长度到 64 个 unicode 字符
-r：通过 Rock Ridge 产生支持 Unix/Linux 的文件数据，可记录较多的信息
-v：显示创建 ISO文件的过程
-V vol：创建Volume，有点像 Windows 在文件资源管理器内看到的 CD title 的东西
-m file： -m 为排除文件的意思
-graft-point：下面再说
```   

如果我们只是想要制作“数据光盘”时,上述的选项也就够用了。光盘的格式一般称为 iso9660 ,这种格式一般仅支持旧版的 DOS 文件名,亦即文件名只能以 8.3 (文件名8个字符,扩展名3个字符) 的方式存在。如果加上 -r 的选项之后,那么文件信息能够被记录的比较完整,可包括UID/GID与权限等等。    

# 第 9 章 Vim

## 9.1 vi 的使用

vi分为3种模式，分别是一般指令模式、编辑模式与命令行命令模式。这3种模式的作用分别是：    

+ 一般指令模式：以 vi 打开一个文件就直接进入一般指令模式了(这是默认的模式,也简称为一般模式)。在
这个模式中, 你可以使用“上下左右”按键来移动光标,你可以使用“删除字符”或“删除整列”来处理文件内容, 也可以使用“复制、贴上”来处理你的文件数据。   
+ 编辑模式/插入模式：在一般指令模式中可以进行删除、复制、贴上等等的动作,但是却无法编辑文件内容的! 要
等到你按下“i, I, o, O, a, A, r, R”等任何一个字母之后才会进入编辑模式。
+ 命令行命令模式：在一般模式当中,输入“ : / ? ”三个中的任何一个按钮,就可以将光标移动到最下面那一列。在
这个模式当中, 可以提供你“搜寻数据”的动作,而读取、存盘、大量取代字符、离开 vi 、显示行号等等的动作则是在此模式中达成的。     

### 9.1.1 快捷键

**一般模式下**：   

- 光标移动类：
    + h,j,k,l：左，下，上，右
    + <kbd>Ctrl</kbd> + f/b：向下/上翻页
    + <kbd>Ctrl</kbd> + d/u：向下/上翻半页
    + n + <kbd>space</kbd>：n表示数值，例如20。则光标会向右移动20个字符。
    + 0或功能键[Home]：移动到这一列第一个字符处
    + $或功能键[End]：移动到这一列最后字符处
    + H：光标移动到这个屏幕的最上方那一列的第一个字符
    + M：移动到这个屏幕中央的那一列的第一个字符
    + L：移动到屏幕最下方那一列的第一字符
    + G：移动到文件的最后一列
    + nG：n为数值，移动到第n列。
    + gg：移动到第一列
    + n + <kbd>Enter</kbd>：n为数值，向下移动 n列
- 查找与替换类：
    + /word：向光标之下寻找一个名称为 work 的字串。
    + ？word：向光标之上寻找一个 work 字串
    + n：重复前一个查找动作
    + N：反向进行
    + :n1,n2s/word1/word2/g：n1与n2为数字，在n1列到n2列之间查找word1 替换为word2
    + :1,$s/word1/word2/g：从第一列到最后一列
    + :1,$s/word1/word2/gc：从第一列到最后一列，但在替换前会询问
- 删除、复制与粘贴类：
    + x,X：x为向后删除一个字符，X为向前删除一个字符
    + nx：n为数值，连续向后删除n个字符
    + dd：删除光标所在的那一整列
    + ndd：删除光标向下 n列
    + d1G：删除光标所在列到第一列的所有数据
    + dG：删除光标所在到最后一列的所有数据
    + d$：删除光标所在处到该列最后一个字符
    + d0：删除光标所在处到该列第一个字符
    + yy：复制光标所在的那一列
    + nyy：复制光标向下 n列
    + y1G：复制光标所在列到第一列的所有数据
    + yG：复制到最后一列
    + y0：复制光标所在处到该列第一字符
    + y$：略
    + p,P：p为将已复制的数据在光标下一列贴上，P则为在上面贴
    + J：将光标所在列与下一列的数据结合成同一列
    + u：复原前一个动作
    + <kbd>Ctrl</kbd> + r：重复前一个动作   

**命令界面的指令**：    

+ :w：将编辑的数据写入硬盘
+ :w!：若文件属性为只读时，强制写入。
+ :q：离开
+ :q!：不想保存编辑离开时
+ ZZ：若文件没有变动过，则不存储离开，若变动过，存储后离开
+ :w [filename]：将编辑的数据存储为另一个，也就是另存为
+ :n1,n2 w [filename]：将 n1到 n2 的内容存储为 filename
+ :set nu：显示行号
+ :set nonu：取消行号



