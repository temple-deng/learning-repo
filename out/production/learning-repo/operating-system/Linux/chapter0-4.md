# 第 0 章 计算机概论

<!-- TOC -->

- [第 0 章 计算机概论](#第-0-章-计算机概论)
  - [0.1 计算机组成](#01-计算机组成)
  - [0.2 电脑架构与相关元件](#02-电脑架构与相关元件)
    - [0.2.1 显卡](#021-显卡)
    - [0.2.2 硬盘](#022-硬盘)
- [第 1 章 Linux 简介](#第-1-章-linux-简介)
- [第 2 章 主机规划与磁盘分区](#第-2-章-主机规划与磁盘分区)
  - [2.1 Linux 与硬件](#21-linux-与硬件)
    - [2.1.1 各硬件设备在 Linux 中的文件名](#211-各硬件设备在-linux-中的文件名)
  - [2.2 磁盘分区](#22-磁盘分区)
    - [2.2.1 MBR 与 GPT 磁盘分区表](#221-mbr-与-gpt-磁盘分区表)
    - [2.2.2 开机流程中的 BIOS 与 UEFI 开机检测程序](#222-开机流程中的-bios-与-uefi-开机检测程序)
- [第 3 章 安装 CentOS7](#第-3-章-安装-centos7)
  - [3.1 分区配置](#31-分区配置)
- [第 4 章 首次登录与线上求助](#第-4-章-首次登录与线上求助)
  - [4.1 命令](#41-命令)
    - [4.1.1 基础的几个命令](#411-基础的几个命令)
  - [4.2 man page 和 info page](#42-man-page-和-info-page)
    - [4.2.1 搜寻特定指令/文件的 man page 说明文档](#421-搜寻特定指令文件的-man-page-说明文档)
  - [4.3 关机](#43-关机)
    - [4.3.1 Sync](#431-sync)
    - [4.3.2 shutdown](#432-shutdown)
    - [4.3.3 systemctl](#433-systemctl)

<!-- /TOC -->

## 0.1 计算机组成

CPU里含有微指令集。CPU 的工作主要在与管理和运算，因此在 CPU 内又可分为两个主要的单元，
分别是算数逻辑单元和控制单元。其中算数逻辑单元主要负责程序运算与逻辑判断，控制单元主要
协调各周边元件与各单元间的工作。    

## 0.2 电脑架构与相关元件

在主板上，早期的芯片组通常分为两个桥接器来控制各元件的沟通，分别是：   

1. 北桥：负责连接速度较快的CPU、内存和显卡接口等元件
2. 南桥：负责连接速度较慢的设备接口，包括硬盘、USB、网卡等。    

不过由于北桥最重要的就是 CPU 与内存之间的桥接，因此目前的主流架构中，大多将北桥内存
控制器整合到 CPU 封装当中了。    

外频指的是 CPU 与外部元件进行数据传输时的速度，倍频则是 CPU 内部用来加速工作性能的一个倍数，
两者相乘才是 CPU 的频率。    

超频就是改外频。    

超线程：在每一个 CPU 内部将重要的寄存器分成两群，而让程序分别使用这两群寄存器。也就是说，
可以有两个程序“同时竞争CPU 的运算单元”，而非通过操作系统的多任务切换。这一过程就会让CPU 
好像同时有两个核心一样。因此例如 I7 的4个核心可以同时运行八个程序。    

除了内存条之外，事实上整部PC当中还有很多内存存在。例如 CPU 内的第二层告诉缓存内存。由于
L2 cache 整合到 CPU 内部，因此这个L2 内存的速度必须要与 CPU频率相同。使用普通内存的
DRAM 是无法达到这个频率速度的，因此就需要 SRAM（Static Random Access Memory) 了。    

主板上的元件非常多，每个元件的参数又具有可调整性。例如，CPU 与内存的频率是可调整的；而
如果主板上面有内置的网卡或者是显卡时，该功能是否要启动与该功能的各项参数，是被记录到主板
上一个称为 CMOS 的芯片上，这个芯片需要借助额外的电源来发挥记录功能，这就是主板上有一颗
电池的缘故。    

CMOS 的数据如何读取和更新：电脑开机的时候可以按下 <kbd>Del</kbd>进入 BIOS(Basic Input
Output System) 程序，这套程序写死到主板上的一个内存芯片中，这个内存芯片在没有通电时也
能够将数据记录下来，那就是ROM(Read Only Memory)。    

根据操作系统书上说的，现在的BIOS 存储在闪速 RAM 上，也是非易失性的。因为之前 ROM 是只读的，无法修改。     

### 0.2.1 显卡

显卡的规格由早期的 PCI 到现在被 PCI-Express规格取代了。PCIe 使用的是类似管线的概念来处理，
在第一版中 PCIe 1.0，每条管线可以具有250 MBytes/s 的带宽性能，管线越多（通常设计到 x16）
则总带宽越高。另外，为了提升更多的带宽，PCIe 还有进阶版本，目前主要为第三版 PCIe 3.0。   

### 0.2.2 硬盘

虽然硬盘看起来就一个圆柱体，然而却是由许多圆形盘片组成，那读取头怎么读取下方盘片的数据呢。
注意硬盘中不是只有一个读取头，貌似是这样，盘片之间都有一点距离隔开，而在每个盘片的间隙间
都有磁头读取，而且好像是两个磁头，一个读取上面盘片的反面，一个读取下面盘片的正面。    

通常数据写入方式就是以圆圈转圈的方式读写。因此，在盘片同心圆上切出一个一个的小区块，这些
小区块就是硬盘最小的物理存储单位，称之为扇区，同一个同心圆的扇区组成的圆就是磁道/轨道。
由于磁盘里可能有多个盘片，因此在所有盘片上的同一个磁道组成一个柱面。     

原本硬盘的扇区都是512 Byte 的容量，但是最近有的硬盘已经有 4KByte 的扇区设计。    

# 第 1 章 Linux 简介

Linux 核心版本格式如下：    

```
3.10.0-123.el7.x86_64
主版本.次版本.释出版本-修改版本
```    

使用 `uname -r` 查看内核版本。   

# 第 2 章 主机规划与磁盘分区

## 2.1 Linux 与硬件

### 2.1.1 各硬件设备在 Linux 中的文件名


设备 | 文件名 | 
----------|---------
 SCSI/SATA/USB 硬盘 | /dev/sd[a-p] 
 USB 闪存 | /dev/sd[a-p]（与SATA相同）
 VirtI/O 界面 | /dev/vd[a-p]（用于虚拟机内）
 打印机 | /dev/lp[0-2]（25针打印机） /dev/usb/lp[0-15]（USB接口）
 鼠标 | /dev/input/mouse[0-15]（通用）/dev/mouse（当前鼠标)
 CDROM/DVDROM | /dev/scd[0-1]（通用） /dev/sr[0-1]（通用） /dev/cdrom（当前 CDROM）

## 2.2 磁盘分区

整颗磁盘的第一个扇区特别的重要，因为它记录了整颗磁盘的重要信息。早期磁盘的第一个扇区里面
含有的重要信息我们称为 MBR (Master Boot Record)格式，后来又多了一个新的磁盘分区格式，
称为 GPT(GUID partition table)。     

### 2.2.1 MBR 与 GPT 磁盘分区表

**MBR 分区表格式和限制**     

早期的 Linux 系统为了相容于 Windows 的磁盘，因此使用的是支持 Windows 的 MBR 的方式来
处理开机管理程序和分区表。而开机管理程序记录区和分区表通通放在磁盘的第一个扇区，这个扇区
通常是 512Bytes 的大小。所以说，第一个扇区 512Bytes 会有这两个数据：   

+ 主要开机记录区MBR：可以安装开机管理程序的地方，有446Bytes
+ 分区表：记录整颗硬盘分区的状态，有64Bytes。     

因为分区表所在区块仅有64 Bytes容量，因此最多仅能有四组记录区，每组记录区记录了该区段的
起始和结束的柱面号码。假如一块硬盘文件名为 /dev/sda，分了4个分区，那么这四个分区在 Linux
系统中的设备文件名为 /dev/sda1, /dev/sda2, /dev/sda3, /dev/sda4。     

由于分区最多只能容纳四笔分区的记录，这四个分区被称为主分区或扩展分区。    

扩展分区的⽬的是使⽤额外的扇区来记录分区信息，扩展分区本⾝并不能被拿来格式化。  

扩展分区并不是只占一个区块，而是会分布在每个分区的最前面几个扇区来记载分区信息。扩展分区
的目的是使用额外的扇区来记录分区信息，扩展分区本身并不能被拿来格式化。由扩展分区再划分
出来的分区，就叫逻辑分区。     

+ 主分区和扩展分区最多可以有 4 个（硬盘的限制，因为 MBR 只有 64 字节用来记录分区信息吧）
+ 扩展分区最多只能有一个（操作系统的限制）
+ 逻辑分区是由扩展分区持续切割出来的分区
+ 能够被格式化的，只有主分区和逻辑分区，扩展分区无法格式化
+ 逻辑分区的数据依操作系统而不同    

**GUID partition table GPT 磁盘分区表**     

因为过去的一个扇区大小为 512Bytes，目前则有 4K 的扇区出现。为了相容于所有的磁盘，因此在扇区的
定义上面，大多会使用所谓的逻辑区块位址（Logical Block Address, LBA）来处理。GPT 将磁盘所
有区块以 LBA（默认为 512 Bytes）来规划，第一个 LBA 称为 LBA0。所以 LBA 只是一种定义扇区
大小的方式。      

与 MBR 仅使用第一个 512 Bytes 区块来记录不同，GPT 使用了 34 个LBA区块来记录分区信息。
同时除了前面的34个 LBA 之外，整个磁盘的最后33个LBA 也拿来作为另一个备份。    

![GUID partition table](https://raw.githubusercontent.com/temple-deng/markdown-images/master/linux/GUID-partition-table.png)  

+ LBA0(MBR 相容区块)：与 MBR 模式相似，这个相容区块也分为两个部分，一个就是跟之前 446Bytes 
相似的区块，储存了第一阶段的开机管理程序！而在原本的分区表的记录区内，这个相容模式仅放入一个特殊
标志的分区，用来表示此磁盘为 GPT 格式之意。而不懂 GPT 分区表的磁盘管理程序，就不会认识这颗磁盘。  
+ LBA1（GPT 表头记录）：这个部分记录了分区表本身的位置和大小，同时记录了备份用的GPT分区放置的
位置，同时放置了分区表的检验机制码。操作系统可以根据这个校验码来判断 GPT 是否正确，若有错误，
可以通过这个记录区取得备份的GPT来恢复。
+ LBA2-33（实际记录分区信息处）：从LBA2区块开始，每个LBA都可以记录4条分区记录，所以在默认的
情况下，总共可以有4*32=128 条分区记录。每条记录用到128Bytes 空间，除了每条记录所需要的识别码
和相关的记录之外，GPT 在每笔记录中分别提供了 64bits 来记载开始/结束的扇区号码。    

现在 GPT 分区默认可以提供多达 128 笔记录，此外，GPT 分区已经没有所谓的主、扩展、逻辑分区的
概念，既然每笔记录都可以独立存在，当然每个都可以视为主分区，每个分区都可以拿来格式化使用。    

### 2.2.2 开机流程中的 BIOS 与 UEFI 开机检测程序

**BIOS 搭配MBR/GPT 的开机流程**     

BIOS 是在开机的时候，计算机系统会自动执行的第一个程序了。接下来 BIOS 会区分析计算机里有哪些
存储设备，我们以硬盘为例，BIOS 会依据使用者的设置去取得能够开机的硬盘，并且到该硬盘里面去读取
第一个扇区的 MBR 位置。MBR 这个仅有的446Bytes 的硬盘容量里面会放置最基本的开机管理程序，此时 
BIOS就功成圆满，接下来就是 MBR 内开机管理程序的工作了。    

这个开机管理程序的目的是载入核心文件，由于开机管理程序是操作系统在安装的时候所提供的，
所以它会认识硬盘内的文件系统格式，因此能够读取核心文件，然后就是核心文件的工作了。   

简单的说， 整个开机流程到操作系统之前的动作应该是这样的：   

1. BIOS：开机主动执⾏的固件，会认识第⼀个可开机的设备；
2. MBR：第⼀个可开机设备的第⼀个扇区内的主要开机记录区块，内含开机管理程序；
3. 开机管理程序（boot loader）：⼀⽀可读取核⼼⽂件来执⾏的软件；
4. 核⼼⽂件：开始操作系统的功能..     

如果你的开机管理程序能够认识 GPT 的话，那么使⽤ BIOS 同样可以读取到正确的操作系统核⼼。换句话
说，如果开机管理程序不懂 GPT，例如 Windows XP 的环境，那⾃然就⽆法读取核⼼⽂件，开机就失败了。   

由于 LBA0 仅提供第一阶段的开机管理程序码，因此如果使用类似 grub 的开机管理程序，得额外
分区出一个"BIOS boot" 的分区，这个分区才能够放置其他开机过程所需的程序码。    

Boot loader 是操作系统安装在 MBR 上面的一套软件。其主要任务如下：    

+ 提供菜单：使用者可以选择不同的开机项目，这也是多重开机的重要功能
+ 载入核心文件：直接指向可开机的程序区段来开始操作系统
+ 转交其他loader：将开机管理功能转交给其他loader负责     

根据上面的第3点，开机管理程序除了可以安装在 MBR 之外，还可以安装在每个分区的开机扇区(boot sector)中。如下图中的例子，第一、二分区分别安装了 Windows 及 Linux：    

![boot loader](https://github.com/temple-deng/learning-repo/blob/master/pics/boot-loader.png)    

在上图中，MBR 的开机管理程序提供两个菜单，菜单一可以直接载入 Windows 的核心文件来开机，菜单二则是将开机管理工作交给第二个分区的开机扇区。当使用者在开机的时候选择菜单二时，那么整个开机管理工作就会交给第二分区的开机管理程序。这就是多重开机的情况。   

**UEFI BIOS 搭配 GPT 开机的流程**    

由于 BIOS 不懂 GPT。只能以相容模式处理。所以为了解决这个问题，有了 UEFI（Unified Extensible
Firmware Interface）。UEFI 主要是想要取代 BIOS，因此我们也称 UEFI 为 UEFI BIOS。    

# 第 3 章 安装 CentOS7

## 3.1 分区配置

所需目录/设备 | 磁盘容量 | 文件系统 | 分区格式
---------|----------|---------|---------
 BIOS boot | 2MB | 系统自订 | 主分区
 /boot | 1GB | xfs | 主分区
 / | 10GB | xfs | LVM 方式
 /home | 5GB | xfs | LVM 方式
 swap | 1GB | swap | LVM 方式

话说这里 BIOS boot 是存放开机启动程序的，那 /boot 目录是放什么的，还有分区格式是什么东西。  

根据后面的内容来看，/boot 目录主要放置开机会用到的文件，包括 Linux 核心文件以及开机菜单和开机
所需配置文件。   

这里其实感觉说的有点问题，严格来说这里其实是划分挂载点，最终是根据我们划分的每一个挂载点然后分一个
区出来。   

这里简单讲一下自己理解的 grub2 之类的开机程序，这种程序通常安装在 MBR 中，我们知道通常 MBR 安装
的是操作系统安装的系统启动代码，而这里我们把 grub2 安装到这里，那么启动后，BIOS 处理完自己的
工作后，那就到了这里来执行，如果 grub2 有一些 I/O 能力话，就可以和用户交互，来决定下一步去那里
执行，那这样我们其实是可以选择去哪里执行操作系统启动代码的，那这里其实就可以提供给我们双系统启动
时的选择。   

安装时的各个文件系统：   

+ ext2/ext3/ext4: Linux早期使用的文件系统类型。
+ swap:由于swap 并不会使用到目录树的挂载，所以不需要指定挂载点。
+ BIOS Boot: 就是GPT 分区表可能用到的项目，如果使用 MBR 分区就不需要这个项目了。
+ xfs: 这个是目前 CentOS 默认的文件系统，对于大容量的磁盘管理非常好，而且格式化的时候速度相当快。
+ vfat: 同时被 Linux 和 Windows 所支持的文件系统类型。如果你的主机硬盘内同时存在 Windows 和 Linux 系统，为了数据的交换，可以创建一个这样的系统。

# 第 4 章 首次登录与线上求助

从 CentOS 7 开始，已经取消了使用多年的 SystemV 的服务管理方式，也就是说，从这一版开始，已经没有所谓的“执行等级（run level）”的概念了。新的管理方法使用的是 systemd 的模式，这个模式将很多的服务进行相依性管理。     

登录时上面显示的内容来自与 /etc/issue 这个文件。     

登出命令 `exit` 但是好像 `logout` 也可以。    

## 4.1 命令

```shell
[dengbo@host ~]$ command [-options] parameter1 parameter2 ...
                 命令      选项      参数1           参数2
```    

1. 一行指令中第一个输入的部分一定是“命令”或“可执行文件”
2. parameter1 parameter2... 为依附在选项后面的参数，或者是 command 的参数
3. 指令，选项，参数之间以空格分割，不管几个空格 shell 都视为一个
4. 按下 <kbd>Enter</kbd> 命令开始执行
5. 命令太长的时候，可以使用反斜线(\)来断行。不过必须在紧跟着反斜线后面输入后面的命令内容。   

光输入 `locale` 命令其实是展示当前主机与语系相关的信息。也就是展示一系列当前系统语系设置的系统
变量吧。LANG 其实只是 base 输出的语言设置。   

### 4.1.1 基础的几个命令

+ 显示日期与时间的指令： `date`
+ 显示日历的指令：`cal`
+ 简单好用的计算机：`bc`    

**date**    

格式化输出：   

```shell
$ date +%Y/%m/%d
$ date +%H:%M
```     

从这个例子能看出，命令的选项除了以 `-` 开头外，在一些特殊的情况下，选项或参数前面也会带有 `+` 的情况。    

**cal**  

语法： `cal [month] [year]`   

**bc**  

bc默认仅输出整数位，如果要输出小数点位，必须要执行 `scale=number`，`number`是小数点后的位数。    

输入 `quit` 退出。     

## 4.2 man page 和 info page

指令添加 `--help` 会显示用法帮助。   

命令的类别：   


代号 | 代表内容 
----------|---------
 1 | 使用者在 shell 环境中可以操作的指令或可执行文件
 2 | 系统核心可调用的函数与工具 
 3 | 一些常用的函数与函数库，大部分是C的函数库
 4 | 设备文件的说明
 5 | 配置文件或者是某些文件的格式
 6 | 游戏
 7 | 惯例与协定等，例如Linux文件系统、网络协定
 8 | 系统管理员可用的命令
 9 | 跟内核有关的文件   

### 4.2.1 搜寻特定指令/文件的 man page 说明文档

例如，系统中还有哪些跟"man"指令相关的说明文档：    

```shell
$ man -f man
man	(1)														-	an	interface	to	the	on-line	reference	manuals
man	(7)														-	macros	to	format	man	pages
```    

可以指定显示的文档：   

```shell
$ man 1 man
$ man 7 man
```    

## 4.3 关机

关机的注意事项：  

+ 观察系统的使用状态：如果要看目前谁在线上，使用`who` 命令，而如果要看网络的连线状态，
可以下达 `netstat -a` 命令，要看背景执行的程序执行 `ps -aux` 命令。
+ 通知线上使用者关机的时刻，使用 `shutdown` 指令。    

常用的几个与关机/重新开机相关的指令：   

+ 将数据同步写入硬盘中的指令： `sync`
+ 惯用的关机指令：`shutdown`
+ 重新开机，关机：`reboot`, `halt`, `poweroff`     

### 4.3.1 Sync

由于硬盘的速度太慢，所以如果系统常常让数据在内存和硬盘间来回写入/读出，性能就会不太好。    

因此在 Linux 系统中，为了加快数据的读取速度，所以在默认的情况中，某些已经载入内存中的数据将不会直接被写入硬盘，而是先暂存在内存当中，如此一来，如果一个数据被你重复的改写，那么由于他尚未被写入到硬盘中，因此可以直接由内存中读取出来。     

因此，这时如果遇到突发情况，数据未被写入到硬盘当中，就会造成数据的更新不正常。这时候就需要 `sync` 指令，强制将内存中尚未被更新的数据，写入到硬盘中。     

### 4.3.2 shutdown

如果是在主机中的终端上(tty1-tty7)登陆时，不论什么身份都可以关机，如果是远程登陆工具，例如SSH，则只有 root 可以。     

shutdown 可以完成如下的工作：    

+ 可以自由选择关机模式：关机或重新开机均可
+ 可以设置关机时间：可以设置成现在立刻关机，也可以设置成某一个特定的时间才关机
+ 可以自定关机讯息：在关机之前，可以将自己设置的讯息传送给线上 user
+ 可以仅发出警告讯息    

### 4.3.3 systemctl

上面提到的 halt, poweroff, reboot, shutdown等，其实都是调用这个 systemctl 命令：     

```shell
# systemctl [命令]
指令项目包括：
halt
poweroff
reboot
suspend    休眠模式
```    

