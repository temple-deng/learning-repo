# 第 7 章 理解 Linux 文件权限

<!-- TOC -->

- [第 7 章 理解 Linux 文件权限](#第-7-章-理解-linux-文件权限)
  - [7.1 Linux 的安全性](#71-linux-的安全性)
    - [7.1.1 /etc/passed 文件](#711-etcpassed-文件)
    - [7.1.2 /etc/shadow 文件](#712-etcshadow-文件)
    - [7.1.3 添加新用户](#713-添加新用户)
    - [7.1.4 删除用户](#714-删除用户)
    - [7.1.5 修改用户](#715-修改用户)
  - [7.2 使用 Linux 组](#72-使用-linux-组)
    - [7.2.1 /etc/group 文件](#721-etcgroup-文件)
    - [7.2.2 创建新组](#722-创建新组)
    - [7.2.3 修改组](#723-修改组)
  - [7.3 理解文件权限](#73-理解文件权限)
    - [7.3.2 默认文件权限](#732-默认文件权限)
  - [7.4 改变安全性设置](#74-改变安全性设置)
    - [7.4.1 改变权限](#741-改变权限)
    - [7.4.2 改变所属关系](#742-改变所属关系)
  - [7.5 共享文件](#75-共享文件)
- [第 8 章 管理文件系统](#第-8-章-管理文件系统)
  - [8.1 探索 Linux 文件系统](#81-探索-linux-文件系统)
    - [8.1.1 基本的 Linux 文件系统](#811-基本的-linux-文件系统)
    - [8.1.2 日志文件系统](#812-日志文件系统)
  - [8.2 操作文件系统](#82-操作文件系统)
    - [8.2.1 创建分区](#821-创建分区)
    - [8.2.2 创建文件系统](#822-创建文件系统)
    - [8.2.3 文件系统的检查和修复](#823-文件系统的检查和修复)
  - [8.3 逻辑卷管理](#83-逻辑卷管理)
    - [8.3.1 逻辑卷管理布局](#831-逻辑卷管理布局)
    - [8.3.2 Linux 中的 LVM](#832-linux-中的-lvm)
    - [8.3.3 使用 Linux LVM](#833-使用-linux-lvm)
- [第 9 章 安装软件程序](#第-9-章-安装软件程序)
  - [9.1 包管理基础](#91-包管理基础)
  - [9.2 基于 Debian 的系统](#92-基于-debian-的系统)
    - [9.2.1 用 aptitude 管理软件包](#921-用-aptitude-管理软件包)
    - [9.2.2 用 aptitude 安装软件包](#922-用-aptitude-安装软件包)
    - [9.2.3 用 aptitude 更新软件](#923-用-aptitude-更新软件)
    - [9.2.4 用 aptitude 卸载软件](#924-用-aptitude-卸载软件)
    - [9.2.5 aptitude 仓库](#925-aptitude-仓库)
  - [9.3 基于 Red Hat 的系统](#93-基于-red-hat-的系统)
    - [9.3.1 列出已安装包](#931-列出已安装包)
    - [9.3.3 用 yum 更新软件](#933-用-yum-更新软件)
    - [9.3.4 用 yum 卸载文件](#934-用-yum-卸载文件)
    - [9.3.5 处理损坏的包依赖关系](#935-处理损坏的包依赖关系)
    - [9.3.6 yum 软件仓库](#936-yum-软件仓库)
  - [9.4 从源码安装](#94-从源码安装)

<!-- /TOC -->

## 7.1 Linux 的安全性

Linux 安全系统的核心是用户账户。     

用户权限是通过创建用户时分配的用户 ID 来跟踪的。UID 是数值。    

Linux 系统使用特定的文件和工具来跟踪和管理系统上的用户账户。   

### 7.1.1 /etc/passed 文件

Linux系统使用一个专门的文件来将用户的登录名匹配到对应的UID值。这个文件就是
/etc/passwd文件,它包含了一些与用户有关的信息。    

root 用户账户是 Linux 系统的管理员，固定分配给它的 UID 是 0.系统会为各种各样的功能创建不同
的用户账户，而这些账户并不是真的用户。这些账户叫做 **系统账户**，是系统上运行的各种服务进程访问
资源用的特殊账户。所有运行在后台的服务都需要用一个系统用户账户登录到 Linux 系统上。    

Linux 为系统账户预留了 500 以下的 UID 值。/etc/passwd 文件的字段包含了如下信息：   

+ 登录用户名
+ 用户密码
+ 用户账户的 UID
+ 用户账户的组 ID，GID
+ 用户账户的文本描述
+ 用户 HOME 目录的位置
+ 用户的默认 shell    

大多数 Linux 系统都将用户密码保存在单独的文件中 /etc/shadow。只有特定的程序才能访问这个文件。   

### 7.1.2 /etc/shadow 文件

只有 root 用户才能访问 /etc/shadow 文件。/etc/shadow 文件为系统上的每个用户账户都保存了
一条记录。    

```
rich:$1$.FfcK0ns$f1UgiyHQ25wrB/hykCn020:11627:0:99999:7:::
```    

在 /etc/shadow 文件的每个记录中都有 9 个字段：   

+ 与 /etc/passwd 文件中登录名字段对应的登录名
+ 加密后的密码
+ 自上次修改密码后过去的天数（自 1970 年 1 月 1日开始计算）
+ 多少天后才能修改密码
+ 多少天后必须更改密码
+ 密码过期前提前多少天提醒用户更改密码
+ 密码过期后多少天禁用用户账户
+ 用户账户被禁用的日期（用自 1970 年 1月1日到当天的天数表示）
+ 预留字段    

### 7.1.3 添加新用户

用来向 Linux 系统添加新用户的主要工具是 `useradd`。`useradd` 命令使用系统的默认值以及命令行
参数来设置用户账户。系统默认值被设置在 /etc/default/useradd 文件中。可以使用加入了 -D 选项
的 `useradd` 命令查看所用 Linux 系统中的这些默认值。    

```bash
$ useradd -D
GROUP=100
HOME=/home
INACTIVE=-1
EXPIRE=
SHELL=/bin/sh
SKEL=/etc/skel
CREATE_MAIL_SPOOL=no
```     

这个例子列出的默认值如下：   

+ 新用户会被添加到 GID 为 100 的公共组
+ 新用户的 HOME 目录将会位于 /home/loginname
+ 新用户账户密码在过期后不会被禁用
+ 新用户账户未被设置过期日期
+ 新用户账户使用 shell 作为默认 shell
+ 系统会将 /etc/skel 目录下的内容复制到用户的 HOME 目录下
+ 系统不会为该用户账户在 mail 目录下创建一个用于接收邮件的文件    

```bash
$ useradd -m test
```   

默认情况下，`useradd` 命令不会创建 HOME 目录，但是 `-m` 选项会使其创建 HOME 目录。   


参数 | Column C
----------|---------
 -c comment | 给新用户添加备注
 -d home_dir | 为主目录指定一个名字（如果不想用登录名作为主目录名的话）
 -e expire_date | 用 YYYY-MM-DD 格式指定一个账户过期的日期
 -f inactive_days | 指定这个账户密码过期后多少天被禁用；0 表示密码一过期就立即禁用，-1 表示禁用这个功能
 -g initial_group | 指定用户登录组的 GID 或组名
 -G group ... | 指定用户除登录组之外所属的一个或多个附加组
 -k | 必须和 -m 一起使用，将 /etc/skel 目录的内容复制到用户的 HOME 目录
 -m | 创建用户的 HOME 目录
 -n | 创建一个与用户登录名同名的新组
 -r | 创建系统账户
 -p passwd | 为用户账户指定默认密码
 -s shell | 指定 shell
 -u uid | 指定 UID

### 7.1.4 删除用户

`userdel` 删除用户，删除 /etc/passwd 文件中的用户信息，而不会删除系统中属于该账户的任何文件。
如果加上 `-r` 参数，会删除用户的 HOME 目录以及邮件目录。    

### 7.1.5 修改用户

**usermod**     

`usermod` 能用来修改 /etc/passwd 文件中的大部分字段，只需用与想修改的字段对应的命令行参数就
可以了。参数大部分与 `useradd` 命令的参数一样。除此之外，还有另外的一些选项：   

+ `-l` 修改用户账户的登录名
+ `-L` 锁定账户，使用户无法登录
+ `-U` 解除锁定

**passwd 和 chpasswd**    

```bash
$ passwd test
```     

如果只用 `passwd` 命令，它会改你自己的密码。只有 root 用户才有权限改别人的密码。    

`-e` 选项能强制用户下次登录时修改密码。你可以先给用户设置一个简单的密码，之后再强制在下次登录时
改成他们能记住的更复杂的密码。    

如果需要为系统中的大量用户修改密码，`chpasswd` 命令可以事半功倍。`chpasswd` 命令能从标准输入
自动读取登录名和密码对（由冒号分割）列表，给密码加密，然后为用户账户设置。    

**chsh, chfn 和 chage**      

`chsh` 用来修改默认登录 shell。使用时必须用 shell 的全路径名作为参数。      

```bash
# chsh -s /bin/bash
```   

`chfn` 命令提供了在 /etc/passwd 文件的备注字段中存储信息的标准方法。    

`chage` 用来帮助管理用户账户的有效期。    

+ `-d`: 设置上次修改密码到现在的天数
+ `-E`: 设置密码过期日期
+ `-I`: 设置密码过期到锁定账户的天数
+ `-m`: 设置修改密码之间最少要多少天
+ `-W`: 设置密码过期前多久开始出现提醒信息     

`chage` 命令的日期值可以用 YYYY-MM-DD 也可以用 1970.1.1 到该天的数值。    

## 7.2 使用 Linux 组

### 7.2.1 /etc/group 文件

/etc/grouo 文件有 4 个字段：   

+ 组名
+ 组密码
+ GID
+ 属于该组的用户列表

当一个用户在 /etc/passwd 文件中指定某个组作为默认组时，用户账户不会作为该组成员再出现在 /etc/group
文件中。    

### 7.2.2 创建新组

`groupadd` 创建新组。使用 `usermod` 将用户添加到组里。如果加了 `-g` 选项，指定的组名会替换
掉该账户的默认组。-G 选项则将该组添加到用户的属组的列表里，不会影响默认组。   

### 7.2.3 修改组

`groupmod` 命令可以修改已有组的 GID（`-g`）或组名（`-n`）。    

## 7.3 理解文件权限

### 7.3.2 默认文件权限

`umask` 命令用来设置所创建文件和目录的默认权限：   

```bash
$ umask
0002
```    

第一位代表了一项特别的安全特性，叫做 **粘着位**(sticky bit)。    

要把 umask 值从对象的全权限值中减掉。对文件来说，全权限值是 666（所有用户都有读和写的权限）；
而对目录来说，则是 777（所有用户都有读、写、执行权限）。    

在大多数的 Linux 发行版中，umask 值通常会设置在 /etc/profile 启动文件中，不过有一些是设置
在 /etc/login.defs 文件中的。可以用 `umask` 命令为默认的 umask 设置指令的一个新值。    

```bash
$ umask 026
```  

## 7.4 改变安全性设置

### 7.4.1 改变权限

`chmod` 命令用来改变文件和目录的安全性设置：    

```bash
# chmod options mode file
```    

mode 参数可以使用八进制模式或符号模式进行安全性设置。    

`-R` 选项可以让权限的改变递归地作用到文件和子目录。   

### 7.4.2 改变所属关系

`chown` 命令用来改变文件的属主，`chgrp` 命令用来改变文件的默认属组。   

```bash
# chown options owner[.group] file
```   

可用登录名或 UID。   

## 7.5 共享文件

Linux 为每个文件和目录存储了 3 个额外的信息位：   

+ **设置用户 ID（SUID）**：当文件被用户使用时，程序会以文件属主的权限运行
+ **设置组 ID（SGID）**：对文件来说，程序会以文件属组的权限运行；对目录来说，目录中创建的新文件
会以目录的默认属组作为默认属组
+ **粘着位**：进程结束后文件还驻留在内存中。   

SGID可通过 chmod 命令设置。它会加到标准3位八进制值之前(组成4位八进制值),或者在
符号模式下用符号 s 。    


二进制值 | 八进制值 | 描述
---------|----------|---------
 000 | 0 | 所有位清零
 001 | 1 | 粘着位清零
 010 | 2 | SGID 位置位
 011 | 3 | SGID位和粘着位都置位
 100 | 4 | SUID 为置位

表格里剩下的略了。    

# 第 8 章 管理文件系统

## 8.1 探索 Linux 文件系统

### 8.1.1 基本的 Linux 文件系统

**ext文件系统**    

Linux操作系统中引入的最早的文件系统叫作扩展文件系统 (extended filesystem,简记为ext)。
它为Linux提供了一个基本的类Unix文件系统:使用虚拟目录来操作硬件设备,在物理设备上按
定长的块来存储数据。     

ext文件系统采用名为索引节点的系统来存放虚拟目录中所存储文件的信息。索引节点系统
在每个物理设备中创建一个单独的表(称为索引节点表)来存储这些文件的信息。存储在虚拟目
录中的每一个文件在索引节点表中都有一个条目。ext文件系统名称中的extended部分来自其跟踪
的每个文件的额外数据,包括:     

+ 文件名
+ 文件大小
+ 文件的属主
+ 文件的属组
+ 文件的访问权限
+ 指向存有文件数据的每个硬盘块的指针    

Linux 通过唯一的数值（称为 **索引节点号**）来引用索引节点表中的每个索引节点。    

**ext2文件系统**    

ext2文件系统扩展了索引节点表的格式来保存系统上每个文件的更多信息。ext2的索引节点表为文件添加了
创建时间值、修改时间值和最后访问时间值来帮助系统管理员追踪文件的访问情况。    

### 8.1.2 日志文件系统

日志文件系统为Linux系统增加了一层安全性。它不再使用之前先将数据直接写入存储设备
再更新索引节点表的做法,而是先将文件的更改写入到临时文件(称作 **日志**,journal)中。在数
据成功写到存储设备和索引节点表之后,再删除对应的日志条目。    

如果系统在数据被写入存储设备之前崩溃或断电了,日志文件系统下次会读取日志文件并处
理上次留下的未写入的数据。     

Linux 中有 3 中广泛使用的日志方法，每种的保护等级都不相同。   

+ **数据模式**：索引节点和文件都会被写入日志；丢失数据风险低，但性能差
+ **有序模式**：只有索引节点数据会被写入日志，但只有数据成功写入后才删除；在性能和安全性之间取得了
良好的折中
+ **回写模式**：只有索引节点数据会被写入日志，但不控制文件数据何时写入；丢失数据风险高    

数据模式日志方法是目前为止最安全的数据保护方法,但同时也是最慢的。所有写到存储设
备上的数据都必须写两次:第一次写入日志,第二次写入真正的存储设备。    

**ext3文件系统**     

它采用和ext2文件系统相同的索引节点表结构,但给每个存储设备增加了一个日志文件,
以将准备写入存储设备的数据先记入日志。     

默认情况下,ext3文件系统用有序模式的日志功能——只将索引节点信息写入日志文件,直
到数据块都被成功写入存储设备才删除。你可以在创建文件系统时用简单的一个命令行选项将
ext3文件系统的日志方法改成数据模式或回写模式。    

**ext4文件系统**    

除了支持数据压缩和加密,ext4文件系统还支持一个称作区段(extent)的特性。区段在存储
设备上按块分配空间,但在索引节点表中只保存起始块的位置。由于无需列出所有用来存储文件中数据的数据块,
它可以在索引节点表中节省一些空间。    

**XFS文件系统**    

XFS文件系统采用回写模式的日志,在提供了高性能的同时也引入了一定的风险,因为实际
数据并未存进日志文件。XFS文件系统还允许在线调整文件系统的大小,这点类似于ReiserFS文
件系统,除了XFS文件系统只能扩大不能缩小。     

## 8.2 操作文件系统

### 8.2.1 创建分区

`fdisk` 工具用来帮助管理安装在系统上的任何存储设备的分区。它是个交互式程序。   

要启动 `fdisk` 命令，你必须指定要分区的存储设备的设备名，另外还得有超级用户权限。    

fdisk 交互式命令提示符使用单字母命令来告诉 fdisk 做什么：   

+ a：设置活动分区标志
+ b：编辑 BSD Unix 系统用的磁盘标签
+ c：设置 DOS 兼容标志
+ d：删除分区
+ l：显示可用的分区类型
+ m：显示命令选项
+ n：添加一个新分区
+ o：创建 DOS 分区表
+ p：显示当前分区表
+ u：改变使用的存储单位
+ v：验证分区表
+ w：将分区表写入磁盘
+ x：高级功能

### 8.2.2 创建文件系统

在将数据存储到分区之前,你必须用某种文件系统对其进行格式化,这样Linux才能使用它。每种文件系统类型
都用自己的命令行程序来格式化分区。     


工具 | 用途
----------|---------
 mkefs | 创建一个 ext 文件系统
 mke2fs | 创建一个 ext2 文件系统
 mkfs.ext3 | 创建一个 ext3 文件系统
 mkfs.ext4 | 创建一个 ext4 文件系统
 mkreiserfs | 创建一个 ReiserFS 文件系统
 mkfs.xfs | 创建一个 XFS 文件系统

```bash
$ sudo mkfs.ext4 /dev/sdb1
```    

为分区创建了文件系统之后，下一步是将它挂载到虚拟目录下的某个挂载点，这样就可以将数据存储在新文件
系统中。     

### 8.2.3 文件系统的检查和修复

`fsck` 命令能够检查和修复大部分类型的 Linux 文件系统：   

```bash
$ fsck options filesystem
```    

你可以在命令行上列出多个要检查的文件系统。文件系统可以通过设备名、在虚拟目录中的挂载点以及分配给
文件系统的唯一 UUID 值来引用。    

`fsck` 命令使用 /etc/fstab 文件来自动决定正常挂载到系统上的存储设备的文件系统。   

## 8.3 逻辑卷管理

如果用标准分区在硬盘上创建了文件系统,为已有文件系统添加额外的空间多少是一种痛苦
的体验。你只能在同一个物理硬盘的可用空间范围内调整分区大小。如果硬盘上没有地方了,你
就必须弄一个更大的硬盘,然后手动将已有的文件系统移动到新的硬盘上。     

这时候可以通过将另外一个硬盘上的分区加入已有文件系统,动态地添加存储空间。Linux
逻辑卷管理器(logical volume manager,LVM)软件包正好可以用来做这个。它可以让你在无需
重建整个文件系统的情况下,轻松地管理磁盘空间。     

### 8.3.1 逻辑卷管理布局

逻辑卷管理的核心在于如何处理安装在系统上的硬盘分区。在逻辑卷管理的世界里，硬盘分区称作 **物理卷**
（physical volume, PV）。每个物理卷都会映射到硬盘上特定的物理分区。   

多个物理卷集中在一起可以形成一个 **卷组**（volume group, VG）。逻辑卷管理系统将卷组视为一个
物理硬盘，但事实上卷组可能是由分布在多个物理硬盘上的多个物理分区组成的。卷组提供了一个创建逻辑分区
的平台，而这些逻辑分区则包含了文件系统。   

整个结构中的最后一层是 **逻辑卷**（logical volume, LV）。逻辑卷为 Linux 提供了创建文件系统的
分区环境，作用类似于到目前为止我们一直在探讨的 Linux 中的物理硬盘分区。Linux 将逻辑卷视为物理分区。   

可以使用任意一种标准Linux文件系统来格式化逻辑卷,然后再将它加入Linux虚拟目录中的
某个挂载点。    

![lvm](https://raw.githubusercontent.com/temple-deng/markdown-images/master/linux/lvm.png)    

如果你给系统添加了一块硬盘,逻辑卷管理系统允许你将它添加到已有卷组,为某
个已有的卷组创建更多空间,或是创建一个可用来挂载的新逻辑卷。    

### 8.3.2 Linux 中的 LVM

除了标准的逻辑卷管理功能，LVM2 还提供了另外一些好用的功能。   

**快照**    

最初的 Linux LVM 允许你在逻辑卷在线的情况下将其复制到另一个设备。这个功能叫做 **快照**。传统
的备份方法在将文件复制到备份媒体上时通常要将文件锁定。快照允许你在复制的同时，保证运行关键任务的
Web 服务器或数据库服务器继续工作。     

**条带化**    

有了条带化，可跨多个物理硬盘创建逻辑卷。当 Linux LVM 将文件写入逻辑卷时，文件中的数据块会被
分散到多个硬盘上。每个后继数据块会被写到下一个硬盘上。    

条带化有助于提高硬盘的性能，因为 Linux 可以将一个文件的多个数据块同时写入多个硬盘，而无需等待
单个硬盘移动读写磁头到多个不同位置。    

**镜像**     

镜像是一个实时更新的逻辑卷的完整副本。当你创建镜像逻辑卷时，LVM 会将原始逻辑卷同步到镜像副本中。
根据原始逻辑卷的大小，这可能需要一些时间才能完成。    

一旦原始同步完成,LVM会为文件系统的每次写操作执行两次写入——一次写入到主逻辑
卷,一次写入到镜像副本。可以想到,这个过程会降低系统的写入性能。    

### 8.3.3 使用 Linux LVM

**1. 定义物理卷**    

创建过程的第一步就是将硬盘上的物理分区转换成 LVM 使用的物理卷区段。使用 `fdisk` 完成，在创建了
基本的 Linux 分区之后，需要通过 `t` 命令改变分区类型。     

```bash
[...]
Command (m for help): t
Selected partition 1
Hex code (type L to list codes): 8e
Changed system type of partition 1 to 8e (Linux LVM)
```    

分区类型 8e 表示这个分区将会被用作 LVM 系统的一部分。    

下一步就是用分区来创建实际的物理卷。这可以通过 `pvcreate` 命令来完成。    

```bash
$ sudo pvcreate /dev/sdb1
```    

如果你想查看创建进度的话，可以使用 `pvdisplay` 命令来显示已创建的物理卷列表：   

```bash
$ sudo pvdisplay /dev/sdb1
```    

**2. 创建卷组**    

下一步是从物理卷中创建一个或多个卷组。使用 `vgcreate`。    

```bash
$ sudo vgcreate Vol1 /dev/sdb1
```   

查看细节 `vgdisplay`。    

**创建逻辑卷**    

Linux 系统使用逻辑卷来模拟物理分区。要创建逻辑卷，使用 `lvcreate` 命令。    


选项 | 长选项名 | 描述
---------|----------|---------
 -c | --chunksize | 指定快照逻辑卷的单位大小
 -C | --contiguous | 设置或重置连续分配策略
 -i | --stripes | 指定条带数
 -I | --stripesize | 指定每个条带的大小
 -l | --extents | 指定分配给新逻辑卷的逻辑区段数，或者要用的逻辑区段的百分比
 -L | --size | 指定分配给新逻辑卷的硬盘大小
 -L | --minor | 指定设备的次设备号
 -m | --mirrors | 创建逻辑卷镜像
 -M | --persistent | 让次设备号一直有效
 -n | --name | 指定新逻辑卷的名称
 -p | --permission | 为逻辑卷设置读/写权限
 -r | --readahead | 设置预读扇区数
 -R | --regionsize | 指定将镜像分成多大的区
 -s | snapshot | 创建快照逻辑卷

**4. 创建文件系统**    

略。    

# 第 9 章 安装软件程序

## 9.1 包管理基础

各种主流 Linux 发行版都采用了某种形式的包管理系统来控制软件和库的安装。PMS 利用一个数据库来记录
各种相关内容：   

+ Linux 系统上已安装了什么软件包
+ 每个包安装了什么文件
+ 每个已安装软件包的版本    

软件包存储在服务器上，可以利用本地 Linux 系统上的 PMS 工具通过互联网访问。这些服务器称为
**仓库**(repository)。可以用 PMS 工具来搜素新的软件包，或者是更新系统上已安装的软件包。   

软件包通常会依赖其他的包，为了前者能够正常运行，被依赖的包必须提前安装在系统中。PMS 工具将会检测
这些依赖关系，并在安装需要的包之前先安装号所有额外的软件包。    

Linux 中广泛使用的两种主要 PMS 基础工具是 dpkg 和 rpm。   

## 9.2 基于 Debian 的系统

`dpkg` 命令是基于 Debian 系 PMS 工具的核心。包含在这个 PMS 中的其他工具有：   

+ `apt-get`
+ `apt-cache`
+ `aptitude`    

到目前为止，最常用的命令行工具是 `aptitude`，这是有原因的。`aptitude` 工具本质上是 apt 工具
和 dpkg 的前端。    

### 9.2.1 用 aptitude 管理软件包

如果使用的Linux发行版中已经安装了aptitude,只需要在shell提示符键入 aptitude 并按下回
车键就行了。紧接着就会进入aptitude的全屏模式。    

如果你已经知道了系统上的那些软件包，只想快速显示某个特定包的详细信息，就没必要到 `aptitude`
的交互式界面。可以在命令行下以单个命令的方式使用 `aptitude`:   

```bash
$ aptitude show package_name
```    

### 9.2.2 用 aptitude 安装软件包

怎么才能找到特定的软件包呢？用 aptitude 命令加 search 选项。    

```bash
$ aptitude search package_name
```    

在每个包名字之前都有一个 p 或 i。如果看到一个 i，说明这个包现在已经安装到你的系统上了。如果看到
一个 p 或 v，说明这个包可用，但还没安装。    

在系统上用 aptitude 从软件仓库中安装软件包非常简单。   

```bash
$ aptitude install package_name
```    

### 9.2.3 用 aptitude 更新软件

要用软件仓库中的新版本妥善地更新系统上的所有软件包，可用 `safe-upgrade` 选项。   

```bash
$ aptitude safe-upgrade
```     

### 9.2.4 用 aptitude 卸载软件

如果只想删除软件包而不删除数据和配置文件，可以使用 `aptitude` 的 `remove` 选项。要删除软件
包和相关的数据和配置文件，可用 `purge` 选项。    

### 9.2.5 aptitude 仓库

aptitude 默认的软件仓库是在安装 Linux 发行版时设置的。具体位置存储在文件 /etc/apt/sources.list
中。如果需要为你的 PMS 添加一些额外的软件仓库，就在这个文件中设置吧。    

使用下面的结构来指定仓库源：   

```
deb (or deb-src) address distribution_name package_type_list
```    

deb 或 deb-src 的值表明了软件包的类型。deb 值说明这是一个已编译的程序源，而 deb-src 值则说明
这是一个源代码的源。    

address 条目是软件仓库的 Web 地址。distribution_name 条目是这个特定软件仓库的发行版版本的
名称。     

最后，package_type_list 条目可能不止一个词，它还表明仓库里面有什么类型的包。可以看到诸如
main, restricted, universe 和 partner 这样的值。    

## 9.3 基于 Red Hat 的系统

### 9.3.1 列出已安装包

```bash
$ yum list installed
```    

还可以查看包是否已安装：   

```bash
$ yum list xterm
```    

也可以手动下载 rpm 安装文件并用 yum 安装，这叫做 **本地安装**：   

```bash
$ yum localinstall package_name.rpm
```    

### 9.3.3 用 yum 更新软件

```bash
$ yum list updates
```   

列出所有已安装包的可用更新。    

```bash
$ yum update package_name
$ yum update
```    

### 9.3.4 用 yum 卸载文件

```bash
$ yum remove package_name
$ yum erase package_name
```    

### 9.3.5 处理损坏的包依赖关系

有时在安装多个软件包时,某个包的软件依赖关系可能会被另一个包的安装覆盖掉。这叫作
损坏的包依赖关系(broken dependency)。     

略。    

### 9.3.6 yum 软件仓库

yum 的仓库定义文件位于 /etc/yum.repos.d。     

## 9.4 从源码安装

```bash
$ ./configure
```    

下一步就是用 make 命令来构建各种二进制文件。make 命令来构建各种二进制文件，make 命令会编译
源码，然后链接器会为这个包创建最终的可执行文件。    

make 步骤结束后，可运行的软件程序会出现在目录下，但是从那个目录运行程序有些不便，你会想将它安装
到 Linux 系统中常用的位置上。要这样的话，必须以 root 身份执行 `make install`。    

Last Update: 2018.12.1