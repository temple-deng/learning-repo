# 第 8 章 多处理机系统


<!-- TOC -->

- [第 8 章 多处理机系统](#第-8-章-多处理机系统)
  - [8.1 多处理机](#81-多处理机)
    - [8.1.1 多处理机硬件](#811-多处理机硬件)
  - [8.2 多计算机](#82-多计算机)
    - [8.2.1 多计算机硬件](#821-多计算机硬件)
    - [8.2.3 用户层通信软件](#823-用户层通信软件)
    - [8.2.4 远程过程调用](#824-远程过程调用)
    - [8.2.5 分布式共享存储器](#825-分布式共享存储器)
  - [8.3 分布式系统](#83-分布式系统)
    - [8.3.3 基于文档的中间件](#833-基于文档的中间件)
    - [8.3.4 基于文件系统的中间件](#834-基于文件系统的中间件)
    - [8.3.5 基于对象的中间件](#835-基于对象的中间件)

<!-- /TOC -->

本章介绍了三种不同模型的多处理机系统，第一种是多个 CPU 之间通过一个共享存储器通信。第二种是许多
CPU-存储器通过某种高速互联网络连接在一起。这种系统称为消息传递型多计算机。最后一种就是所有的计算机
系统通过一个广域网连接起来，如因特网，构成了一个 **分布式系统**。第二种与第三种的区别是，后者使用了
完整的计算机而且消息传递时间通常需要10～100ms。如此长的延迟造成使用这类 **松散耦合**系统的方式和
第二种的 **紧密耦合**系统不同。    

## 8.1 多处理机

**共享存储器多处理机**是这样的一种计算机系统，其两个或更多的 CPU 全部共享访问一个公用的 RAM。运行
在任何一个 CPU 上的程序都看到一个普通的虚拟地址空间。这个系统唯一特别的性质是，CPU 可对存储器的某个字
写入某个值，然后读回改字，并得到一个不同的值（因为另一个 CPU 改写了它）。在进行恰当组织时，这种
性质构成了处理器间通信的基础：一个CPU 向存储器写入某些数据而另一个读取这些数据。    

至于最重要的部分，多处理机操作系统只是通常的操作系统,。它们处理系统调用，进行存储器管理，提供文件
系统并管理I/O 设备。不过，在某些领域里它们还是有一些独特的性质。这包括进程同步、资源管理以及调度。
下面先概要地介绍多处理机硬件，然后进入有关操作系统的问题。    

这个其实和我们现在的多核处理器好像类似啊，大家共享一个内存。   

### 8.1.1 多处理机硬件

所有的多处理机都具有每个 CPU 可访问全部存储器的性质，而有些多处理机仍有一些其他的特性，即读出每个
存储字的速度是一样快的。这些机器称为 UMA（Uniform Memory Access, 统一存储器访问）多处理机。相反，
NUMA（Nonuniform Memory Access, 非一致存储器访问）多处理机就没有这种特性。    

+ **基于单总线的 UMA 多处理机体系结构**    

最简单的多处理机是基于单总线的，两个或多个 CPU 以及一个或多个存储器模块都使用同一总线进行通信。当一个
CPU 需要读一个存储器字时，它首先检查总线忙否。如果总线空闲，该 CPU 把所需字的地址放到总线上，发出
若干控制信号，然后等待存储器把所需的字放到总线上。    

当某个 CPU 需要读写存储器时，如果总线忙，CPU 只是等待，直到总线空闲。这种系统完全受到总线带宽的限制，
多数 CPU 在大部分时间是空闲的。    

这一问题的解决方案是为每个 CPU 添加一个高速缓存。这个高速缓存可以位于 CPU 芯片的外部、CPU 附近、
在处理器板上或所有这三种方式的组合。由于许多读操作可以从本地高速缓存上得到满足，总线流量就大大减少了，
这样系统能够支持更多的 CPU。一般而言，高速缓存不以单个字为基础，而是以32字节或64字节块为基础。
当引用一个字时，它所在的整个数据块（叫作一个 **cache行**）被取到使用它的 CPU 的高速缓存中。       

每一个高速缓存块或者被标记为只读（这种情况下，它可以同时存在于多个高速缓存中），或者被标记为读写
（这种情况下，它不能在其他高速缓存中存在）。如果 CPU 试图在一个或多个远程高速缓存中写入一个字，
总线硬件检测到写，并把一个信号放到总线上通知所有其他的高速缓存。（那其实这种情况，说明这个字应该
是之前被多个 CPU 取进高速缓存进行读操作）
如果其他高速缓存有个“干净”的副本，也就是同存储器内容完全一样的副本，那么它们可以丢弃该副本并让写者在修改
之前从存储器取出高速缓存块（也就是存储器上的数据还是最新的，所以从存储器上读出数据，然后做出修改）。
如果某些其他高速缓存有“脏”的副本，它必须在处理写之前把数据写回存储器或者把它通过总线直接传送到写者上。
（这样写者在实际写之前拿到的是最新的数据）高速缓存这一套规则被称为 **高速缓存一致性协议**。    

+ **使用交叉开关的 UMA 多处理机**     

交叉开关的最好一个特性是它是一个 **非阻塞网络**，即不会因有交叉点或连线已经被占据了而拒绝连接。    

+ **使用多级交换网络的 UMA 多处理机**    

看书去吧，说不清楚。    

+ **NUMA 多处理机**    

剩下的都不讲了，太难了，这太难了。     


## 8.2 多计算机

多计算机容易构造，因为其基本部件只是一台配有高性能网络接口卡的PC裸机，没有键盘、鼠标或显示器。    

### 8.2.1 多计算机硬件

下面介绍多计算机系统是如何组织的。    

+ **互连技术**    

在每个节点上有一块网卡，带有一根或两根从网卡上接出的电缆（或光纤）。这些电缆或者连接到其他的节点上，
或者连到交换机上。    

在计算机中的数据交换可采用两种交换机制。在第一种机制里，每个消息首先被分解（由用户软件或网络接口）成为
有最大长度限制的块，称为**包**。该交换机制称为**存储转发包交换**。尽管存储转发包交换灵活且有效，但是它存在通过互联网络时增加时延的问题。    

另一种交换机制是**电路交换**，它包括由第一个交换机建立的，通过所有交换机而到达目标交换机的一条路径。一旦路径
建立起来，比特流就从源到目的地通过整个路径不断地尽快输送。在所涉及的交换机中，没有中间缓冲。    

+ **网络接口**    

在多计算机中，所有节点里都有一块插卡板，它包括节点与互连网络的连接。接口板上都有一些用来存储进出包的
RAM。通常，在包被传送到第一个交换机之前，这个要送出的包必须被复制到接口板的 RAM 中。这样设计的原因是
许多互连网络是同步的，所以一旦一个包的传送开始，比特流必须以恒定的速率连续进行。如果包在主 RAM 中，由于
内存总线上有其他的信息流，所以这个送到网络上的连续流是不能保证的。     

### 8.2.3 用户层通信软件

在多计算机中，不同 CPU 的进程通过互相发送消息实现通信。    

+ **发送和接收**    

在最简化的情形下，所提供的通信服务可以减少到两个（库）调用，一个用于发送消息，另一个用于接收消息。发送一条
消息可能是 `send(dest, &mptr)` 而接收消息可能是 `receive(addr, &mptr)`。   

前者把由 &mptr 参数所指向的消息发送给由 dest 参数所标识的进程，并且引起对调用者的阻塞，直到该消息被发出。
后者引起对调用者的阻塞，直到消息到达。该消息到达后，被复制到由 mptr 参数所指向的缓冲区，并且撤销对
调用者的阻塞。    

+ **阻塞调用和非阻塞调用**    

上面所叙述的调用是阻塞调用。当一个进程调用 send 时，它指定一个目标以及发送消息到该目标的一个缓冲区。当消息
发送时，发送进程被阻塞。在消息已经完全发送出去之前，不会执行跟随在调用 send 后面的指令。   

相对于阻塞调用的另一种方式是**非阻塞调用**。如果send 是非阻塞的，在消息发出之前，它立即将控制返回给
调用者。这种机制的优点是发送进程可以继续运算，与消息传送并行，而不是让 CPU 空闲（假设没有其他可运行
的进程）。    

但是，非阻塞原语所提供的性能优点被其严重的缺点所抵消了：直到消息被送出发送者才能修改消息缓冲区。然而，发送进程
不知道传输何时会结束，所以根本不知道什么时候重用缓冲区是安全的。    

有三种可能的解决方案。第一种是让内核复制这个消息到内部的内核缓冲区，然后让进程继续。   

第二种方案是，当消息发送之后中断发送者，告知缓冲区又可以使用了。这里不需要复制。从而节省了时间，
但是用户级中断使编写程序变得棘手。   

第三种方案是，让缓冲区写时复制，也就是说，在消息发送出去之前将其标记为只读。在消息发送出去之前，如果
缓冲区被重用，则进行复制。这个方案的问题时，触发缓冲区被孤立在自己的页面上。否则对临近变量的写操作
也会导致复制。    

### 8.2.4 远程过程调用

尽管消息传递模型提供了一种构造多计算机操作系统的便利方式，但是它有不可救药的缺陷：构造所有通信的笵型都是
输入/输出。过程send 和receive 基本上在做 I/O 操作，而许多人认为 I/O 就是一种错误的编程笵型。（所以
其实并没有说出这种方式为什么不好吧，就因为觉得人家模式错了就否定人家？）     

Birrell 和 Nelson 引进了一种完全不同的方法来解决这个问题，其建议是，允许程序调用位于其他 CPU 的过程。
当机器1的进程调用机器2的过程时，在机器1中的调用进程被挂起，在机器2中被调用的过程执行。可以在参数中传递从
调用者到被调用者的信息，并且可在过程的处理结果中返回信息（所以仍然需要消息传递模型，毕竟这应该是唯一的一种
多计算机间数据交换的方式）。根本不存在对程序员可见的消息传递或I/O（那这整个操作是由操作系统完成的吗？）。
这种技术既是所谓的**远程过程调用**（Remote Procedure Call, RPC），并且已经成为大量多计算机的软件的基础。
习惯上，称发出调用的进程为客户机，而称被调用的进程为服务器。     

RPC 背后的思想是尽可能使远程过程调用像本地调用。在最简单的情形下，要调用一个远程过程，客户程序必须被绑定在
一个称为**客户端存根**（client stub）的小型库过程上，它在客户机地址空间中代表服务器过程。类似地，服务器
程序也绑定在一个称为**服务器存根**（server stub）的过程上。    

进行 RPC 的步骤如下，第1步是客户机调用客户端存根。该调用是一个本地调用，其参数以通常方式压入栈内。第2步
是客户端存根将有关参数打包成一条消息，并进行系统调用来发出该消息。这个将参数打包的过程称为**编排**。第
3步是内核将消息从客户机发送给服务器。第4步是内核将接收进来的消息传送给服务器端存根。最后，第5步是
服务器端存根调用服务器过程。应答则是在相反的方向沿着同一步骤进行。     

这里需要说明的关键是由用户编写的客户机过程，只进行对客户端存根的正常（本地）调用，而客户端存根与服务器
过程同名。由于客户机过程和客户端存根在同一个地址空间，所以有关参数以正常方式传递。类似地，服务器过程
由其所在的地址空间中的一个过程用它所期望的参数进行调用。对服务器过程而言，一切都很正常。   

### 8.2.5 分布式共享存储器

很多程序员仍然偏爱共享存储器的模型，一种称为**分布式共享存储器**（Distributed Shared Memory, DSM）的技术，就有可能很好地保留共享存储器的幻觉，尽管这个共享存储器实际并不存在。有了 DSM，每台机器都有其自己的虚拟内存和和页表。当一个 CPU
在一个它并不拥有的页面上进行 LOAD 和 STORE 时，会陷入到操作系统当中。然后操作系统对该页面进行定位，并请求当前
持有该页面的 CPU 解除对该页面的映射并通过互连网络发送该页面。在页面到达时，页面被映射进来，于是出错指令
重新启动。     

+ **复制**    

对基本系统的一个改进是复制那些只读页面，如程序代码、只读常量或其他只读数据结构，它可以明显地提高性能。   

## 8.3 分布式系统

下面的表格比较了多处理机，多计算机和分布式系统。    


项目 | 多处理机 | 多计算机 | 分布式系统
---------|----------|---------|---------
 节点配置 | CPU | CPU、RAM、网路接口 | 完整的计算机 
 节点外设 | 全部共享 | 可能除了磁盘 | 每个几点全套外设
 位置 | 同一机箱 | 同一房间 | 可能全球
 节点间通信 | 共享 RAM | 专用互连 | 传统网络
 操作系统 | 一个，共享 | 多个，相同 | 可能都不相同
 文件系统 | 一个，共享 | 一个，共享 |  每个节点自有
 管理 | 一个机构 | 一个结构 | 多个机构   

分布式系统面对不同硬件和操作系统实现某种统一性的途径是，在操作系统的顶部加一层软件。这层软件叫做
**中间件**。这层软件提供了一些特定的数据结构和操作，从而允许散布的机器上的进程和用户用一致的方式互操作。   

### 8.3.3 基于文档的中间件

Web。    

### 8.3.4 基于文件系统的中间件

隐藏在 Web 背后的基本思想是，使一个分布式系统看起来像一个巨大的、超链接的集合。另一种处理方式则是使一个
分布式系统看起来像一个大型文件系统。   

分布式系统采用一个文件系统模型意味者只存在一个全局文件系统，全世界的用户都能够读写他们各自具有授权的文件。
通过一个进程将数据写入文件而另一个进程把数据读出的办法可以实现通信。由此产生了标准文件系统中的很多问题。   

+ **传输模式**   

第一个问题是，在**上传/下载模式**和**远程访问模式**之间的选择问题。在前一个模式中，通过把远程服务器
上的文件复制到本地的方法，实现进程对远程文件的访问。如果只是需要读该文件，考虑到高性能的需要，就在本地
读出该文件。如果需要写入该文件，就在本地写入。进程完成工作之后，把更新后的文件送回原来的服务器。在远程
访问模式中，文件停留在服务器上，而客户机向服务器发出命令并在服务器上完成工作。    

### 8.3.5 基于对象的中间件

现在让我们考察第三种范型。这里不再说一切都是文档或者一切都是文件，取而代之，我们会说一切都是对象。**对象**
是变量的集合，这些变量与一套称为**方法**的访问过程绑定在一起。进程不允许直接访问这些变量。相反，要求他们
调用方法来访问。    

一个知名的基于运行时对象的系统是**CORBA**（公共对象请求代理体系结构，Common Object Request
Broker Architecture）。CORBA 是一个客户机——服务器系统，其中在客户机上的客户进程可以调用位于（可能是远程）
服务器上的对象操作。CORBA 是为运行不同硬件平台和操作系统的异构系统设计的，并且用各种语言编写。为了使
在一个平台上的客户有可能使用在不同平台上的服务器，将ORB（对象请求代理，Object Request Broker）插入
到客户机和服务器之间，从而使它们相互匹配。    

对于 CORBA 而言，一个严重问题是每个 CORBA 对象只存在一个服务器上，这意味着那些在世界各地客户机上
被大量使用的对象，会有很差的性能。在实践中，CORBA 只在小规模系统才能有效工作，比如一个局域网中。    

