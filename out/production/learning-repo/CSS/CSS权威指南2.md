# 第 10 章 浮动及其形状    

## 10.1 浮动    

### 10.1.4 浮动元素与内容重叠    

- 行内框与浮动元素重叠时，其边框、背景和内容都在浮动元素"之上"渲染。    
- 块级框与浮动元素重叠时，其边框和背景在浮动元素"背后"渲染，而内容在浮动元素"之上"渲染。   

## 10.3 浮动形状   

`shape-image-threshold` 用于指定透明度多少时允许内容流入。    

# 第 11 章 定位    

## 11.9 sticky   

sticky 是相对于其包含块定位的，而不是视口。   

# 第 12 章 弹性盒布局    

## 12.2 弹性容器    

弹性容器中的绝对定位子元素也是弹性元素，不过确定其尺寸和位置时，将其视作弹性容器中唯一的弹性元素.    

## 12.6 对齐元素    

### 12.6.2 基线对齐    

baseline 值有点复杂，设为baseline 时，一行中的弹性元素向第一条基线对齐。弹性元素行中，基线与垂轴那一侧外边距
之间距离最远的弹性元素，其外边距的外边界与弹性元素行垂轴起边那一侧的边对齐，其他弹性元素的基线则与哪个弹性元素的
基线对齐。    

## 12.9 弹性元素    

### 12.9.2 弹性元素的特性    

绝对定位的弹性容器的子元素即受弹性容器的 justify-content 值影响，也受自身 align-self 值的影响。例如，如果在绝对定位的
子元素上设定 align-self: center，元素将相对弹性容器的垂轴居中，然后再使用 top，bottom，外边距等属性移动其位置。    

## 12.12 flex-grow 属性    

如果没有设定宽度或弹性基准，弹性基准默认为 auto，即各弹性元素的基准为内容不换行的宽度。auto 是个特殊的值，默认为 content，
但是如果设定了宽度，弹性基准为宽度。    

### 12.12.1 在 flex 属性中设定增长因子     

如果 flex 属性显示把弹性基准声明为 0%，或者默认为 0%，而且弹性元素的增长因子是0，那么尺寸不增加的弹性元素在主轴上的长度
将缩小为内容允许的最小长度，或者比这小一些。     

只要弹性元素明显有溢出，而且没有显示设定 min-width，那么弹性元素的最小宽度（或最小高度）为容下内容所需的最小宽度，或者是
声明的 width（或height），二者取较小的那个。    

如果所有弹性元素都允许增大，而且弹性基准都是 0%，那么所有空间，而不只是多出的空间，将根据增长因子确定的比例分配。    

## 12.13 flex-shrink 属性   

### 12.13.1 根据宽度和缩减因子按比例缩小    

弹性元素根据缩减因子和元素的宽度按比例缩小，这里所说的宽度通常指内容不换行时的宽度。    

### 12.14.5 零基准   

基准为 0 时，弹性容器的尺寸根据增长因子按比例分给各个弹性元素。此时，由 height, width 或 content 定义的主轴方向上，
的原尺寸不在考虑范围内，然而 min-width, min-height 和 max-width, max-height 对弹性尺寸有一定的影响。    

# 第 13 章 栅格元素    

## 13.3 放置栅格线   

### 13.3.2 弹性栅格轨道    

minmax() 表达式的最小值部分不允许使用 fr 单位，因此，使用 fr 设定最小值将导致整个声明失效。   

max-content 的意思是 "占据内容所需的最大空间"。对大段文本来说，这个值一般意味着尽量多占据可用空间，
为内容提供最大的空间。   

min-content 的意思是 "尽量少占据空间，够显示内容即可"，对文本来说，这意味着宽度会尽量收窄，只保证最长的单词能在一行里
完整显示。    

这两个关键字的强大之处在于，它们将应用于整个栅格轨道上，例如，如果把一列的尺寸设为 max-content，那么整个列轨道的宽度都
与列中最宽的内容一样。    

### 13.3.3 根据轨道中的内容适配    

```css
#grid {
    display: grid;
    grid-template-columns: 1fr fit-content(150px) 2fr;
}
```    

`fit-content(argument) = min(max-content, max(min-content, argument))`    

最大小于 max-content，但是最小大于 min-content。    

### 13.3.4 重复栅格线   

`grid-template-columns: repeat(auto-fill, [top] 5em [bottom]);`。自动重复的局限是，只能有一个可选的
栅格线名称、一个尺寸固定的轨道和另一个可选的栅格线名称。   

在一个轨道模板中只能有一个自动重复的模式，因此，下述写法是正确的。   

`grid-template-columns: repeat(auto-fill, 4em) repeat(auto-fill, 2em)`。    

auto-fill 至少会重复一次轨道模板，即使出于什么原因在栅格容器中放不下也是如此。而且，只要空间足够，能重复多少次就重复多少次。   

如果使用 auto-fit，没有栅格元素的轨道将会被剔除。     

```css
.box {
    grid-template-columns: 1fr [content-start] 1fr [content-end] 1fr;
    grid-template-rows: 3em 1fr 3em;
}
```    

这样也能创建名为 content 的栅格区域，只是该区域所在的行将放在显示定义的行之后。奇怪的是，在显示定义的行后面，
content 区域所在的行前面会多出一个空行。但这是符合规定的行为。因此，如果想通过命名栅格线创建具名区域，但不提供全部四条
栅格线，那么具名区域将偏安一隅，而不在栅格的整体结构中。   

## 13.4 放置栅格元素    

### 13.4.1 使用列线和行线    

浏览器遇到你提供的自定义标识符时会在名称后面加上 -start 或 -end，然后寻找对应名称的栅格线。   

### 13.4.2 行和列的简写属性   

如果值中没有斜线，那么定义的是开始栅格线，结束栅格线取决于开始栅格线的值，如果开始栅格线使用名称引用的，那么结束栅格线
也使用那个名称引用。因此，下面两个声明是等效的：   

```css
grid-column: col-B;
grid-column: col-B / col-B;
```    

### 13.4.3 隐式栅格    

跨度必定从显示栅格内部开始计数，但是不一定在显示栅格中结束。   

## 13.5 栅格流   

栅格流主要分为两种模式，即行优先和列优先，不过二者都可以通过密集流增强，栅格流通过 grid-auto-flow 属性设置。  

## 13.6 自动增加栅格线   

默认情况下，自动增加的行是所需的最小尺寸，如果想进一步控制尺寸，使用 grid-auto-rows 和 grid-auto-columns 属性。   

## 13.7 grid 简写属性    

说到底，grid 属性的作用是已简洁的句法定义栅格模板，或者设定栅格流，并为自动增加的轨道设定尺寸，但是二者不能同时设置。   

此外，未定义的值都重置为默认值，这与其他简写属性是一致的。因此，如果定义了栅格模板，那么栅格流和自动增加的轨道尺寸
都归为默认值。这其中包含我们还未谈及的栅格栏距。   

`grid: dense rows 2em / minmax(1em, 3em)`。    

# 第 14 章 CSS 中的表格布局    

## 14.1 表格中的层   

从下到上以此是，表格，列组，列，行组，行，单元格。    

## 14.2 单元格的边框    

在 CSS 中有两种完全不同的边框模型。分离边框模型在单元格布局之间有间隔时起作用，另一个选项是折叠边框模型，此时单元格之间
在视觉上没有间隔，单元格之间的边框将合成或折叠在一起，现在前者是默认模型。     

border-spacing 间隔值在表格外侧的单元格与 table 元素的内边距之间也存在。   

在分离边框模型中，不能为行、行组、列和列组设定边框。   

### 14.2.2 折叠单元格的边框   

- border-collapse 属性的值为 collapse 时，table 元素不能有内边距。
- 边框可以应用于单元格、行、行组、列和列组。当然，表格自身始终可以有边框。
- 在折叠边框模型中，单元格的边框之间肯定没有间隔。其实，边框在邻接处折叠在一起，因此只会绘制一跳折叠的边框。这与外边距折叠有点像，
即最大的外边距胜出。单元格的边框在折叠时，"占上风" 的边框胜出。
- 折叠的边框居中放在单元格之间假想的栅格线上。   

在这个模型中，表格边框的一半含在宽度之内，另一半边框在这个范围之外。位于外边距中。   

## 14.3 表格的尺寸

不管使用哪种方式确定宽度，表格的高度都自动计算。    

### 14.3.1 宽度    

用户代理在计算表格的布局时，固定宽度的表格布局要比自动宽度模型快一些。    

固定布局模型：   

- 如果列元素的 width 属性的值不是 auto，设定的值就是整列的宽度
- 如果列的宽度为 auto，但是表格第一行位于这一列的单元格的 width 属性不是 auto，那么这个单元格的宽度就是整列的宽度，如果这个单元格
跨多列，其宽度平分到各列中。
- 如果列的宽度仍是自动确定的，将自动确定，尽可能保持各列宽度相等   

经过上述过程处理之后，表格的宽度将被设为表格的 width 值和各列宽度之和中较大的那个，如果表格宽度比列的宽度之和打，二者之差除以列数
等到的结果将增加到各列上。   

自动布局模型：   

1. 计算一列中每个单元格的最小宽度和最大宽度
   - 确定显示内容最少需要多少宽度，在这个过程中，内容可以换行，但是不能超出单元格框，如果为单元格设定了 width 值，而且比最小宽度大，
    那么单元格的最小宽度将被设为 width 值，如果单元格的 width 值为 auto，那么单元格的最小宽度将被设为内容的最小宽度
   - 最大宽度即不换行显示内容所需的宽度
2. 计算各列的最小宽度和最大宽度
   - 列的最小宽度由那一列中单元格最小宽度值最大的那个确定。如果为列显示设置了 width 值，且比最小宽度值最大的那个大，那么列的最小宽度
    将被设为 width 的值
   - 列的最大宽度等于那一列中单元格最大宽度值最大的那个。如果为列显式设定了 width 值，而且比列中每个单元格的最大宽度都大，那么列的
    最大宽度就被设为 width 值。    

至此，用户代理已经知道每一列有多宽了，得到这些信息之后，用户代理才真正开始计算表格的宽度，具体步骤如下：   

- 如果表格宽度的计算值不是 auto，比较表格宽度的计算值和每一列的宽度之和加上边框和单元格间距。二者中较大的那个就是表格的最终宽度，如果表格
宽度的计算值比这个和大，差值除以列数后得到的值将增加到各列上。
- 如果表格宽度计算值是 auto，表格最终宽度等于列宽度，边框和间距之和。   

# 第 16 章 变形   

## 16.3 其他变形属性   

### 16.3.3 修改视域   

视域其实由两个属性定义：一个定义视距距离，相当于前面的 perspective() 函数，另一个定义视域的原点。   

perspective() 函数只为目标元素定义视域，而 perspective 属性定义的视域深度应用到目标元素的所有子元素上。   

# 第 18 章 动画   

## 18.4 把动画应用到元素上    

### 18.4.9 动画的填充模式    

animation-fill-mode 的属性作用体现在，默认动画所做的改动只在动画播放的过程中有效，一旦动画结束，属性将还原为动画之前的
值。类似地，如果 animation-delay 为正值，动画不会立即改变属性的值，而是在延迟结束，触发 animationstart 事件后才开始
改变。   

使用 animation-fill-mode 的属性可以定义触发 animationstart 事件之前和触发 animationend 事件之后动画如何影响元素，
我们可以设定，让 0% 关键帧中设定的属性值在延迟期间就应用到元素上，或者在触发 animationend 事件之后继续应用到元素上。   

设为 backwards 时，from 关键帧中定义的属性值在动画应用到元素上的那一刻就起作用。0% 关键帧定义的属性值立即应用，而不等待
delay 时间结束。   

forwards 值的意思是动画播放结束后，当时的属性值继续应用在元素上。   

# 第 19 章 滤镜、混合、裁剪和遮罩    

## 19.1 CSS 滤镜   

### 19.1.1 基本滤镜   

- `blur(<length>)`: 使用高斯模糊对元素的内容做模糊处理，
- `opacity([<number> | <percentage>])`: 透明度滤镜
- `drop-shadow(<length>{2, 3} <color>?)`: 创建与元素 alpha 通道形状一致的投影，带模糊效果。   

## 19.2 合成和混合   

在 CSS 中，混合策略有两种，整个元素与其背后的内容（不管是什么）混合，以及把元素的多个背景层混合在一起。   

### 19.2.1 混合元素   

CSS 规范规定"必须使用定义的公示把颜色和背着物混合在一起"，也就是说，不管元素背后是什么，是另一个元素也好，是父元素的背景也好，
都必须混合。    

默认值 normal 的意思是，元素上的各像素（除去 alpha 通道的值小于 1 个部分）原封不动显示，不与背着物混合。   


