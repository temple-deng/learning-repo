# 第八章 文件与文件系统

<!-- TOC -->

- [第八章 文件与文件系统](#第八章-文件与文件系统)
  - [8.2 Linux 系统常见的压缩指令](#82-linux-系统常见的压缩指令)
  - [打包命令：tar](#打包命令tar)
  - [8.4 XFS 文件系统的备份与还原](#84-xfs-文件系统的备份与还原)
  - [8.5 光盘写入工具](#85-光盘写入工具)
    - [mkisofs：创建镜像文件](#mkisofs创建镜像文件)
- [第九章 Vim](#第九章-vim)
  - [9.2 vi 的使用](#92-vi-的使用)
    - [快捷键](#快捷键)

<!-- /TOC -->

## 8.2 Linux 系统常见的压缩指令

+ *.Z：compress 程序压缩的文件
+ *.zip：zip程序压缩的文件
+ *.gz：gzip 程序压缩的文件
+ *.bz2：bzip2 程序压缩的文件
+ *.xz：xz 程序压缩的文件
+ *.tar：tar 程序打包的数据，并没有压缩过
+ *.tar.gz：tar 程序打包的文件，其中并且经过 gzip 的压缩
+ *.tar.bz2：tar程序打包的文件，并且经过 bzip2 的压缩
+ *.tar.xz：tar程序打包的文件，经过 xz 的压缩     

gzip 可以解开 compress,	zip	与	gzip 等软件所压缩的文件。至于 gzip 所创建的压缩文件为	*.gz 的文件名。     

```shell
$ gzip [-cdtv#] filename

-c：将压缩的数据输出到屏幕上，可通过数据流重定向处理
-d：解压缩的参数
-t：可以用来检验一个压缩文件的一致性
-v：可以显示出原文件/压缩文件的压缩比等信息
-#：#为数字的意思，代表压缩等级，-1最快，但是压缩比最差，-9最慢，但是压缩比最后，默认是 -6。
```   

要注意压缩后源文件就没了，解压缩后压缩文件也会没了，看这样貌似不能重命名啊。    

cat/more/less	可以使用不同的方式来读取纯文本文件,那个 zcat/zmore/zless	则可以对应于 cat/more/less	的方式来读取纯文本文件被压缩后的压缩文件。    

```shell
$ bzip2 [-cdkzv#] filename

-c,-d：略，同gzip。
-k：保留原始文件，而不会删除原始的文件
-z：压缩的参数，默认值，可以不加
-v：可以显示出压缩比
-#：同gzip
```    

同理，使用bzcat/bzmore/bzless/bzgrep。     

```shell
$ xz [-dtlkc#] filename

-l：列出压缩文件的相关信息
其他的同 bzip2
```   

同理有xzcat/xzmore/xzless/xzgrep。    

## 打包命令：tar

```shell
$ tar [-zjJ] [cv] [-f 新文件名] 待打包的filename  -> 打包与压缩
$ tar [-zjJ] [tv] [-f 既有的 tar 文件名] -> 查看
$ tar [-zjJ] [xv] [-f 既有的 tar 文件名] [-C 目录] -> 解压缩到指定目录

-c：创建打包文件，使用 -v 来查看打包的文件名
-t：查看打包文件的内容含有哪些文件名
-x：解打包或解压缩的功能，可以搭配 -C 在指定目录解开
    特别留意的是 -c,	-t,	-x 不可同时出现在一串命令行中

-z：通过 gzip 的支持进行压缩解压缩
-j：通过 bzip2 的支持进行压缩解压缩
-J：通过 xz 的支持进行压缩解压缩
    同理 z, j, J 也不能一起出现
-v：将正在处理的文件名显示出来
-f filename：要被处理的文件名
-C 目录：解压缩到特定的目录

-p：保留备份数据的原本权限与属性,常用于备份(-c)重要的配置文件
-P：保留绝对路径,亦即允许备份数据中含有根目录存在之意;
--exclude=FILE:在压缩的过程中,不要将 FILE	打包
```    

## 8.4 XFS 文件系统的备份与还原

xfsdump 除了进行文件系统的完整备份，还可以进行累积备份。使用 `xfsdump` 需要注意以下的限制：    

+ `xfsdump` 不支持没有挂载的文件系统备份
+ `xfsdump` 必须使用 root 的权限才能操作
+ `xfsdump` 只能备份 XFS 文件系统
+ `xfsdump` 备份下来的数据只能用 `xfsrestore` 解析
+ `xfsdump` 是通过文件系统的 UUID 来分辨各个备份文件的，因此不能备份两个具有相同 UUID 的文件系统。    

```shell
# xfsdump [-L S_label] [-M M_label] [-l #] [-f 备份文件] 待备份数据
# xfsdump -I

-L：xfsdump 会记录每次备份的 session 标头，这里可以填写针对此文件系统的简易说明
-M：xfsdump 可以记录存储媒体的标头，这里可以填写此媒体的简易说明
-l：指定等级，有0~9 共10个等级，默认为0，即完整备份
-f：类似 tar，后面接产生的文件
-I：从 /var/lib/xfsdump/inventory 列出目前备份的信息状态
```    

`xfsdump` 默认仅支持文件系统的备份，并不支持特定目录的备份，所以不能区备份某个目录。    

`xfsdump -l 0 -L boot_all -M boot_all -f /srv/boot.dump /boot` 备份 /boot 文件系统。一定得要进行过完整备份后 (-l 0) 才能够继续有其他累积备份 (-l 1~9)。     

```shell
# xfsrestore -I  -> 用来查看备份文件数据
# xfsrestroe [-f 备份文件] [-L S_label] [-s] 待复原目录，单一文件全系统复原
# xfsrestore [-f 备份文件] -r 待复原目录  -> 通过累积备份文件来复原系统
# xfsrestore [-f 备份文件] -i 待复原目录  -> 进入互动模式

-I：跟 xfsdump 相同的输出，查询备份数据
-f：后面接的就是备份文件
-L：就是 session 的label name
-s：需要接某特定目录
-r：如果使用文件来存储备份数据，那这个就不需要使用，如果是一个磁带内带有多个文件，就要用来累积复原
-i：进入互动模式
```    

`# xfsrestore -f /srv/boot.dump -L boot_all /boot` 直接覆盖的复原。也可以指定到别的目录，再手动覆盖的复原。不过直接复原的结果是，同名的文件会被覆盖，但是新的文件会被保留。    

`-s` 的话好像是可以指定恢复备份系统中的某个目录。    

## 8.5 光盘写入工具

### mkisofs：创建镜像文件

```shell
$ mkisofs [-o 镜像文件] [-Jrv] [-V vol] [-m file] 待备份文件 -graft-point isodir=systemdir

-o：后面接你想要产生的那个镜像文件文件名
-J：产生相容于 Windows 机器的文件名结构，可增加文件名长度到 64 个 unicode 字符
-r：通过 Rock Ridge 产生支持 Unix/Linux 的文件数据，可记录较多的信息
-v：显示创建 ISO文件的过程
-V vol：创建Volume，有点像	Windows	在文件资源管理器内看到的 CD	title 的东西
-m file： -m 为排除文件的意思
-graft-point：下面再说
```   

如果我们只是想要制作“数据光盘”时,上述的选项也就够用了。光盘的格式一般称为 iso9660 ,这种格式一般仅支持旧版的	DOS	文件名,亦即文件名只能以 8.3 (文件名8个字符,扩展名3个字符) 的方式存在。如果加上 -r 的选项之后,那么文件信息能够被记录的比较完整,可包括UID/GID与权限等等。    

# 第九章 Vim

## 9.2 vi 的使用

vi分为3种模式，分别是一般指令模式、编辑模式与命令行命令模式。这3种模式的作用分别是：    

+ 一般指令模式：以	vi	打开一个文件就直接进入一般指令模式了(这是默认的模式,也简称为一般模式)。在
这个模式中, 你可以使用“上下左右”按键来移动光标,你可以使用“删除字符”或“删除整列”来处理文件内容, 也可以使用“复制、贴上”来处理你的文件数据。   
+ 编辑模式/插入模式：在一般指令模式中可以进行删除、复制、贴上等等的动作,但是却无法编辑文件内容的!	要
等到你按下“i, I,	o, O, a, A, r, R”等任何一个字母之后才会进入编辑模式。
+ 命令行命令模式：在一般模式当中,输入“ : / ?	”三个中的任何一个按钮,就可以将光标移动到最下面那一列。在
这个模式当中,	可以提供你“搜寻数据”的动作,而读取、存盘、大量取代字符、离开	vi 、显示行号等等的动作则是在此模式中达成的。     

### 快捷键

**一般模式下**：   

- 光标移动类：
    + h,j,k,l：左，下，上，右
    + <kbd>Ctrl</kbd> + f/b：向下/上翻页
    + <kbd>Ctrl</kbd> + d/u：向下/上翻半页
    + n + <kbd>space</kbd>：n表示数值，例如20。则光标会向右移动20个字符。
    + 0或功能键[Home]：移动到这一列第一个字符处
    + $或功能键[End]：移动到这一列最后字符处
    + H：光标移动到这个屏幕的最上方那一列的第一个字符
    + M：移动到这个屏幕中央的那一列的第一个字符
    + L：移动到屏幕最下方那一列的第一字符
    + G：移动到文件的最后一列
    + nG：n为数值，移动到第n列。
    + gg：移动到第一列
    + n + <kbd>Enter</kbd>：n为数值，向下移动 n列
- 查找与替换类：
    + /word：向光标之下寻找一个名称为 work 的字串。
    + ？word：向光标之上寻找一个 work 字串
    + n：重复前一个查找动作
    + N：反向进行
    + :n1,n2s/word1/word2/g：n1与n2为数字，在n1列到n2列之间查找word1 替换为word2
    + :1,$s/word1/word2/g：从第一列到最后一列
    + :1,$s/word1/word2/gc：从第一列到最后一列，但在替换前会询问
- 删除、复制与粘贴类：
    + x,X：x为向后删除一个字符，X为向前删除一个字符
    + nx：n为数值，连续向后删除n个字符
    + dd：删除光标所在的那一整列
    + ndd：删除光标向下 n列
    + d1G：删除光标所在列到第一列的所有数据
    + dG：删除光标所在到最后一列的所有数据
    + d$：删除光标所在处到该列最后一个字符
    + d0：删除光标所在处到该列第一个字符
    + yy：复制光标所在的那一列
    + nyy：复制光标向下 n列
    + y1G：复制光标所在列到第一列的所有数据
    + yG：复制到最后一列
    + y0：复制光标所在处到该列第一字符
    + y$：略
    + p,P：p为将已复制的数据在光标下一列贴上，P则为在上面贴
    + J：将光标所在列与下一列的数据结合成同一列
    + u：复原前一个动作
    + <kbd>Ctrl</kbd> + r：重复前一个动作   

**命令界面的指令**：    

+ :w：将编辑的数据写入硬盘
+ :w!：若文件属性为只读时，强制写入。
+ :q：离开
+ :q!：不想保存编辑离开时
+ ZZ：若文件没有变动过，则不存储离开，若变动过，存储后离开
+ :w [filename]：将编辑的数据存储为另一个，也就是另存为
+ :n1,n2 w [filename]：将 n1到 n2 的内容存储为 filename
+ :set nu：显示行号
+ :set nonu：取消行号