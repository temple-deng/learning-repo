# 第二章 主机规划与磁盘分区

<!-- TOC -->

- [第二章 主机规划与磁盘分区](#第二章-主机规划与磁盘分区)
  - [Linux 与硬件](#linux-与硬件)
    - [各硬件设备在 Linux 中的文件名](#各硬件设备在-linux-中的文件名)
  - [磁盘分区](#磁盘分区)
    - [开机流程中的 BIOS 与 UEFI 开机检测程序](#开机流程中的-bios-与-uefi-开机检测程序)
- [第三章 安装 CentOS7](#第三章-安装-centos7)
- [第四章 首次登录与线上求助](#第四章-首次登录与线上求助)
  - [命令](#命令)
    - [基础的几个命令](#基础的几个命令)
      - [date](#date)
      - [cal](#cal)
      - [bc](#bc)
  - [man page 和 info page](#man-page-和-info-page)
    - [搜寻特定指令/文件的 man page 说明文档](#搜寻特定指令文件的-man-page-说明文档)
  - [关机](#关机)
    - [Sync](#sync)
    - [shutdown](#shutdown)
    - [reboot, halt, poweroff](#reboot-halt-poweroff)
    - [systemctl](#systemctl)

<!-- /TOC -->

## Linux 与硬件

### 各硬件设备在 Linux 中的文件名


设备 | 文件名 | 
----------|---------
 SCSI/SATA/USB 硬盘 | /dev/sd[a-p] 
 USB 闪存 | /dev/sd[a-p]（与SATA相同）
 VirtI/O 界面 | /dev/vd[a-p]（用于虚拟机内）
 打印机 | /dev/lp[0-2]（25针打印机） /dev/usb/lp[0-15]（USB接口）
 鼠标 | /dev/input/mouse[0-15]（通用）/dev/mouse（当前鼠标)
 CDROM/DVDROM | /dev/scd[0-1]（通用） /dev/sr[0-1]（通用） /dev/cdrom（当前 CDROM）

## 磁盘分区

整颗磁盘的第一个扇区特别的重要，因为它记录了整颗磁盘的重要信息。早期磁盘的第一个扇区里面含有的重要信息我们称为 MBR (Master Boot Record)格式，后来又多了一个新的磁盘分区格式，称为 GPT(GUID partition table)。     

**MBR 分区表格式和限制**     

早期的 Linux 系统为了相容于 Windows 的磁盘，因此使用的是支持 Windows 的 MBR 的方式来处理开机管理程序和分区表。而开机管理程序记录区和分区表通通放在磁盘的第一个扇区，这个扇区通常是 512Bytes 的大小。所以说，第一个扇区 512Bytes 会有这两个数据：   

+ 主要开机记录区MBR：可以安装开机管理程序的地方，有446Bytes
+ 分区表：记录整颗硬盘分区的状态，有64Bytes。     

又要分区表所在区块仅有64 Bytes容量，因此最多仅能有四组记录区，每组记录区记录了该区段的起始和结束的柱面号码。     
假如一块硬盘文件名为 /dev/sda，分了4个分区，那么这四个分区在 Linux 系统中的设备文件名为 /dev/sda1, /dev/sda2, /dev/sda3, /dev/sda4。     

由于分区最多只能容纳四笔分区的记录，这四个分区被称为主分区或扩展分区。    

扩展分区并不是只占一个区块，而是会分布在每个分区的最前面几个扇区来记载分区信息。扩展分区的目的是使用额外的扇区来记录分区信息，扩展分区本身并不能被拿来格式化。由扩展分区再划分出来的分区，就叫逻辑分区。     

+ 主分区和扩展分区最多可以有 4 个（硬盘的限制，因为 MBR 只有 64 字节用来记录分区信息吧）
+ 扩展分区最多只能有一个（操作系统的限制）
+ 逻辑分区是由扩展分区持续切割出来的分区
+ 能够被格式化的，只有主分区和逻辑分区，扩展分区无法格式化
+ 逻辑分区的数据依操作系统而不同    

**GUID partition table GPT 磁盘分区表**     

因为过去的一个扇区大小为 512Bytes，目前则有4K的扇区出现。为了相容于所有的磁盘，因此在扇区的
定义上面，大多会使用所谓的逻辑区块位址（Logical Block Address, LBA）来处理。GPT 将磁盘所
有区块以 LBA（默认为 512 Bytes）来规划，第一个 LBA 称为 LBA0。所以 LBA 只是一种定义扇区
大小的方式。      

与 MBR 仅使用第一个 512 Bytes 区块来记录不同，GPT 使用了 34个 LBA区块来记录分区信息。同时除了前面的34个 LBA 之外，整个磁盘的最后33个LBA 也拿来作为另一个备份。    

![GUID partition table](https://github.com/temple-deng/learning-repo/blob/master/pics/GUID-partition-table.png)     

+ LBA0(MBR 相容区块)：与 MBR 模式相似，这个相容区块也分为两个部分，一个就是跟之前 446Bytes 
相似的区块，储存了第一阶段的开机管理程序！而在原本的分区表的记录区内，这个相容模式仅放入一个特殊
标志的分区，用来表示此磁盘为 GPT 格式之意。而不懂 GPT 分区表的磁盘管理程序，就不会认识这颗磁盘。  
+ LBA1（GPT 表头记录）：这个部分记录了分区表本身的位置和大小，同时记录了备份用的GPT分区放置的
位置，同时放置了分区表的检验机制码。操作系统可以根据这个校验码来判断 GPT 是否正确，若有错误，
可以通过这个记录区取得备份的GPT来恢复。
+ LBA2-33（实际记录分区信息处）：从LBA2区块开始，每个LBA都可以记录4条分区记录，所以在默认的
情况下，总共可以有4*32=128 条分区记录。每条记录用到128Bytes 空间，除了每条记录所需要的识别码
和相关的记录之外，GPT 在每笔记录中分别提供了 64bits 来记载开始/结束的扇区号码。    

现在 GPT 分区默认可以提供多达 128 笔记录，此外，GPT 分区已经没有所谓的主、扩展、逻辑分区的
概念，既然每笔记录都可以独立存在，当然每个都可以视为主分区，每个分区都可以拿来格式化使用。    

### 开机流程中的 BIOS 与 UEFI 开机检测程序

**BIOS 搭配MBR/GPT 的开机流程**     

BIOS 实在开机的时候，计算机系统会自动执行的第一个程序了。接下来BIOS 会区分析计算机里有哪些
存储设备，我们以硬盘为例，BIOS 会依据使用者的设置去取得能够开机的硬盘，并且到该硬盘里面去读取
第一个扇区的 MBR 位置。MBR 这个仅有的446Bytes 的硬盘容量里面会放置最基本的开机管理程序，此时 
BIOS就功成圆满，接下来就是 MBR 内开机管理程序的工作了。    

这个开机管理程序的目的是载入核心文件，由于开机管理程序是操作系统在安装的时候所提供的，所以它会认识硬盘内的文件系统格式，因此能够读取核心文件，然后就是核心文件的工作了。    

由于 LBA0 仅提供第一阶段的开机管理程序码，因此如果使用类似 grub 的开机管理程序，得额外分区出一个"BIOS boot" 的分区，这个分区才能够放置其他开机过程所需的程序码。    

Boot loader 是操作系统安装在 MBR 上面的一套软件。其主要任务如下：    

+ 提供菜单：使用者可以选择不同的开机项目，这也是多重开机的重要功能
+ 载入核心文件：直接指向可开机的程序区段来开始操作系统
+ 转交其他loader：将开机管理功能转交给其他loader负责     

根据上面的第3点，开机管理程序除了可以安装在 MBR 之外，还可以安装在每个分区的开机扇区(boot sector)中。如下图中的例子，第一、二分区分别安装了 Windows 及 Linux：    

![boot loader](https://github.com/temple-deng/learning-repo/blob/master/pics/boot-loader.png)    

在上图中，MBR 的开机管理程序提供两个菜单，菜单一可以直接载入 Windows 的核心文件来开机，菜单二则是将开机管理工作交给第二个分区的开机扇区。当使用者在开机的时候选择菜单二时，那么整个开机管理工作就会交给第二分区的开机管理程序。这就是多重开机的情况。   

**UEFI BIOS 搭配 GPT 开机的流程**    

由于 BIOS 不懂 GPT。只能以相容模式处理。所以为了解决这个问题，有了 UEFI（Unified Extensible Firmware Interface)。UEFI 主要是想要取代 BIOS，因此我们也称 UEFI 为 UEFI BIOS。    

# 第三章 安装 CentOS7

这里简单讲一下自己理解的 grub2 之类的开机程序，这种程序通常安装在 MBR 中，我们知道通常 MBR 安装
的是操作系统安装的系统启动代码，而这里我们把 grub2 安装到这里，那么启动后，BIOS 处理完自己的
工作后，那就到了这里来执行，如果 grub2 有一些 I/O 能力话，就可以和用户交互，来决定下一步去那里
执行，那这样我们其实是可以选择去哪里执行操作系统启动代码的，那这里其实就可以提供给我们双系统启动
时的选择。   

安装时的各个文件系统：   

+ ext2/ext3/ext4: Linux早期使用的文件系统类型。
+ swap:由于swap 并不会使用到目录树的挂载，所以不需要指定挂载点。
+ BIOS Boot: 就是GPT 分区表可能用到的项目，如果使用 MBR 分区就不需要这个项目了。
+ xfs: 这个是目前 CentOS 默认的文件系统，对于大容量的磁盘管理非常好，而且格式化的时候速度相当快。
+ vfat: 同时被 Linux 和 Windows 所支持的文件系统类型。如果你的主机硬盘内同时存在 Windows 和 Linux 系统，为了数据的交换，可以创建一个这样的系统。

# 第四章 首次登录与线上求助

从 CentOS 7 开始，已经取消了使用多年的 SystemV 的服务管理方式，也就是说，从这一版开始，已经没有所谓的“执行等级（run level）”的概念了。新的管理方法使用的是 systemd 的模式，这个模式将很多的服务进行相依性管理。     

登录时上面显示的内容来自与 /etc/issue 这个文件。     

登出命令 `exit` 但是好像 `logout` 也可以。    

## 命令

```shell
[dengbo@host ~]$ command [-options] parameter1 parameter2 ...
                 命令      选项      参数1           参数2
```    

1. 一行指令中第一个输入的部分一定是“命令”或“可执行文件”
2. parameter1 parameter2... 为依附在选项后面的参数，或者是 command 的参数
3. 指令，选项，参数之间以空格分割，不管几个空格 shell 都视为一个
4. 按下 <kbd>Enter</kbd> 命令开始执行
5. 命令太长的时候，可以使用反斜线(\)来断行。不过必须在紧跟着反斜线后面输入后面的命令内容。   

光输入 `locale` 命令其实是展示当前主机与语系相关的信息。也就是展示一系列当前系统语系设置的系统
变量吧。LANG 其实只是 base 输出的语言设置。   

### 基础的几个命令

+ 显示日期与时间的指令： `date`
+ 显示日历的指令：`cal`
+ 简单好用的计算机：`bc`    

#### date

格式化输出：   

```shell
$ date +%Y/%m/%d
$ date +%H:%M
```     

从这个例子能看出，命令的选项除了以 `-` 开头外，在一些特殊的情况下，选项或参数前面也会带有 `+` 的情况。    
#### cal

语法： `cal [month] [year]`   

#### bc

bc默认仅输出整数位，如果要输出小数点位，必须要执行 `scale=number`，`number`是小数点后的位数。    

输入 `quit` 退出。     

## man page 和 info page

指令添加 `--help` 会显示用法帮助。   

命令的类别：   


代号 | 代表内容 
----------|---------
 1 | 使用者在 shell 环境中可以操作的指令或可执行文件
 2 | 系统核心可调用的函数与工具 
 3 | 一些常用的函数与函数库，大部分是C的函数库
 4 | 设备文件的说明
 5 | 配置文件或者是某些文件的格式
 6 | 游戏
 7 | 惯例与协定等，例如Linux文件系统、网络协定
 8 | 系统管理员可用的命令
 9 | 跟内核有关的文件   

### 搜寻特定指令/文件的 man page 说明文档

例如，系统中还有哪些跟"man"指令相关的说明文档：    

```shell
$ man -f man
man	(1)														-	an	interface	to	the	on-line	reference	manuals
man	(7)														-	macros	to	format	man	pages
```    

可以指定显示的文档：   

```shell
$ man 1 man
$ man 7 man
```    

## 关机

关机的注意事项：  

+ 观察系统的使用状态：如果要看目前谁在线上，使用`who` 命令，而如果要看网络的连线状态，可以下达 `netstat -a` 命令，要看背景执行的程序执行 `ps -aux` 命令。
+ 通知线上使用者关机的时刻，使用 `shutdown` 指令。    

常用的几个与关机/重新开机相关的指令：   

+ 将数据同步写入硬盘中的指令： `sync`
+ 惯用的关机指令：`shutdown`
+ 重新开机，关机：`reboot`, `halt`, `poweroff`     

### Sync

由于硬盘的速度太慢，所以如果系统常常让数据在内存和硬盘间来回写入/读出，性能就会不太好。    

因此在 Linux 系统中，为了加快数据的读取速度，所以在默认的情况中，某些已经载入内存中的数据将不会直接被写入硬盘，而是先暂存在内存当中，如此一来，如果一个数据被你重复的改写，那么由于他尚未被写入到硬盘中，因此可以直接由内存中读取出来。     

因此，这时如果遇到突发情况，数据未被写入到硬盘当中，就会造成数据的更新不正常。这时候就需要 `sync` 指令，强制将内存中尚未被更新的数据，写入到硬盘中。     

### shutdown

如果是在主机中的终端上(tty1-tty7)登陆时，不论什么身份都可以关机，如果是远程登陆工具，例如SSH，则只有 root 可以。     

shutdown 可以完成如下的工作：    

+ 可以自由选择关机模式：关机或重新开机均可
+ 可以设置关机时间：可以设置成现在立刻关机，也可以设置成某一个特定的时间才关机
+ 可以自定关机讯息：在关机之前，可以将自己设置的讯息传送给线上 user
+ 可以仅发出警告讯息

### reboot, halt, poweroff

略。    

### systemctl

上面提到的 halt, poweroff, reboot, shutdown等，其实都是调用这个 systemctl 命令：     

```shell
# systemctl [命令]
指令项目包括：
halt
poweroff
reboot
suspend    休眠模式
```    