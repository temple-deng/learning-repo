# 第十六章 进程管理与 SELinux 初探

## 16.1 什么是进程

在Linux 系统当中，触发任何一个事件时，系统都会将他定义成为一个进程，并且给予这个进程一个 ID，称为 PID，同时依据启动这个进程的使用者与相关属性关系，给予这个 ID 一组有效的权限设置。从此以后，这个 PID 能够在系统上面进行的动作，就与这个 PID 的权限有关了。     

### 16.1.1 进程与程序

系统仅认识二进制文件，因此我们想让系统执行某些工作的时候，就需要启动一个二进制文件，这个二进制文件就叫做程序。     

在 Linux 中进程的相互调用通常称为 fork-and-exec 的流程。程序都会借由父进程以复制(fork)的产生一个一模一样的子进程，然后被复制出来的子进程再以 exec 的方式来执行实际要进行的程序。   

常驻在内存当中的进程通常都是负责一些系统所提供的功能以服务使用者各项任务，因此这些常驻进程就会被称为：服务(daemon)。系统的服务非常多，不过主要可以分成系统本身所需要的服务，例如 crond 和 atd，还有 rsyslogd 等。还有一些则是负责网络连接的服务，例如 Apache 等。一般 daemon 类型的进程都会加入 d 在文件名后头。     

在 Linux 下面执行一个命令时，系统会将相关的权限、属性、程序码与数据等载入内存，并给予这个单元一个进程码 PID。     

## 16.2 工作管理

### 16.2.1 什么是工作管理

要进行 bash 的工作管理必须要注意到的限制是：    

+ 这些工作所触发的进程必须来自于你 shell 的子程序
+ 前台：可以控制与下达指令的这个环境称为前台的工作
+ 后台：可以自行运行的工作，无法使用 ctrl + c 终止
+ 后台中的进程不能等待终端的输入     

### 16.2.2 工作管理

在后台中的进程的状态又可以分为暂停与运行中。    

+ 直接将指令丢到后台中执行的 &
+ 将目前的工作丢到后台中暂停 ctrl + z
+ 观察目前的背景工作状态：jobs     
```
#jobs [-lrs]

-l：除了列出 job number 与指令串之外，还列出 PID
-r：仅列出在后台运行中的工作
-s：仅列出在后台中暂停的工作     
```     
+ 将后台工作拿到前台来处理：fg      
```
#fg %jobNumber

%jobNumbwe：%是可有可无的
```    
+ 让工作在后台中的进程运行：bg `bg %jobNumber`。相当于把一个在后台暂停了的工作变为后台运行中状态。
+ 管理后台中的工作：kill     

```
#kill -signal %jobNumber
#kill -l

-l：列出目前 kill 能够使用的 signal 有哪些
signal：代表给予后面接的那个工作什么样的指示
  -1：重新读取一次参数的配置文件
  -2：代表与由键盘输入 ctrl + c 同样的动作
  -9：立刻强制删除一个工作
  -15:以正常的方式终止一项工作
```    

注意 kill 后面接的数字默认会是 PID，如果想要管理 bash 的工作控制，就得要加上 %。    

### 16.2.3 离线管理问题

我们之前在工作管理中提到的后台，是指在 bash 的后台，而不是系统的后台，因此工作管理的后台依然与终端机有关，因此当我们退出终端时，任务是会被中断的，如果我们希望将一些任务放到系统的后台，而与终端无关。一种方法是使用上一章提到的 `at`，而一种就是 `nohup` 命令。     

```
#nohup  [指令与参数]   -> 在终端前台工作
#nphup  [命令与参数] &   -> 在终端后台工作
```    

需要注意的一点是 `nohup` 并不支持 bash 内置的命令，因此命令必须是外部命令才可以。     

## 16.3 程序管理

### 16.3.1 程序的观察

利用静态的 `ps` 或者是动态的 `top` 查看系统上面正在运行的程序，还可以用 `pstree` 来查阅程序树之间的关系。   

+ `ps`：将某个时间点的程序运行情况摘取下来     

```
#ps aux   -> 观察系统所有的程序数据
#ps -lA    -> 也是能够观察所有系统的数据
#ps axjf   -> 连同部分程序树的状态

-A：所有的进程均显示出来，与 -e 具有同样的效用
-a：不与终端有关的所有进程
-u：有效使用者相关的进程
x：通常与 a 一起使用，可列出完整的信息    

输出格式规划：   
l：较长、较详细的将该 PID 的信息列出
j：工作的格式
-f：做一个更为完整的输出
```   

说实话，乱七八糟看不懂。    

一般只背两个写法，查阅自己 bash 程序的 `ps -l`，还有一个查阅所有系统运行进程的 `ps aux`。     

先看下 `ps -l` 输出信息的含义：     

+ F (process flags)，常见号码有：
  - 4：表示此程序的权限为 root
  - 1：表示此子程序仅进行 fork 而没有实际执行
+ S (STAT)，表示进程的状态，主要的状态有：
  - R：表示进程正在运行中
  - S：表示进程目前正在睡眠状态，但可以被唤醒
  - D：不可被唤醒的睡眠状态，通常这支程序可能正在等待 I/O 的情况
  - T：停止状态，可能是在工作控制（后台暂停）或除错状态
  - Z：僵尸状态，进程已经终止但却无法被移除至内存外    
+ UID/PID/PPID
+ C：代表 CPU 使用率，单位为百分比
+ PRI/NI：priority/nice 的缩写，代表此程序被 CPU 所执行的优先顺序，数值越小代表程序越快被CPU执行
+ ADDR/SZ/WCHAN：都与内存有关，ADDR 是内核函数，指出此进程在内存的哪个部分，如果是个 runnig 的进行，一般会显示 `-`， SZ 代表此程序用掉多少内存，WCHAN 表示进程是否在运行中，同样的，若为 `-` 表示正在运行中。
+ TTY：登录者的终端机位置，若为远程登录则使用动态终端接口 pts/n
+ TIME：使用掉的 CPU 时间，注意，是此程序实际花费的 CPU 运行时间，而不是系统时间
+ CMD：就是命令的缩写     

之后是 `ps aux` 的内容含义：    

+ USER：该进程属于哪个使用者账号
+ PID
+ %CPU：使用的 CPU 占比
+ %MEM：进程所占用的内存占比
+ VSZ：使用的虚拟内存量 KB
+ RSS：占用的固定内存量 KB
+ TTY：该进程是在哪个终端机上面运行，若与终端机无关则显示 `?`
+ STAT：进程状态，与 `ps -l` 的 S 相同
+ TIME：占用 CPU 时间
+ COMMAND      

+ `top`：动态观察程序的变化    

```
#top [-d 数字] | top [-bnp]

-d：后面可以接秒数，就是整个程序画面更新的秒数，默认是5秒
-b：以批次的方式执行top
-n：与-b搭配，意义是，需要进行几次 top 的输出结果
-p：指定某些个 PID 来进行观察检测而已

在top执行过程中可以使用的按键：    

