# 复习




## JS权威指南

1. `onclick`之类的事件监听是注册事件处理程序最简单的方法，把JS函数赋值给目标对象的属性，因此在JS中并没有用驼峰式的命令。  

2. \u0009 水平制表符， \u000A 换行符， \u000B 垂直制表符， \u000D 回车符， \u0020 空白符。  

3. `_`, `$`, 字母可以做标识符的开头，后续可以有`_`, `$`, 数字，字母。  

4. `return`, `break`, `continue`后面紧跟的换行符的话，JS会自动补全分号。  

5. 后缀表达式应该写在同一行，否则会被解析成前缀表达式    
   x  
   ++  
   y  
被解析成 `x;++y` 而不是 `x++;y`  

6. 通常来讲，如果一条语句以"(", "[", "/", "+"或"-"开始，那么它极有可能和前一条语句在一起解析(指的是前一条语句末尾没加;的情形)。  

7. 全局对象上的`isNaN`, `isFinite`方法会先用 Number() 方法转换参数，ES6中绑定在 Number 对象上的这两个方法则不会进行转换， 而是直接进行比较。  

8. `==` 运算符将原始值和其包装对象视为相等。  

9. 不带`new`调用`Object`函数可以将原始值参数转为其包装对象，就像调用对应的包装函数作显示类型装换一样。  

10. `toFixed()`参数指定小数点后的位数， `toExponential()`将转换为指数形式表示，参数也是指定小数点后的位数，不同的是其小数点前只有一位。`toPrecision()`参数则是指定整个数字的位数，如果参数指定的位数小于数字现有位数，则换成指数形式，否则可以填0。 注意3种方法都是将数字转换为字符串。  

11. "+", "==", "!=" 和众多的关系运算符对非日期对象来说，当执行对象到原始值的转换时使用的是特殊的转换规则: 首先尝试调用`valueOf()`方法，然后调用`toString()`， 不管得到的原始值是否能直接使用，都不会进一步转换为字符串或数字。  

12. 日期对象的减法是计算时间间隔的毫秒数，Month是从0开始，Date是日期，从1开始，Day是星期几，值为0~6，星期日为0，星期六为6.  

13. 使用`var`声明的全局变量作为全局对象的属性是不可配置和不可删除的，但在非严格模式中，未使用`var`声明的全局变量作为全局对象的属性是可配置和可删除的。  

14. "<=" 和 ">=" 运算符在判断相等的时候，并不依赖于相等运算符和严格相等运算符的比较规则。相反，小于等于只是简单的"不大于"，大于等于只是简单的"不小于",只有在一个操作数是(或转换后是)NaN时例外，此时4个运算符均返回false。  

15. eval()只有一个参数，如果传入的参数不是字符串，它直接返回这个参数，如果参数是字符串，它会把字符串当成JS代码进行编译，如果编译失败，则抛出一个语法错误。如果编译成功，则开始执行这段代码，并返回字符串中最后一个表达式或语句的值，如果最后一个表达式会语句没有值，则最终返回undefined。  

16. 当直接使用非限定的"eval"名称来调用eval函数，它总是在调用它的上下文作用域内执行。其他的间接调用则使用全局对象作为其上下文作用域，并且无法读，写，定义局部变量和函数。在严格模式下，局部eval()可查询或更改局部变量，但不能在局部作用域内定义新的变量和函数。  

17. 严格模式。
    + 在严格模式中禁止使用with语句。
    + 在严格模式中，所有的变量都要先声明，如果给一个未声明的变量，函数，函数参数，catch从句参数或全局对象的属性赋值，将会抛出一个引用错误异常。
    + 在严格模式中，调用的函数(不是方法)中的一个`ythis`值是`undefined`。
    + 在严格模式中，当通过`call()`或`apply()`来调用函数时，其中的this值就是通过`call()`或`apply()`传入的第一个参数。(在非严格模式中，null和undefined值被全局对象和转换为对象的非对象值所代替)
    + 给只读属性赋值和给不可扩展的对象创建新成员都将抛出一个类型错误异常。
    + 传入`eval()`的代码不能在调用程序所在的上下文中声明变量或定义函数。相反，变量和函数的定义是在`eval()`创建的新作用域中，这个作用域在`eval()`返回时就弃用了。
    + 函数里的arguments对象拥有传入函数值的静态副本。
    + 当`delete`运算符后跟随非法的标识符(比如变量、函数、函数参数)时，将会抛出一个语法错误异常。
    + 试图删除一个不可配置的属性将抛出一个类型错误异常。
    + 在一个对象直接量中定义两个或多个同名属性将产生一个语法错误。
    + 函数声明中存在两个或多个同名的参数将产生一个语法错误。
    + 不允许八进制直接量（以0为前缀）
    + 标识符`eval`和`arguments`当做关键字，他们的值是不能更改的。不能给这些标识符赋值。也不能把它们声明为变量、用作函数名、用作函数参数或用作catch块的标识符。
    + arguments.caller和arguments.callee都会抛出一个类型错误异常。  

18. try/catch/finally语句
```javascript
try {
	// 通常来讲，这里的代码会从头执行到尾而不会产生任何问题
	// 但有时会抛出一个异常，要么是有throw语句直接抛出异常
	// 要么是通过调用一个方法间接抛出异常
}
catch(e){
	// 当且仅当try语句块抛出了异常，才会执行这里的代码
	// 这里可以通过局部变量e来获得对Error对象或者抛出的其他值的引用
	// 这里的代码块可以基于某种原因处理这个异常，也可以忽略这个异常
	// 还可以通过throw语句重新抛出异常
}
finally {
	// 不管try语句块是否抛出了异常，这里的逻辑总是会执行，终止try语句块的方式有：
	// 1) 正常终止，执行完语句块的最后一条语句
	// 2) 抛出一个异常，异常被catch从句捕获
	// 3) 抛出一个异常，异常未被捕获，继续向上传播
}
```    

19. 任何对`Object.defineProperty()`或`Object.defineProperties()`违反规则的使用都会抛出类型错误异常：  
   + 如果对象是不可扩展的，则可以编辑已有的自有属性，但不能给它添加新属性
   + 如果属性是不可配置的，则不能修改它的可配置性和可枚举性
   + 如果存取器属性是不可配置的，则不能修改其 getter 和 setter 方法，也不能将它转换为数据属性。
   + 如果数据属性是不可配置的，则不能将其转换为存取器属性
   + 如果数据属性是不可配置的，则不能将其可写性从 false 转换为 true ，但可以从 true 修改为 false。
   + 如果数据属性是不可配置且不可写的，则不能修改它的值，然而可配置但不可写属性的值是可以修改的。  

20. JSON的语法是JS语法的子集，它并不能表示JS里的所有值。支持对象、数组、字符串、无穷大数字、布尔值和null， 并且他们可以序列化和还原。 NaN、Infinity和 -Infinity序列化的结果是null， 日期对象序列化的结果是ISO格式的日期字符串，JSON.parse()依然保留它们的字符串形态，而不能将它们还原为原始日期对象。函数、RegExp、Error对象和 undefined 值不能序列化和还原。JSON.stringify()只能序列化对象可枚举的自有属性。对于一个不能序列化的属性来说，在序列化后的输出字符串中会将这个属性省略掉。   

21. 数组方法： `sort()`——如果数组包含 `undefined` 元素，会排到数组尾部。 `splice()`返回一个由删除元素组成的数组。 `push()`是在尾部添加一个或多个元素。 `unshift()`的参数是一次性插入的，就像 `splice()` 方法， 而非一次一个地插入。 ES5中的数组方法，对稀疏数组中的不存在元素不调用传递的函数参数。  

22. 尽管有时候构造函数看起来像一个方法调用，但它依然会使用这个新对象作为调用上下文。也就是说，在表达式`new o.m()`中，调用上下文并不是o.

23. 正则表达式中园括号的用途： 把单独的项组合成子表达式，在完整的模式中定义子模式，允许在同一正则表达式的后部引用前面的子表达式。  

24. 对正则表达式前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是与那个模式相匹配的文本的引用。  

25. 不能在字符类中使用 \n 这种对子表达式的引用，所以下面的写法是非法的: `/(['"])[^'"]*\1/`  

26. 用 "(?:" 和 ")" 对子表达式分组，但不创建带数字的引用。  

27. 锚字符： `\b` 匹配一个单词的边界，就是位于字符 `\w`和 `\W`之间的位置，或位于字符 `\w`和字符串的开头或结尾之间的位置。 `\B`匹配非单词边界的位置。 `(?=P)` 零宽正向先行断言，要求接下来的字符都与P匹配，但不能包括匹配P的那些字符. `(?!P)`零宽负向先行断言，要求接下来的字符都不与P匹配。  

28. 正则对象的属性： `global`, `ignoreCase`, `multiline`, `lastIndex`, `source`。 `exec()`方法，如果找到一个匹配项，它将返回一个由匹配结果组成的数组，否则将返回 `null`。返回数组的元素0是匹配的文本，元素1是匹配RegExp中第一个带圆括号的子表达式文本，如果存在这样的子表达式的话。元素2匹配第二个子表达式文本，依次类推，数组的 `index`属性指定匹配的文本的第一个字符的位置，`input`指代string.  

29. source的值为该 RegExp 模式的文本内容，这个文本不包括正则表达式直接量中的分隔斜杠，也不包括"g","i","m"属性。  

30. `Date()`也可以不带 new 操作符，像一个函数一样调用，以这种方式调用`Date()`将忽略掉所有传入的参数，并返回当前日期和时间的一个字符串表示。  

31. `Date.now()`返回当前时间自纪元开始后的毫秒数。  

32. String实例的 `subString()`方法，如果 from 等于 to， 则这个方法将返回一个空字符串，如果 from 比 to大，这个将先交换两个参数的值，然后返回它们之间的子串。这个方法不接受负数参数。  

33. 开始加载文档，`document.readyState == 'loading'` => 非 `defer`和 `async` 脚本加载并执行， `defer` 和 `async` 脚本加载， `async`脚本加载完成后立即执行 =>  文档解析完成，`document.readyState == 'interactive'` => `defer` 脚本开始执行 => 所有 `defer`脚本执行完成后触发 DOMContentLoaded 事件，程序进入异步事件驱动阶段 => 等待图片等内容的加载以及未执行完的 `async` 脚本的执行 => 所有外部资源加载完成，脚本执行完毕。`document.readyState == 'complete'`， window对象上触发 load 事件。

34. Location对象  
    http://www.oreilly.com:1234/catalog/search.html?q=JavaScript&m=10#results  
    hash: #results  
    host: http://www.oreilly.com:1234  
    hostname: http://www.oreilly.com  
    port: 1234  
    pathname: /catalog/search.html  
    protocol: http:   
    search: ?q=JavaScript&m=10  
    href: http://www.oreilly.com:1234/catalog/search.html?q=JavaScript&m=10#results  

35. 如果窗口包含多个子窗口(比如&lt;iframe&gt;元素)，子窗口的浏览历史会按时间顺序穿插在主窗口的历史中。这意味着在主窗口调用 `history.back()` 可能会导致其中一个子窗口往回跳转到前一个显示的文档，但主窗口保留当前状态不变。  

36. 作为 Window 对象属性的文档元素： 如果在 html 文档中用 id 属性来为元素命名， 并且如果 Window对象没有此名字的属性， Window对象会赋予属性，它的名字是 id 属性的值，而它们的值指向表示文档元素的 HTMLElement 对象，以下元素如果有name属性的话也会这样表现：`<a> <applet> <area> <embed> <form> <frame> <iframe> <img> <object>`。有 name 或 id 属性的 `<iframe>` 元素，这个变量会引用表示当前 `<iframe>` 元素创建的嵌套的浏览器窗体的 Window 对象。  

37. Window 对象如果有 name 属性，就用它保存名字。该属性是可写的，并且脚本可以随意设置它。如果传递给 `window.open()`一个除 `_blank`之外的名字，通过该调用创建的窗口将以该名字作为 name 属性的初始值。 如果 `<iframe>`  元素有 name 属性，表示该 iframe 的 Window 对象会用它作为 name 属性的初始值。  

38. 窗口名字可以用来允许 `open()` 方法引用已存在的窗口，并同时可以作为 `<a>` 和 `<form>` 元素上 HTML target 属性的值， 用来表示引用的问题或表单提交结果应该显示在命名的窗口中。  

39. `<iframe>` 元素有 contentWindow 属性，引用该窗体的 Window 对象，也可以进行反向操作——从表示窗体的 Window 对象来获取该窗体的`<iframe>`元素——用 Window对象的 frameElement 属性。表示顶级窗口的 Window 对象的 frameElement 属性为 null, 窗体的 Window 对象的 frameElement 属性不为 null。  

40. 每个 Window 对象都有一个 frames 属性，它引用自身包含的窗口或窗体的子窗体。frames 属性引用的是类数组对象，并可以通过数字或窗体名索引。注意，frames[] 数组里的元素是 Window 对象，而不是 `<iframe>` 元素。  

41. 表示 HTML 属性的值通常是字符串。当属性为布尔值或数值，属性也是布尔值或数值，而不是字符串。事件处理程序属性总是为 Function对象(或 null)。任何 HTML 元素的 style 属性值是 CSSStyleDeclartion 对象而不是字符串。  

42. 查询窗口滚动条位置  
```javascript
  // 以一个对象的x和y属性的方式返回滚动条的偏移量  
  function getScrollOffsets(w) {
	var w = w || window;
	if(w.pageXOffset != null)
	  return { x: w.pageXOffset, y: w.PageYOffset };

	var d = w.document;
	if(d.compatMode == 'CSS1Compat')
	  return { x: d.documentElement.scrollLeft, y: d.documentElement.scrollTop };

	return { x: d.body.scrollLeft, y: d.body.scrollTop };
}
```     



43. 查询窗口的视口尺寸  
```javascript
  // 作为一个对象的w和h属性返回视口的尺寸
  function getViewportSize(w) {
	var w = w || window;
	if(w.innerWidth != null)
	  return { w: w.innerWidth, h: w.innerHeight };

	var d = w.document;
	if(d.compatMode == 'CSS1Compat')
	  return { w: d.documentElement.clientWidth, h: d.documentElement.clientHeight };

	return { w: d.body.clientWidth, h: d.body.clientHeight };
}
```  

44. 如果想查询内联元素每个独立的矩形，调用 `getClientRects()` 方法来获得一个只读的类数组对象，它的每个元素类似于 `getBoundingClientRect()` 返回的矩形对象。  

45. Window 对象的 `scrollTo()` (和其同义词`scroll()`)接受一个点的x 和 y 坐标(文档坐标)并作为滚动条的偏移量设置它们。 `scrollBy()`的参数是相对的，并在当前滚动条的偏移量上增加。  

46. 在 HTML 元素上有 `scrollIntoView()` 方法，该方法保证了元素能在视口中可见，默认情况下它试图将元素的上边缘放在尽量接近视口的上边缘，如果只传递 false 作为参数，它将试图将元素的下边缘放在尽量接近视口的下边缘。  

47. 用浏览器窗口对象的 `getComputedStyle()`方法来获得一个元素的计算样式，此方法的第一个参数就是要获取其计算样式的元素，第二个参数也是必须的，通常是 null 或空字符串，但它也可以是命名CSS伪对象的字符串，如':before'.  

48. 计算样式是只读的。计算样式的值是绝对值，类似百分比和点之类相对的单位将全部转换为绝对值。所有指定尺寸的属性都有一个以像素为度量单位的值。该值将是一个冠以"px"后缀的字符串，其值是颜色属性将以"rgb(#,#,#)"或"rgba(#,#,#,#)"的格式返回。计算样式不计算复合属性，它们只基于最基础的属性，例如，不要查询 margin 属性，应该使用 marginLeft 和 marginTop 等。 计算样式的cssText属性未定义。  

49. 某些事件类型通常直接在浏览器上而非任何特定文档元素上触发，在JS中，这些事件处理程序在 Window 对象上注册。 在 HTML 中，会把它们放到 `<body>` 标签上，但浏览器会在 Window 对象上注册它们。  

50. 对于文本输入域，只有用户和表单元素完成交互并通过 Tab 键或单击的方式移动焦点到其他元素上时才会触发 change 事件。 响应通过键盘改变焦点的表单元素在得到和失去焦点时会分别触发 focus 和 blur 事件，这两个事件不冒泡。  

51. 一个元素可以通过键盘命令获得焦点，如Tab键，或按鼠标点击的元素。当一个元素获得焦点时，focus事件被触发。此事件起初适用于有限的元素，比如表单元素（`<input>, <select>`等）和链接元素（`<a href>`）。在最近版本的浏览器中，该事件可以扩展到所有包括通过显式设置tabindex属性的元素类型。    

52. 当用户移动鼠标指针从而使它悬停到新元素上时，浏览器就会在该元素上触发 `mouseover` 事件。当鼠标移动指针从而使它不再悬停在某个元素上时，浏览器就会在该元素上触发 `mouseout` 事件。    

53.  3级DOM事件规范标准化了冒泡的 `focusin` 和 `focusout` 事件来取代不冒泡的 `focus` 和 `blur` 事件。标准化了不冒泡的 `mouseenter` 和 `mouseleave` 事件来取代冒泡的 `mouseover` 和 `mouseout` 事件。    

54. 除了像 type 和 timestamp 这样常用的 Event 对象属性外， 与这些 progress 事件相关联的事件对象还有3个有用的属性。 loaded 属性是目前传输的字节数值， total 属性是 'Content-Length' 头传输的数据的整体长度(单位是字节)，如果不知道内容长度则为0.最后知道内容长度则 lengthComputable 属性为 true 否则为 false。    

55. cookie的作用域并不是局限在浏览器的单个窗口内，它的有效期和整个浏览器进程而不是单个浏览器窗口的有效期一致。     

<br>
<br>

## jQuery

1. `css()` 方法不可获取复合属性，但可设置复合属性，和原生JS操作CSS一致。可以在style属性上设置复合属性，但计算样式无法获取复合属性。  

2. 当不带参数调用时， `text()` 方法返回所有匹配元素的所有子孙文本节点的纯文本内容。 如果不带参数调用 `html()` 方法，它返回第一个匹配元素的 HTML 内容。  

3. `width()` 和 `height()` 方法拥有其他4个方法(以 inner 和 outer 开头)所没有的特性。首先，当 jQuery 对象的第一个元素是 Window 或 Document 对象时， `width()` 和 `height()` 方法返回的窗口的视口大小或文档的整体尺寸。其他方法只适用于元素，不适用窗口和文档。另一个特性是这两个方法可以是 setter 也可以是 getter。  

4. jQuery自定义选择符的语法与CSS中的伪类选择符的语法相同，即选择符以冒号(:)开头，因为JS数组采用从0开始的编号方式，所以eq(1)取得的是集合中的第2个元素。而CSS则是从1开始的。因此CSS选择符 `$('div:nth-child(1)')` 取得的是作为其父元素的第一个子元素的所有div元素。  

5. `<div> <span> <a> </a> </span> <p>  </p> <div>` 假设在我们的例子中， 为`<div>` 添加了一个 mouseout 事件的处理程序，当用户鼠标指针退出这个 `<div>` 时，会按照预期运行 mouseout 处理程序。因为这个过程发生在顶层元素上，所以其他元素不会去的这个事件。但是当指针从 `<a>` 元素上离开时， `<a>` 元素也会取得一个 mouseout 事件。然后这个事件会向上冒泡到 `<span>` 和 `<div>`, 从而触发上述的事件处理程序。  

6. HTML属性和 DOM 属性有一点区别。HTML 属性是指页面标记中放在引号中的值，而DOM属性则是指通过 JS 能够存取的值。某些 DOM 属性，例如 `nodeName, nodeType, selectedIndex和 childNodes`在 HTML 中没有对应的属性，因此通过 `attr()` 方法就没办法操作它们。此外，数据类型方面也存在差异，比如 HTML 中的 checked 属性是一个字符串，而 DOM 中的 checked 属性是一个布尔值。对于布尔值属性，最后是测试 DOM 属性而不是 HTML属性。  

<br>
<br>

## Web 相关  

1. 慢启动以保守的窗口初始化连接，随后的每个往返都会成倍提高传输的数据量，直到超过接收端的流浪控制窗口，即系统配置的拥塞阈值窗口， 或者有分组丢失为止，此时拥塞预防算法介入。拥塞预防算法把丢包作为网络拥塞的标志，即路径中某个连接或路由器已经拥堵了，以至于必须采取删包措施。  

2. 应用层协议协商ALPN作为 TLS 的扩展，让我们能在 TLS 握手的同时协商应用协议，从而省掉了 HTTP 的 Upgrade 机制所需要的额外的往返时间，具体来说，整个过程如下：  
   + 客户端在 ClientHello 消息中追加一个新的 ProtocolNameList 字段，包含自己支持的应用协议
   + 服务器检查 ProtocolNameList 字段，并在 SeverHello消息中从 ProtocolName 字段返回选中的协议。  

3. 信道容量即最大信息速率  
   $$C = BW * \log_2(1 + \frac{\ S }{ N })$$  
  + C 是信道容量，单位是 bit/s  
  + BW是可用带宽，单位是 Hz。
  + S是信号，N是噪声，单位是W  

4. 并非所有频率范围的性能都一样，低频信号传输距离远，覆盖范围广(大蜂窝)，但要求天线更大。而且竞争激烈。另一方面，高频信号能传输更多数据，但传输距离不远，因此覆盖范围小(小蜂窝)，需要更多的基础设施投入。  

5. 把 HTTP 消息分解为独立的帧，交错发送，然后在另一端重新组装是 HTTP2.0 最重要的一项增强，事实上，这个机制在整个Web技术栈中会引发一系列连锁反应，从而带来巨大的性能提升：  
   + 可以并行交错地发送请求，请求之间互不影响。
   + 可以并行交错地发送响应，响应之间互不干扰
   + 只使用一个连接即可并行发送多个请求和响应
   + 消除不必要的延迟，从而减少页面加载的时间。

6.   
```
GET /page HTTP/1.1  
Host: server.example.com
Connection: Upgrade, HTTP2-Settings
Upgrade: HTTP/2.0
HTTP2-Settings: (SETTINGS payload)

HTTP/1.1 200 OK
Content-Length: 243
Content-Type: text/html

(... HTTP 1.1  response...)
    (or)   

HTTP/1.1 101 Switching Protocols  
Connection: Upgrade
Upgrade: HTTP/2.0

(... HTTP2.0 response...)
```

7. CORS请求会省略cookie和HTTP认证等用户凭据。客户端被限制只能发送“简单的跨源请求”包括只能使用的方法(GET, POST和HEAD)，以及只能访问可以通过XHR发送并读取的HTTP首部。  

8. 要启用cookie和HTTP认证，客户端必须在发送请求时通过XHR对象发送额外的属性( withCredentials)， 而服务器也必须以适当的首部(Access-Control-Allow-Credentials)响应，表示它允许应用发送用户的隐私数据。类似地，如果客户端需要写或者读自定义的HTTP首部，或者想要使用"不简单的方法"发送请求，那么它必须首先要获得第三方服务器的许可，即向第三方服务器发送一个预备(preflight)请求。  

9. 起始行和首部就是由行分隔符的ASCII文本。每行都以一个由两个字符组成的行终止序列作为结束。其中包括一个回车符(ASCII码13)和一个换行符(ASCII码10)，这个行终止序列可以写作CRLF。  

10. HTTP的Connection首部字段中有一个逗号分隔的连接标签列表，这些标签为此连接指定了一些不会传播到其他连接中去的选项。比如可以用`Connection: close` 来说明发送完下一条报文之后必须关闭的连接。  

11. Connection首部可以承载3种不同类型的标签  
   + HTTP首部字段名，列出了只与此连接有关的首部
   + 任意标签值，用户描述此连接的非标准选项
   + 值close，说明操作完成之后需关闭这条连接  

12. 如果连接标签中包含了一个HTTP首部字段的名称，那么这个首部字段就包含了一些与连接有关的信息，不能将其转发出去，在将报文转发出去之前，必须删除Connection首部列出的所有首部字段。  

13. 通过特殊的HTTP Cache-Control 首部和 Expires 首部，HTTP让原始服务器向每个文档附加了一个"过期日期".在缓存文档过期之前，缓存可以以任意频率使用这些副本，而无需与服务器联系——当然，除非客户端请求中包含有阻止提供已缓存或未验证资源的首部。

14. 下面的规则说明了在若干不同的情况下如何正确计算主体的长度和结束位置。这些规则应当按顺序应用，谁先匹配就用谁。  
  1. 如果特定的HTTP报文类型中不允许带有主体，就忽略 `Content-Length` 首部，它是对(没有实际发送出来的)主体进行计算的。这种情况下， `Content-Length` 首部是提示性的，并不说明实际的主体长度。
  2. 如果报文中含有描述传输编码的 `Transfer-Encoding` 首部，那实体就应由一个称为"零字节块"的特殊模式结束，除非报文已经因连接关闭而结束。
  3. 如果报文中含有`Content-Length`首部（并且报文类型允许有实体主体），而且没有非恒等的 `Transfer-Encoding` 首部字段，那么 `Content-Length`的值就是主体的长度。如果收到的报文中既有`Content-Length`首部字段又有非恒等的`Transfer-Encoding`字段，那么必须忽略`Content-Length`， 因为传输编码会改变实体主体的表示和传输方式。  

15. 如果HTTP请求中没有包含`Accept-Encoding` 首部，服务器就可以假设客户端能够接受任何编码方式(等价以发送`Accept-Encoding: *`), 客户端可以给每种编码附带Q（质量）值参数来说明编码的优先级。Q值的范围从0.0到1.0, 0.0说明客户端不想接受所说明的编码，1.0则表示最希望使用的编码，‘*’表示任何其他方法。  

16.  `Transfer-Encoding` 告知接收方为了可靠地传输报文，已经对其进行了何种编码。 `TE`,用在请求首部中，告知服务器可以使用哪些传输编码扩展。  

17. 分块编码是相当简单的，它由起始的HTTP响应首部块开始，随后就是一系列分块。每个分块包含一个长度值和该分块的数据。长度值是十六进制形式并将CRLF与数据分隔开，分块中的数据的大小以字节计算，不包括长度值和数据之间的CRLF序列以及分块结尾的CRLF序列。最后一块有点特别，它的长度值是0，表示“主体结束”。  


<br>
<br>

## 移动Web

1. 在手机上，视口与移动端浏览器屏幕宽度不再关联，用来CSS布局的视口叫布局视口。通常由浏览器决定。  

2. 视觉视口指用户正在看到的网站的区域。  

3. 布局视口的默认宽度并不是一个理想的宽度。这就是为什么苹果和其他效仿苹果的浏览器厂商，会引进理想视口，它是对设备来说最理想的布局视口尺寸。只有主动往页面里添加 meta 视口标签时理想视口才会生效。
