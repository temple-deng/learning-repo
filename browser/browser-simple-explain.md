# Browser

# 浏览器

## 浏览器架构

目前 Chrome 浏览器的架构是这样的：   

![browser-arch2](https://raw.githubusercontent.com/temple-deng/markdown-images/master/browser/browser-arch2.png)    

在较高的层面来看，Browser 进程负责协调各个不同的进程以及应用的不同部分。每个 tab 页都会分配一个
renderer 进程。    

## 各个进程的功能


进程 | 功能
----------|---------
 Browser | 控制应用的 "chrome" 部分，包括地址栏，书签，后退和前进按钮。同时也会处理那些一个浏览器不可见的部分，例如网络请求和文件访问
 Renderer | 控制一个 tab 页中展示网页的所有部分
 Plugin | 控制被网页使用的任意插件
 GPU | 独立于其他进程处理 GPU 任务

### 节省内存

通常来说，当 Chrome 的内存使用到达一个阈值的时候，通常就会将一个站点的多个 tab 合并到一个渲染
进程中，以节省内存。    

同样的理念对浏览器进程也是适用的，Chrome 目前正在进行架构的变动，以便可以让浏览器的各个部分作为
一项服务运行，从而可以轻松地拆分出多个进程或者合并到一个进程。    

### 每个 frame 一个 renderer 进程 - Site Isolation

注意这里的 frame 应该与之前将 webkit 的那本书里介绍的一直，每个窗口，每个 iframe 应该都可以
看做是一个 frame。   

站点孤立 site isolation 是最近才引入 Chrome 的功能，即每个跨站的 iframe 运行在一个分离的
renderer 进程上。为什么要引入这个功能呢，因为之前提到了一个 tab 一个渲染进程，那跨站的两个
站点就会共享内存区，虽然有同源策略的限制，但还是带来了安全攻击的隐患。因此直接划分开进程就安全
多了。   

![isolation](https://raw.githubusercontent.com/temple-deng/markdown-images/master/browser/isolation.png)    

# 导航工作流

Browser 进程处理了一个 tab 页以外的所有事务。其包含多个线程，例如 UI 线程负责绘制浏览器的
按钮和输入框，网络线程负责处理网络堆栈中的数据，存储线程处理对文件的访问等。当我们在地址栏
输入 URL 时，显然我们的输入是被 UI 线程处理了。    

## 第一步：处理输入

首先 UI 线程要确认，输入是个搜索词，还是一个 URL。根据解析后的结果，浏览器才会决定把数据发送
给搜索引擎还是到我们请求的站点。    

## 第二步：开始导航

当用户按下回车后，UI 线程实例化一个网络调用，去请求站点的内容。这里面可能会包含 DNS 查询的步骤。   

## 第三步：读取响应

网络线程会查看响应的 Content-Type 首部，如果是个 HTML 文件，就将数据传递给渲染进程。但如果
是个 zip 文件或其他一些文件类型，可能意味着这是个下载请求，因此数据被传送给下载管理器。    

这里面可能会进行一些安全检查。    

## 第四步：搜索一个渲染进程

一旦所有检查都完事，网络线程就通知 UI 线程一切准备就绪。UI 线程就会找一个渲染进程去负责
页面的渲染。    

## 第五步：提交导航

现在数据和渲染进程都准备就绪了，然后 browser 进程发起一个 IPC 到渲染进程提交本次导航。同时
也会将数据流传递给渲染进程。一旦 browser 进程收到了渲染进程对提交的确认，此时导航就已经完成了，
文档加载阶段开始。    

此时，UI 线程会更新地址栏，安全提示符和站点配置。   

## 额外步骤：初始加载完成

一旦导航提交了，渲染进程就开始加载资源并渲染页面。一旦完成了渲染，就发送一个 IPC 到 browser
进程（在页面上所有的 frames　都触发了 `onload` 事件并且事件回调也执行完了），这个时候，UI
线程就停止那个加载旋转图表的旋转了。   

## 包含 SW 的情况

SW 是运行在一个渲染进程中的，那当发出导航请求的时候，browser 进程是如何知道这个站点存在一个 SW 呢？   

当注册一个 SW 时，SW 的 scope 会被保存下来。当导航动作发生时，网络线程会检查域中注册的 SW 的
scopes，如果一个 SW 为这个 URL 注册了，那 UI 线程就搜寻一个渲染进程去执行 SW 的代码。   

## 导航预加载

如果 SW 最终决定去从网络取数据的话，这期间其实就浪费了一些时间。因此，浏览器采用预加载的机制来
利用这段时间。也就是在 SW 启动的同时并行请求加载资源。   

# 渲染

## 渲染线程处理页面内容

渲染进程负责了一个 tab 中的所有东西。主线程处理大部分要发送给用户的代码。Compositor 和 Raster
线程也运行在渲染进程内。    

渲染进程的核心工作就是将 HMTL，CSS 和 JS 代码转化成一个用户可以交互的页面。   

## 代码解析

解析 HTML 的过程中如果发现了外部资源，会给 browser 进程的网络线程发请求去请求资源。   

## 布局

主线程遍历 DOM 树和计算样式，创建布局树。布局树和 DOM 树类似，但是只包含页面可见的内容，
`display:none` 的节点肯定就不存在于布局树上，不过伪元素是可能包含在布局树中。   

## 绘制

主线程遍历布局树，创建绘制记录 paint records。paint record 是一份类似 "先背景，再矩形"这样
绘制流程的笔记。有点类似我们画 canvas 的流程。   

如果我们在 JS 中执行大量的内容，那么主线程上用来计算每一帧样式的操作就会被阻塞。（Why?）   

## 组合

将上述已知的所有信息转变为屏幕上的像素，叫做光栅化 rasterizing。    

组合 compositing 是一种将一个页面分成多层，然后分别光栅化，然后在一个独立的组合器线程上将各层
组合到一个页面上的技术。    

这样的话，在滚动的时候，每层都光栅化好了，我们只要重新组合一个新帧即可。而不用重新光栅化新的内容。    

为了将不同的元素分到不同的层中，主线程在遍历布局树的过程中会创建分层树 layer tree。如果一个页面
的某个部分应该在一个独立的层上，我们可以使用 `will-change` 属性提示浏览器。   

一旦创建了分层树，主线程就将所有信息提交给组合器线程。组合器线程将每层光栅化。而组合器线程又会将
一层分成多个片 tiles，然后将每个片发送给光栅线程。光栅线程会将每片光栅化，然后将它们存储在 GPU
内存中。    

一旦各个片都被光栅化了，组合器线程收集这些叫做 draw quads 的片信息，创建一个 **组合器帧**。   


Draw quads| 包含例如片在内存中的位置，在页面中哪部分绘制这个片等等信息
---------|----------
 Compositor frame | 页面一帧，即页面所有 draw quads 的集合

这个组合器帧然后通过 IPC 提交给浏览器进程。这时，由于浏览器 UI 变动，从 UI 线程中来的另一个
组合器帧或者由扩展生成的来自其他渲染进程的组合器帧可能也被添加进 browser 进程。这些组合器帧
发送给 GPU 来展示在屏幕上。    

![composit](https://raw.githubusercontent.com/temple-deng/markdown-images/master/browser/composit.png)   

# 交互

## 浏览器角度的输入

从浏览器角度来看，用户的任意姿势都是输入。当用户进行了一个交互，browser 进程会第一个接收到这个
手势，不过浏览器也只是知道这个手势发生的坐标，因为 tab 里面的内容都是渲染进程控制的。然后
browser 进程将事件类型及其坐标发送给渲染进程。渲染进程来搜索其事件目标，然后运行绑定的回调。   

## 组合器接收输入事件

如果页面中没有对任何输入事件的监听，那组合器线程可以在滚动的时候直接独立于主线程创建一个新的
帧。     

由于执行 JS 是主线程的工作，当页面被组合后，组合器线程会将页面中含有监听事件的区域标记出来，
叫做 "Non-Fast Scrollable Region"。有了这个信息后，如果有事件发生在这些区域，组合器线程就
会将输入事件发送给主线程。   

这时就提出了一个优化的问题，在使用事件委托时，如果直接在 body 上监听，那整个页面都变成了
Non-Fast Scrollable Region，那样每次有输入的时候，组合器线程都要等主线程处理完后才能开始
绘制帧。    

为了减少这种性能的降低，可以传入一个 `passive: true` 配置项，提示浏览器我们仍然希望在主线程
上监听这个事件，但是同时组合器线程也可以开始组合新帧。   

```js
document.body.addEventListener('touchstart', event => {
    if (event.target === area) {
        event.preventDefault()
    }
 }, {passive: true});
```    