# 第 1 章 计算机系统漫游

<!-- TOC -->

- [第 1 章 计算机系统漫游](#第-1-章-计算机系统漫游)
  - [1.2 程序被其他程序翻译成不同的格式](#12-程序被其他程序翻译成不同的格式)
  - [1.4 处理器读并解释储存在内存中的指令](#14-处理器读并解释储存在内存中的指令)
    - [1.4.1 系统的硬件组成](#141-系统的硬件组成)
  - [1.5 高速缓存至关重要](#15-高速缓存至关重要)
  - [1.9 重要主题](#19-重要主题)
    - [1.9.2 并发和并行](#192-并发和并行)
- [第一部分 程序结构和执行](#第一部分-程序结构和执行)
- [第 2 章 信息的表示和处理](#第-2-章-信息的表示和处理)
  - [2.1 信息存储](#21-信息存储)
    - [2.1.2 字数据大小](#212-字数据大小)
    - [2.1.3 寻址和字节顺序](#213-寻址和字节顺序)
    - [2.1.4 表示字符串](#214-表示字符串)
    - [2.1.6 布尔代数简介](#216-布尔代数简介)
    - [2.1.9 C 语言中的移位运算](#219-c-语言中的移位运算)
  - [2.2 整数表示](#22-整数表示)
    - [2.2.2 无符号数的编码](#222-无符号数的编码)
    - [2.2.3 补码编码](#223-补码编码)
    - [2.2.4 有符号数和无符号数之间的转换](#224-有符号数和无符号数之间的转换)
    - [2.2.6 扩展一个数字的位表示](#226-扩展一个数字的位表示)
    - [2.2.7 截断数字](#227-截断数字)
  - [2.3 整数运算](#23-整数运算)
    - [2.3.1 无符号加法](#231-无符号加法)
    - [2.3.2 补码加法](#232-补码加法)
    - [2.3.4 无符号乘法](#234-无符号乘法)
    - [2.3.5 补码乘法](#235-补码乘法)
    - [2.3.6 乘以常数](#236-乘以常数)
    - [2.3.7 除以 2 的幂](#237-除以-2-的幂)
  - [2.4 浮点数](#24-浮点数)
    - [2.4.1 二进制小数](#241-二进制小数)
    - [2.4.2 IEEE 浮点表示](#242-ieee-浮点表示)
    - [2.4.3 数字示例](#243-数字示例)
    - [2.4.4 舍入](#244-舍入)
    - [2.4.6 C 语言中的浮点数](#246-c-语言中的浮点数)

<!-- /TOC -->

## 1.2 程序被其他程序翻译成不同的格式    

```c
// hello.c
#include <stdio.h>

int main() {
  printf("hello world\n");
  return 0;
}
```    

hello 程序的生命周期是从一个高级 C 语言程序开始的，因为这种形式能够被人读懂。然后，为了
在系统上运行 hello.c 程序，每条 C 语句必须被其他程序转化为一系列的低级 **机器语言** 指令。
然后这些指令按照一种称为 **可执行目标程序** 的格式打好包，并以二进制磁盘文件的形式存放
起来。目标程序也称为 **可执行目标文件**。   

在 Unix 系统上，从源文件到目标文件的转化是由编译器驱动程序完成的：   

`linux> gcc -o hello hello.c`    

这个翻译过程可分为四个阶段完成，执行这四个阶段的程序（预处理器、编译器、汇编器和链接器）
一起构成了 **编译系统**：    

![compilation-system](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/compilation-system.png)   

+ _预处理阶段_。预处理器 cpp 根据以字符 # 开头的命令，修改原始的 C 程序。比如 hello.c
中的第 1 行的 `#include <stdio.h>` 命令告诉预处理器读取系统头文件 stdio.h 的内容，并把
它直接插入程序文本中。结果就得到了另一个 C 程序，通常是以 .i 作为文件扩展名。
+ _编译阶段_。编译器 ccl 将文本文件 hello.i 翻译成文本文件 hello.s，它包含一个汇编语言
程序。该程序包含函数 main 的定义，如下所示：   
```asm
1  main:
2    subq     $8, %rsp
3    movl     $.LCO, %edi
4    call     puts
5    movl     $0, %eax
6    addq     $8. %rsp
7    ret
```    
+ _汇编阶段_。接下来，汇编器 as 将 hello.s 翻译成机器语言指令，并把这些指令打包成一种
叫做 **可重定位目标程序**(relocatable object program)的格式，并将结果保存在目标文件
hello.o 中。hello.o 文件是一个二进制文件，它包含的 17 个字节是函数 main 的指令编码。
+ _链接阶段_。printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中。而这个
文件必须以某种方式合并到我们的 hello.o 程序中。链接器 ld 就负责处理这种合并。结果就得到
hello 文件，它是一个可执行目标文件，可以被加载到内存中，由系统执行。   

看这个意思，可**程序一般是指一种文件的格式，而可\*\*文件就是最后的某种文件。   

## 1.4 处理器读并解释储存在内存中的指令

### 1.4.1 系统的硬件组成

![system-hardware](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/system-hardware.png)   

1. **总线**    

贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。通常总线被
设计成传送定长的字节块，也就是 **字**(word)。字中的字节数（即字长）是一个基本的系统参数，
各个系统中都不尽相同，现在大多数机器字长要么是 4 个字节，要么是 8 个字节。    

2. **I/O 设备**    

每个 I/O 设备都通过一个 **控制器** 或 **适配器** 与 I/O 总线相连。控制器与适配器之间的
区别主要在于它们的封装方式。控制器是 I/O 设备本身或者系统的主板上的芯片组。而适配器则
是一块插在主板插槽上的卡。无论如何，它们的功能都是在 I/O 总线和 I/O 设备之间传递信息。    

3. **处理器**    

处理器的核心是一个大小为一个字的存储设备（或寄存器），称为 **程序计数器**(PC)。在任何
时刻，PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）。     

从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数
器，使其指向下一条指令。在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列
的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，
然后更新 PC，使其指向下一条指令。    

这样的简单操作并不多，它们围绕着主存、寄存器文件和 **算术/逻辑单元**(ALU) 进行。寄存器
文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU 计算
新的数据和地址值。下面是一些简单操作的例子，CPU 在指令的要求下可能会执行这些操作：   

+ **加载**：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。
+ **存储**：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。
+ **操作**：把两个寄存器的内容复制到 ALU，ALU 对这两个字做算术运算，并将结果存放到一个
寄存器中，以覆盖该寄存器中原来的内容。
+ **跳转**：从指令本身中抽取一个字，并将这个字复制到程序计数器中，以覆盖 PC 中原来的值。    

处理器看上去是他的指令集架构的简单实现，但是实际上现代处理器使用了非常复杂的机制来加速
程序的执行。因此，我们将处理器的 **指令集架构** 和处理器的 **微体系结构** 区分开来：
指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的。   

## 1.5 高速缓存至关重要

一个典型的寄存器文件只存储几百字节的信息。看这个意思，一个单个寄存器应该就是一个字长的
大小，而一个寄存器文件通常是多个寄存器的集合。    

位于处理器芯片的 **L1 高速缓存** 的容量可以达到数万字节，访问速度几乎和访问寄存器文件
一样快。一个容量为数十万到数百万字节的更大的 **L2 高速缓存** 通过一条特殊的总线连接到
处理器。进程访问 L2 高速缓存的时间要比访问 L1 高速缓存的时间长 5 倍。L1 和 L2 高速缓存
使用一种叫做静态随机访问存储器(SRAM)的硬件技术实现的。

## 1.9 重要主题

### 1.9.2 并发和并行

我们用的术语 **并发** 是一个通用的概念，指一个同时具有多个活动的系统；而术语 **并行**
指的是用并发来使一个系统运行得更快。并行可以在计算机系统的多个抽象层次上运用。在此，我们
按照层次结构中由高到低的顺序重点强调三个层次。    

1. **线程级并发**     

超线程，有时称为 **同时多线程**，是一项允许一个 CPU 执行多个控制流的技术。它涉及 CPU 某些
硬件有多个备份，比如程序计数器和寄存器文件，而其他的硬件部分只有一份，比如执行浮点算术运算
的单元。常规的处理器需要大约 20 000 个时钟周期做不同线程间的切换，而超线程的处理器可以在
单个周期的基础上决定要执行哪一个资源。这使得 CPU 能够更好地利用它的处理资源。比如，假设
一个线程必须等到某些数据被装载到高速缓存中，那 CPU 就可以继续去执行另一个线程。     

那也就是说可能我们装载程序的时候，就把不同的线程内容装载到不同的硬件备份中，从这个角度来看，
执行单元应该都只有一份，但一些存储单元应该都是有两份，这样当线程切换时，我们压根不用从内存
中保存和调出线程的上下文，而是直接让执行单元执行另一个 PC 中保存的指令即可。   

2. **指令级并行**    

首先我们需要明确一点，时钟周期和指令并不是一一对应的，并不是说一个时钟周期执行一条指令，
另外一条指令和其要执行的操作也不是一一对应的，一条指令可能要完成多个操作。   

在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为 **指令级并行**。最近的处理器
可以保持某个时钟周期 2~4 条指令的执行速率。其实每条执行从开始到结束需要长得多的时间，大约
20 个或者更多周期，但是处理器使用了非常多的聪明技巧来同时处理多达 100 条指令。    

在流水线中，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，
每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令的不同部分。    

如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为 **超标量** 处理器。大多数
现代处理器都支持超标量操作。   

3. **单指令、多数据并行**    

在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种
方式称为 **单指令、多数据**，即 SIMD 并行。    


# 第一部分 程序结构和执行

我们对计算机系统的探索是从学习计算机本身开始的，它由处理器和存储器子系统组成。在核心部分，
我们需要方法来表示基本数据类型，比如整数和实数运算的近似值。然后，我们考虑机器级指令如何
操作这样的数据，以及编译器又如何将 C 程序翻译成这样的指令。接下来，研究几种实现处理器的
方法，帮助我们更好地了解硬件资源如何被用来执行指令。    

# 第 2 章 信息的表示和处理

我们研究三种最重要的数字表示。*无符号* (unsigned)编码基于传统的二进制表示法，表示大于或者
等于零的数字。*补码* (two's-complement)编码是表示有符号整数的最常见的方式。*浮点数* (floating-point)
编码是表示实数的科学计数法的以 2 为基数的版本。   

计算机的表示法是用有限数量的位来对一个数字编码，因此，当结果太大以致不能表示时，某些计算
就会溢出。例如，在 int32 类型情况下，计算表达式 200\*300\*400*500 会得出结果 -884 901 888.    

另一方面，整数的计算机运算满足人们所熟知的真正整数运算的许多性质。例如，利用乘法的结合律
和交换律，计算下面任何一个 C 表达式，都会得出一个结果 -884 901 888:   

+ (500 * 400) * (300 * 200)
+ ((500 * 400) * 300) * 200
+ ((200 * 500) * 300) * 400
+ 400 * (200 * (300 * 500))    

计算机可能没有产生期望的结果，但是至少它是一致的！    

浮点运算有完全不同的数学属性。虽然溢出会产生特殊的值 +∞，但是一组正数的乘积总是正的。由于
表示的精度有限，浮点运算是不可结合的。例如，在大多数机器上，C 表达式 (3.14 + 1e20) - 1e20
求得的值会是 0.0，而 3.14 + (1e20 - 1e20) 求得的值会是 3.14。   

整数运算和浮点数运算会有不同的数学属性是因为他们处理数字表示有限性的方式不同——整数的表示
虽然只能编码一个相对较小的数值范围，但是这种表示时精确的；而浮点数虽然可以编码一个较大的
数值范围，但是这种表示只是近似的。   

## 2.1 信息存储

### 2.1.2 字数据大小

每台计算机都有一个 **字长**，指明指针数据的标称大小。因为虚拟地址是以这样的一个字来编码的，
所以决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长为 w 位的机器
而言，虚拟地址的范围是 0 ~ 2<sup>w</sup>-1，程序最多访问 2<sup>w</sup> 个字节。    

我们将程序称为 “32位程序” 或 “64位程序” 时，区别在于该程序是如何编译的，而不是其运行的
机器类型。   

### 2.1.3 寻址和字节顺序

对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及在内存中如何
排列这些字节。在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用
字节中最小的地址。     

排列表示一个对象的字节有两个通用的规则。考虑一个 w 位的整数，其位表示为 [x<sub>w-1</sub>,
w<sub>w-2</sub>, ..., x<sub>1</sub>, x<sub>0</sub>]。假设 w 是 8 的倍数，这些位就
能被分组成字节，某些机器在内存中按照从最低有效字节到最高有效字节的顺序存储对象，而另一些
机器则按照从最高有效字节到最低有效字节的顺序存储。前一种规则称为 **小端法**，后一种规则
称为 **大端法**。    

假设变量 x 的类型为 int32, 位于地址 0x100 处，它的十六进制值为 0x01234567。地址范围
0x100~0x103 的字节顺序依赖于机器的类型：    

![big-endian-and-little-endian](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/big-little-endian.png)   

大多数 Intel 兼容机都只用小端模式。   

对于大多数应用程序员来说，其机器所使用的字节顺序是完全不可见的。无论为哪种类型的机器所
编译的程序都会得到同样的结果。不过有时候，字节顺序会成为问题。首先，是在不同类型的机器
之间通过网络传送二进制数据时，一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者
反过来。     

### 2.1.4 表示字符串

C 语言中字符串被编码为一个以 null(acsii 码为0)字符结尾的字符数组。    

### 2.1.6 布尔代数简介

**布尔代数和布尔环**    

对于任意整数 w &gt; 0，长度为 w 的位向量上的布尔运算 |, & 和 ~ 形成了一个布尔代数。最
简单的情况是 w = 1 时，只有 2 个元素；但是对于更普遍的情况，有 2<sup>w</sup> 个长度为
w 的位向量。布尔代数和整数算术运算有很多相似之处。例如，乘法对加法的分配律 a * (b+c) =
(a * b) + (a * c)，而布尔运算 & 对 | 的分配律，a & (b | c) = (a & b) | (a & c)。
此外，布尔运算 | 对 & 也有分配律， a | (b & c) = (a | b) & (a | c)，但是对于整数我们
不能说 a + (b * c) = (a + b) * (a + c)。    

也就是 数据集合(2<sup>w</sup>个数) + 运算(|, &, ~) = 布尔代数。    

当考虑长度为 w 的位向量上的 ^, & 和 ~ 运算时，会得到一种不同的数学形式，我们称为布尔环。    

### 2.1.9 C 语言中的移位运算

右移运算 x &gt;&gt; k，一般而言，机器支持两种形式的右移：**逻辑右移** 和 **算术右移**。
逻辑右移在左端补 k 个 0，算术右移在左端补 k 个最高有效位的值。     

几乎所有的编译器/机器组合都对有符号数使用算术右移，另一方面，对于无符号数，右移必须是逻辑的。    

## 2.2 整数表示

这里需要格外注意一点，图里 x 声明为向量的，其实意指一个二进制的 0,1 串，而一个数字 x 其实
代表一个普通的数字。   

### 2.2.2 无符号数的编码

假设有一个整数数据类型有 w 位，我们可以将位向量写成 x, 表示整个向量，或者写成[x<sub>w-1</sub>,
x<sub>w-2</sub>, ..., x<sub>0</sub>]，表示向量中的每一位。把 x 看做一个二进制表示的数，
就获得了 x 的无符号表示。B2U(Binary to Unsigned 的缩写，长度为 w)：   

![Binary-to-Unsigned](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/btu.png)   

函数的输入是一个二进制向量，而输出是一个十进制的数字。    

函数 B2U 将一个长度为 w 的0,1 串映射到非负整数。因此一个采用 B2U 函数编码的无符号数的
取值范围是 0~2<sup>w</sup> - 1.一共包含 2<sup>w</sup> 个数。     

好像是这个意思，我们给定一个二进制表示的串，这个串肯定是可以代表一个数字的，但具体的是怎样的一个
数，其实取决于我们认为的编码方式，如果我们认为这个二进制串按照无符号数解释，那这个数字就可以通过
B2U 函数算出来，如果是补码的编码方式，那可以通过下面的 B2T 函数算出来。但是其实我们使用
的时候都是应该用的反向操作 U2B，即给一个数字，其为无符号编码，在内存中保存了其二进制格式的
数据。   

原理：无符号数编码的唯一性。函数 B2U 是一个双射。    

### 2.2.3 补码编码

对于很多应用，我们还希望表示负数值。最常见的有符号数的计算机表示方式就是 **补码**(two's-complenment)
形式。在这个定义中，将字的最高有效位解释为负权。我们用函数 B2T<sub>w</sub>(Binary to Two's-complement，
长度为w)来表示：    

![Binary-to-Two's-complement](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/btt.png)  

让我们来考虑一下 w 位补码所能表示的值的范围。它能表示的最小值是位向量[100....0]，其整数
值为 TMin<sub>w</sub> = -2<sub>w-1</sub>。而最大值是位向量 [01...1]，其整数值为
TMax<sub>w</sub> = 2<sup>w-1</sup> - 1.     

同无符号表示一样，在可表示的取值范围内的每个数字都有唯一一个的 w 位的补码编码。这就导出
了与无符号数相似的补码数原理：   

原理：补码编码的唯一性。函数 B2T 是一个双射。    

![important-numbers](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/important-numbers.png)  

关于这些数字，有几点值得注意。第一，补码的范围是不对称的：|TMin| = |TMax| + 1，也就是说，
TMin 没有与之对应的正数。正如我们将看到的，这导致了补码运算的某些特殊的属性，并且容易造成
程序中细微的错误。之所以有这样的不对称性，是因为一半的位模式（符号位设置为 1 的数）表示
负数，而另一半（符号位设置为0的数）表示非负数。因为 0 是非负数，也就意味着能表示的正数
比负数少一个。     

![ones-sign](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/ones-sign.png)   

**重点：**请注意补码（Two's complement）和反码（Ones' complement）中撇号的位置是不同的。
术语补码来源于这样一个情况，对于非负数 x，我们用 2<sup>w</sup> - x（这里只有一个 2）来
计算 -x 的 w 位表示。术语反码来源于这样一个属性，我们用 [111...1] - x（这里有很多个 1）
来计算 -x 的反码表示。   

### 2.2.4 有符号数和无符号数之间的转换

C 语言允许在各种不同的数字数据类型之间做强制类型转换。将有符号数强制转换成无符号数，或者
反过来，会得到什么结果呢？从数学的角度来说，可以想象到几种不同的规则。很明显，对于在两种形式
中都能表示的值，我们是想要保持不变的。另一方面，将负数转换成无符号数可能会得到 0。如果转换
的无符号数太大以至于超出了补码能够表示的范围，可能会得到 TMax。    

然而，对于大多数 C 语言的实现来说，对这个问题的回答都是从 **位级角度** 来看的，而不是数的
角度。   

考虑如下代码：   

```c
short int v = -12345;
unsigned short uv = (unsigned short) v;
printf("v = %d, uv = %u\n", v, uv);
```   

在一台使用补码的机器上，上述代码会产生如下输出：    

v = -12345, uv = 53191    

我们看到，强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。-12345 的 16 位补码
表示与 53191 的 16 位无符号表示是完全一样的。    

类似地，考虑如下的代码：    

```c
unsigned u = 4294967295u;   // UMax
int tu = (int) u;
printf("u = %u, tu = %d\n", u, tu);
```    

在一台使用补码的机器上，上述代码会产生如下输出：   

u = 4294967295, tu = -1    

对于大多数 C 语言的实现，处理 **同样字长** 的有符号数和无符号数之间相互转换的一般规则是：数值
可能会改变，但是位模式不变。让我们用更数学化的形式来描述这个规则。我们定义函数 U2B 和 T2B，
它们将数值映射为无符号数和补码形式的位表示。也就是说，给定 0 &lt;= x &lt;= UMax 范围内的
一个整数 x，函数 U2B(x) 会给出 x 的唯一的 w 位无符号表示。注意 U2B 和 T2B 都是双射。     

现在，将函数 T2U 定义为 T2U(x) = B2U(T2B(x))。这个函数的输入是一个 TMin~TMax 的数，结果
得到一个 0~UMax 的值。   

**补码转换为无符号数：**    

![t2u](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/t2u.png)   

注意上面的推导少了很重要的一步就是 **x** = T2B(x)，左边加粗的 x 代表向量 **x**，然后将式中的
向量 **x** 进行替换，就可以推导出来了。   

**无符号数转换为补码：**    

![u2t](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/u2t.png)   

### 2.2.6 扩展一个数字的位表示

一个常见的运算是在不同字长的整数之间转换，同时又保持数值不变。当然，当目标数据类型太小以
至于不能表示想要的值时，这根本就是不可能的。然而，从一个较小的数据类型转换到一个较大的类型，
应该总是可能的。    

要将一个无符号数转换为一个更大的数据类型，我们只要简单地在表示的开头添加 0，这种运算被称为
**零扩展**。    

要将一个补码数字转换为一个更大的数据类型，可以执行一个 **符号扩展**，在表示中添加最高有效位的
值。     

注意这里补码进行了符号扩展后的代表的数字是不变的，不要想当然负数加了好多 1 数字就变了，下面是
证明过程。   

![prove-sign-extension](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/prove-sign-extension.png)   

值得一提的是，如果我们同时进行了数据大小和有符号无符号之间的转换。是可能影响程序的行为的。
例如 short sx; (unsigned) sx 等价于 (unsigned) (int) sx。    

### 2.2.7 截断数字

假设我们不用额外的位来扩展一个数值，而是减少表示一个数字的位数。例如下面代码中这种情况：   

```c
int x = 53191;    // 0000cfc7
short sx = (short) x;   // -12345 cfc7
int y = sx;     // -12345 ffffcfc7
```   

当将一个 w 位的数截断成一个 k 位数字时，我们会丢弃高 w-k 位。截断一个数字可能会改变他的
值——溢出的一种形式。   

**截断无符号数：**    

![truncated-unsigned](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/truncated-unsigned.png)   

**截断补码数值：**    

![truncated-two's](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/truncated-two's.png)   

## 2.3 整数运算

### 2.3.1 无符号加法

让我们为参数 x 和 y （无符号数）定义运算 +<sup>u</sup><sub>w</sub>，其中 0 &lt;= x, y &lt; 2<sup>w</sup>，
该操作是把整数和 x + y 截断为 w 位得到的结果，再把这个结果看做是一个无符号数。这可以被
视为一种形式的模运算，对 x+y 的位级表示，简单丢弃任何权重大于 2<sup>w-1<sup> 的位就可以
计算出和模 2<sup>w</sup>。     

考虑一个 4 位数字表示，x=9 和 y=12 的位表示分别为 1001 和 1100。它们的和是 21, 5 位的
表示为 10101。但是如果丢弃最高位，我们就得到 0101，也就是十进制的 5.这就和 21 mod 16 = 5
一致。    

**无符号数加法：**    

![unsigned-addition](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/unsigned-addition.png)    

当执行 C 程序时，不会将溢出作为错误而发信号。不过有的时候，我们可能希望判定是否发生了溢出。   

**检测无符号数加法中的溢出：**   

![detect-unsigned-addition-overflow](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/detect-unsigned-addition-overflow.png)    

模数加法形成了一种数学结构，称为 **阿贝尔群**。也就是说，它是可交换和可结合的。它有一个
单位元 0，并且每个元素有一个加法逆元。考虑 w 位的无符号数的集合，执行加法运算+<sup>u</sup><sub>w</sub>.
对于每个值 x，必然有某个值 -<sup>u</sup><sub>w</sub>x 满足
-<sup>u</sup><sub>w</sub>x +<sup>u</sup><sub>w</sub> x = 0。该加法的逆操作可以表述
如下：    

原理：无符号数求反     

对满足 0 &lt;= x &lt; 2<sup>w</sup> 的任意 x，其 w 位的无符号逆元 -<sup>u</sup><sub>w</sub>x
由下式给出：    

-<sup>u</sup><sub>w</sub> = x    x=0   
                          = 2<sup>w</sup> - x,   x &gt; 0     

看不懂是什么鬼东西。   


### 2.3.2 补码加法

给定在范围 -2<sup>w-1</sup> &lt; x, y &lt;= 2<sup>w-1</sup> - 1 之内的整数值 x 和 y，
它们的和就在范围 -2<sup>w</sup> &lt;= x + y &lt;= 2<sup>w</sup> - 1 之内，要想准确
表示，可能需要 w + 1 位。定义 x+<sup>t</sup><sub>w</sub> y 为整数和 x + y 被截断
w 位的结果，并将这个结果看作是补码数。    

**补码加法：**    

![two's-complement-addition](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/two's-complement-addition.png)    

**检测补码加法中的溢出：**         

对满足 TMin &lt;= x, y &lt;= TMax 的 x 和 y，令 s = x+<sup>t</sup><sub>w</sub> y。
当且仅当 x&gt;0, y &gt; 0，但 s &lt;= 0，计算 s 发生了正溢出。当且仅当 x &lt; 0, y &lt; 0,
但 s &gt;= 0 时，计算 s 发生了负溢出。     


### 2.3.4 无符号乘法

![unsigned-multi](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/unsigned-multi.png)    

### 2.3.5 补码乘法      

![two's-multi](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/two's-multi.png)    

### 2.3.6 乘以常数

以往，在大多数机器上，整数乘法指令相当慢，需要 10 个或者更多的时钟周期，然而其他整数运算，
例如加法，减法，位级运算和移位只需要 1 个时钟周期。因此，编译器使用了一项重要的优化，试着
用移位和加法运算来代替乘以常数因子的乘法。首先，我们考虑乘以 2 的幂的情况，然后再概括成乘以
任意常数。    

乘以 2 的幂这个好理解，就是左移。当然无论是无符号运算还是补码运算，乘以 2 的幂都可能会导致
溢出。   

由于整数乘法比移位和加法的代价要大得多，许多 C 语言编译器试图以移位、加法和减法的组合来消除
很多整数乘以常数的情况。例如，假设一个程序包含表达式 x*14。利用 14 = 2<sup>3</sup> +
2<sup>2</sup> + 2<sup>1</sup>，编译器会将乘法重写为 (x &lt;&lt; 3) + (x &lt;&lt;2) +
(x &lt;&lt; 1)，将一个乘法替换为 3 个移位和 2 个加法。无论 x 是无符号的还是补码，甚至
当乘法会导致溢出时，两个计算都会得到一样的结果。更好的是，编译器还可以利用属性 14 = 2<sup>4</sup>-
2<sup>1</sup>，将乘法重写成 (x&lt;&lt;4) - (x&lt;&lt;1)。    

### 2.3.7 除以 2 的幂

在大多数机器上，整数除法要比整数乘法更慢。除以 2 的幂也可以用移位运算来实现，只不过我们
用的是右移，而不是左移。无符号和补码数分别使用逻辑移位和算术移位来达到目的。    

整数触发总是舍入到零。对于除以 2 的幂的无符号除法来说，除法向下舍入的结果相当于逻辑右移。   

但是对于补码来说情况比较复杂，如果简单地进行算术右移，最后向下舍入的结果并非我们想要的
向零舍入。    

因此我们需要通过在移位之前“偏置”这个值，来修正这种不合适的舍入。    

**除以 2 的幂的补码除法：**   

C 变量 x 和 k 分别为有补码值 x 和无符号数值 k，且 0 &lt;= k &lt; w，则当执行算术移位时，
C 表达式 (x + (1 &lt;&lt; k) - 1) &gt;&gt; k 产生数值 ⌈x / 2<sup>k</sup>⌉。   

注意这里的向上取整其实是向零取整。      

不幸的是，除以 2 的幂的移位运算不能推广到任意常数。   

## 2.4 浮点数

### 2.4.1 二进制小数

理解浮点数的第一步是考虑含有小数值的二进制数字。首先，让我们来看看更熟悉的十进制表示法。
十进制表示法使用如下形式的表示：   

d<sub>m</sub>d<sub>m-1</sub>...d<sub>1</sub>d<sub>0</sub> . d<sub>-1</sub>d<sub>-2</sub>...d<sub>-n</sub>     

其中每个十进制数 d<sub>i</sub> 的取值范围是 0~9，这个表达描述的数值 d 定义如下：   

d = ∑<sup>m</sup><sub>i=-n</sub> 10<sup>i</sup> * d<sub>i</sub>     

数字权的定义与十进制小数点符号相关，这意味着小数点左边的数字的权是 10 的正幂，得到整数值，
而小数点右边的数字的权是 10 的负幂，得到小数值。    

类似，考虑一个形如：    

b<sub>m</sub>b<sub>m-1</sub>...b<sub>1</sub>b<sub>0</sub> . b<sub>-1</sub>b<sub>-2</sub>...b<sub>-n</sub>     

的表示法，其中每个二进制数字，或者称为位，b<sub>i</sub> 的取值范围是 0 和 1，这种表示
方法表示的数 b 定义如下：   

b = ∑<sup>m</sup><sub>i=-n</sub> 2<sup>i</sup> * d<sub>i</sub>     

从等式中很容易地看出，二进制小数点向左移动一位相当于这个数被 2 除。类似，二进制小数点
向右移动一位相当于将该数乘 2。    

注意，形如 0.11...1<sub>2</sub> 的数表示的是刚好小于 1 的数。例如，0.111111<sub>2</sub>
表示 63/64，我们将用简单的表达法，1.0 - ε 来表示这样的数值。    

假定我们仅考虑有限长度的编码，那么十进制表示法不能准确地表达像 1/3 和 5/7 这样的树。类似，
小数的二进制表示法只能表示那些能够被写成 x × 2<sup>y</sup> 的数。其他的值只能被近似地
表示。例如，数字 1/5 可以用十进制小数 0.20 精确表示，不过，我们并不能把它准确地表示为一个
二进制小数，我们只能近似地表示它。   

### 2.4.2 IEEE 浮点表示

表达式 5 × 2<sup>100</sup> 是用 101 后面跟随 100 个零的位模式来表示。    

**IEEE 浮点标准：**    

![ieee-floating-standard](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/ieee-floating-standard.png)    

下图给出了将这三个字段装进字中的两种最常见的格式。在单精度浮点格式（C语言中的 float）中，
s、exp 和 frac 字段分别为 1 位、k = 8 位 和 n = 23 位，得到一个 32 位的表示。在双
精度浮点格式（C语言中的 double）中，s、exp 和 frac 字段分别为 1 位、k = 11 位和 n = 52 位。
得到一个 64 位的表示。    

![standard-floating-expression](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/standard-floating-expression.png)    

给定位表示，根据 exp 的值，被编码的值可以分成三种不同的情况（最后一种情况有两个变种）。下图
说明了单精度格式的情况：    

![type-of-floating-expression](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/type-of-floating-expression.png)    

**情况1：规格化的值**    

这是最普遍的情况。当 exp 的位模式即不全为 0，也不全为 1 时，都属于这类情况。在这种情况中，
阶码字段被解释为以 _偏置_ 形式表示的有符号整数。也就是说，阶码的值是 E = e-Bias，其中 e
是无符号数，其位表示为 e<sub>k-1</sub>...e<sub>1</sub>e<sub>0</sub>，而 Bias 是一个
等于 2<sup>k-1</sup> - 1（单精度是 127，双精度是 1023）的偏置值。由此产生指数的取值范围，
对于单精度是 -126~+127，而对于双精度是 -1022~+1023。     

小数字段 frac 被解释为描述小数值 f，其中 0 &lt;= f &lt; 1，其二进制表示为 0.f<sub>n-1</sub>
...f<sub>1</sub>f<sub>0</sub>，也就是二进制小数点在最高有效位的左边。尾数定义为 M = 1 + f。
有时，这种方式也叫做隐含的以 1 开头的表示，因为我们可以把 M 看成一个二进制表达式
1.f<sub>n-1</sub>f<sub>n-2</sub>...f<sub>0</sub> 的数字。既然我们总是能够调整阶码 E，
使得尾数 M 在范围 1 &lt;= M &lt; 2 之中（假设没有溢出），那么这种表示方法是一种轻松获得
一个额外精度位的技巧。既然第一位总是等于 1，那么我们就不需要显示地表示它。   

**情况2：非规格化的值**   

当阶码域为全 0 时，所表示的数是非规格化形式。在这种情况下，阶码值是 E = 1 - Bias，而
尾数的值是 M = f，也就是小数字段的值，不包含隐含的开头的 1。     

非规格化数有两个用途。首先，它们提供了一种表示数值 0 的方法，因为使用规格化数，我们必须
总是使 M &gt;= 1，因此我们就不能表示0。实际上，+0.0 的浮点表示的位模式为全 0：符号位
是0，阶码字段全为 0，而小数域也全为 0，这就得到了 M = f = 0。令人奇怪的是，当符号位
为 1，而其他域全为 0 时，我们得到值 -0.0。根据 IEEE 的浮点格式，值 +0.0 和 -0.0 在某些
方面被认为是不同的，而在其他方面是相同的。    

非规格化数的另外一个功能是表示那些非常接近于 0.0 的数。它们提供了一种属性，称为逐渐溢出，
其中，可能的数值分布均匀地接近于0.0。    

**情况3：特殊值**    

最后一类数值是当阶码全为 1 的时候出现的。当小数域全为 0 时，得到的值表示无穷，当 s = 0
时是 +∞，或者当 s = 1 时是 -∞。当我们把两个非常大的数相乘，或者除以零时，无穷能够表示
溢出的结果。当小数域为非零时，结果值被称为 NaN。    

### 2.4.3 数字示例

k 位阶码和 n 位小数的浮点表示的一般属性如下：    

+ 值 +0.0 总有一个全为 0 的位表示
+ 最小的正非规格化值的位表示，是由最低有效位为 1，而其他所有位为 0 构成的。它具有小数（和
尾数）值 M = f = 2<sup>-n</sup> 和阶码值 E = -2<sup>k-1</sup> + 2。
+ 最大的非规格化值的位模式是由全为 0 的阶码字段和全为 1 的小数字段组成的。它有小数（和尾数）
值 M = f = 1 - 2<sup>-n</sup> 和阶码值 E = -2<sup>k-1</sup> + 2。    
+ 最小的正规格化值的位模式的阶码字段的最低有效位为 1，其他为全为0,。它的尾数值 M = 1，
而阶码值 E = -2<sup>k-1</sup> + 2。   
+ 值 1.0 的位表示的阶码字段除了最高有效位等于 1 以外，其他位都等于 0。它的尾数值是 M =1，
而它的阶码值是 E = 0.
+ 最大的规格化值的位表示的符号位为 0，阶码的最低有效位等于 0，其他位等于 1。它的小数值
f = 1 - 2<sup>-n</sup>，尾数 M = 2 - 2<sup>-n</sup>。它的阶码值 E = 2<sup>k-1</sup> -1.

### 2.4.4 舍入

因为表示方法限制了浮点数的范围和精度，所以浮点运算只能近似地表示实数运算。因此，对于值 x，
我们一般想用一种系统的方法，能够找到 “最接近的” 匹配值 x'，它可以用期望的浮点形式表示出来。
这就是 **舍入** 运算的任务。一个关键问题是在两个可能的中间确定舍入方向。IEEE 浮点格式定义
了四种不同的 **舍入方式**。默认的方法时找到最接近的匹配，而其他三种可用于计算上界和下界。    

下表举例说明了四种舍入方式。向偶数舍入，也被称为向最接近的值舍入，是默认的方式，试图找到
一个最接近的匹配值。因此，它将 1.40 美元舍入成 1，而将 1.60 美元舍入成 2，因为它们是
最接近的整数美元值。唯一的设计决策是确定两个可能结果中间数值的舍入效果。向偶数舍入方式
采用的方法时：它将数字向上或向下舍入，使得结果的最低有效数字是偶数。因此，这种方法将 1.5
美元和 2.5 美元都舍入成 2 美元。   


方式 | 1.40 | 1.60 | 1.50 | 2.50 | -1.50
---------|----------|---------|---------|---------|---------
 向偶数舍入 | 1 | 2 | 2 | 2 | -2
 向零舍入 | 1 | 1 | 1 | 2 | -1
 向下舍入 | 1 | 1 | 1 | 2 | -2
 向上舍入 | 2 | 2 | 2 | 3 | -1

### 2.4.6 C 语言中的浮点数

当在 int、float 和 double 格式之间进行强制类型转换时，程序改变数值和位模式的原则如下
（假设 int 是 32 位的）：    

+ 从 int 转换成 float，数字不会溢出，但是可能被舍入
+ 从 int 或 float 转换成 double，因为 double 有更大的范围，也有更高的精度，所以能够保留
精确的数值
+ 从 double 转换成 float，因为范围要小一些，所以只可能溢出无穷大。另外，由于精确度较小，
它还可能被舍入。   
+ 从 float 或者 double 转换成 int，值将会向零舍入。进一步来说，值可能会溢出。   
