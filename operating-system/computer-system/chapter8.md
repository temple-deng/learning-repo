# 第 8 章 异常控制流

<!-- TOC -->

- [第 8 章 异常控制流](#第-8-章-异常控制流)
  - [8.1 异常](#81-异常)
    - [8.1.1 异常处理](#811-异常处理)
  - [8.1.2 异常的类别](#812-异常的类别)
    - [8.1.3 Linux/x86-64 系统中的异常](#813-linuxx86-64-系统中的异常)
  - [8.2 进程](#82-进程)
    - [8.2.4 用户模式和内核模式](#824-用户模式和内核模式)
  - [8.4 进程控制](#84-进程控制)
    - [8.4.3 回收子进程](#843-回收子进程)
  - [8.5 信号](#85-信号)
    - [8.5.1 信号术语](#851-信号术语)
    - [8.5.3 接收信号](#853-接收信号)

<!-- /TOC -->

## 8.1 异常

异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。因为它们有一部分
是由硬件实现的，所以具体细节将随系统的不同而有所不同。    

异常就是控制流中的突变，用来响应处理器状态中的某些变化。当处理器状态中发生一个重要的变化
时，处理器正在执行某个当前指令 I<sub>curr</sub>。在处理器中，状态被编码为不同的位和信号。
状态变化称为 **事件**。事件可能和当前指令的执行直接相关，比如，发生缺页中断、算术溢出，或者
一条指令试图除以零。另一方面，事件也可能和当前指令的执行没有关系，比如，一个系统定时器
产生信号或者一个 I/O 请求完成。    

在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做 _异常表_ 的跳转表，进行一个
间接过程调用（异常），到一个专门设计用来处理这类事件的操作系统子程序（异常处理程序）。
当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下 3 种情况中的一种：    

1. 处理程序将控制返回给当前指令 I<sub>curr</sub>
2. 处理程序将控制返回给 I<sub>next</sub>
3. 处理程序终止被中断的程序    

### 8.1.1 异常处理

系统中可能的每种类型的异常都分配了一个唯一的非负整数的 **异常号**。其中一些号码是由处理器
的设计者分配的，其他号码是由操作系统内核的设计者分配的。    

在系统启动时，操作系统分配和初始化一张被称为 **异常表** 的跳转表，使得表目 k 包含异常 k
的处理器程序的地址。异常表的起始地址放在一个叫做 **异常表基址寄存器** 的特殊 CPU 寄存器里。    

异常类似于过程调用，但有一些重要的不同之处：    

+ 过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中。然而，根据异常的类型，返回
地址要么是当前指令，要么是下一条指令
+ 处理器也会把一些额外的处理器状态压到栈里，在处理程序返回时，重新开始执行被中断的程序会
需要这些状态
+ 如果控制从用户程序转移到内核，所有这些项目都被压到内核栈中，而不是压到用户栈中
+ 异常处理程序运行在内核模式下     

## 8.1.2 异常的类别

异常可以分为四类：**中断**(interrupt)、**陷阱**(trap)、**故障**(fault)和 **终止**(abort)。    

类别 | 原因 | 异步/同步 | 返回行为
---------|----------|---------|---------
 中断 | 来自 I/O 设备的信号 | 异步 | 总是返回到下一条指令
 陷阱 | 有意的异常 | 同步 | 总是返回到下一条指令
 故障 | 潜在可恢复的错误 | 同步 | 可能返回到当前指令
 终止 | 不可恢复的错误 | 同步 | 不会返回    

异步异常是由处理器外部的 I/O 设备中的事件产生的。同步异常是执行一条指令的直接产物。   

1. **中断**    

硬件中断的异常处理程序常常称为中断处理程序。在当前指令完成执行之后，处理器注意到中断引脚
的电压变高了，就从系统总线读取异常号，然后调用适当的中断处理程序。当处理程序返回时，它就
将控制返回给下一条指令。结果是程序继续执行，就好像没有发生过中断一样。    

剩下的异常类型是 **同步** 发生的，是执行当前指令的结果。我们把这类指令叫做故障指令。   

2. **陷阱和系统调用**    

陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做 **系统调用**。   

用户程序经常需要向内核请求服务，为了允许对这些内核服务的受控的房屋，处理器提供了一条特殊的
'syscall n' 指令，当用户程序想要请求服务 n 时，可以执行这条指令。执行 syscall 指令会
导致一个到异常处理程序的陷阱，这个处理程序解析参数，并调用适当的内核程序。    

3. **故障**   

故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理
程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。
否则，处理程序返回到内核中的 abort 例程，abort 例程会终止引起故障的应用程序。    

4. **终止**    

终止时不可恢复的致命错误造成的结果，通常是一些硬件错误。终止处理程序从不将控制返回给应用
程序。    

### 8.1.3 Linux/x86-64 系统中的异常


异常号 | 描述 | 异常类别
---------|----------|---------
 0 | 除法错误 | 故障
 13 | 一般保护故障 | 故障
 14 | 缺页 | 故障
 18 | 机器检查 | 终止
 32~255 | 操作系统定义的异常 | 中断或陷阱    

+ 除法错误：当应用试图除以零时，或者当一个除法指令的结果对于目标操作数来说太大了的时候，
就会发生除法错误，一般来说系统不会试图恢复
+ 一般保护故障：通常是因为一个程序引用了一个未定义的虚拟内存区域，或者因为程序试图写一个
只读的文本段，系统不会尝试恢复
+ 机器检查：在导致故障的指令执行中检测到致命的硬件错误时发生的。     

C 程序用 syscall 函数可以直接调用任何系统调用。然而，实际中几乎没必要这么做。对于大多数
系统调用，标准 C 库提供了一组方便的包装函数。这些包装函数将参数打包到一起，以适当的系统
调用指令陷入内核，然后将系统调用的返回状态传递回调用程序。   

所有到 Linux 系统调用的参数都是通过通用寄存器而不是栈传递的。按照惯例，寄存器 %rax 包含
系统调用号，寄存器 %rdi, %rsi, %rdx, %r10, %r8, %r9 包含最多 6 个参数。从系统调用返回
时，寄存器 %rcx 和 %r11 会被破坏，%rax 包含返回值。-4095 到 -1 之间的负数返回值表明
发生了错误。   

## 8.2 进程

### 8.2.4 用户模式和内核模式

为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行
的指令，以及它可以访问的地址空间范围。   

处理器通常是用某个控制寄存器中的一个 **模式位** 来提供这种功能的，该寄存描述了进程当前
享有的特权。当设置了模式位时，进程就运行在内核模式中。一个运行在内核模式的进程可以执行
指令集中的任何指令，并且可以访问系统中的任何内存位置。    

没有设置模式位时，进程就运行在用户模式。用户模式中的进程不允许执行特权指令。也不允许用户
模式中的进程直接引用地址空间中内核区内的代码和数据。      

## 8.4 进程控制

### 8.4.3 回收子进程

当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已
终止的状态中，直到被它的父进程 **回收**。当父进程回收已终止的子进程时，内核将子进程的
退出状态传递给父进程，然后抛弃已终止的进程，从此时开始，该进程就不存在了。一个终止了但
还未被回收的进程称为 **僵死进程**。    

如果一个父进程终止了，内核会安排 init 进程成为它的孤儿进程的养父。init 进程的 PID 为 1,
是在系统启动时内核创建的，它不会终止，是所有进程的祖先。如果父进程没有回收它的僵死子进程
就终止了，那么内核会安排 init 进程去回收它们。    

一个进程可以通过 waitpid 函数来等待他的子进程终止或者停止。    

`pid_t waitpid(pid_t pid, int *statusp, int options)`     

默认情况下（options=0），waitpid 挂起调用进程执行，知道它的等待集合中的一个子进程终止。
waitpid 返回已终止子进程的 PID。    

1. 判定等待集合的成员    

等待集合的成员是由参数 pid 来确定的：   

+ 如果 pid &gt; 0，那么等待集合就是一个单独的子进程，它的进程 ID 等于 pid
+ 如果 pid = -1，那么等待集合就是由父进程所有的子进程组成的    

2. 修改默认行为

可以通过将 options 设置为常量 WNOHANG, WUNTRACED 和 UCONTINUED 的各种组合来修改默认
行为：   

+ WNOHANG：如果等待集合中的任何子进程都还没有终止，那么就立即返回
+ WUNTRACED：挂起调用进程的执行，直到等待集合中的一个进程变成已终止或者被停止。返回的 PID
为导致返回的子进程的 PID。默认的行为是只返回已终止的子进程。
+ WCONTINUED：挂起调用进程的执行，直到等待集合中一个正在运行的进程终止或等待集合中一个
被停止的仅收到 SIGCONT 信号重新开始。     

## 8.5 信号

一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。低层的硬件异常是由内核
异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户
进程发生了这些异常。比如，如果一个进程试图除以 0，那么内核就发送给它一个 SIGFPE 信号。
如果一个进程执行一条非法指令，那么内核就发送给它一个 SIGILL 信号。其他信号对应于内核或者
其他用户进程中较高层的软件事件。    

### 8.5.1 信号术语

传送一个信号到目的进程是由两个不同步骤组成的：    

+ **发送信号**。内核通过更新目的进程上下文中的某个状态：**发送** 一个信号给目的进程。
发送信号可以有如下两种原因：
  1. 内核检测到一个系统事件，比如除零错误或者子进程终止
  2. 一个进程调用了 kill 函数，显示地要求内核发送一个信号给目的进程。
+ **接收信号**。当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就 **接收** 了
信号。进程可以忽略这个信号，终止或者通过执行一个 **信号处理程序** 的用户层函数 **捕获**
这个信号。     

一个发出而没有被接收的信号叫做 **待处理信号**。在任何时刻，一种类型至多只会有一个待处理
信号。如果一个进程有一个类型为 k 的待处理信号，那么任何接下来发送到这个进程的类型为 k 的
信号都不会排队等待；它们只是简单地丢弃。一个进程可以有选择性地 **阻塞** 接收某种信号。当
一种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接收，直到进程取消对这种信号
的阻塞。    

### 8.5.3 接收信号

当内核把进程 p 从内核模式切换到用户模式时，它会检查进程 p 的未被阻塞的待处理信号的集合，
如果这个集合为空，那么内核将控制传递给 p 的逻辑控制流中的下一条指令。然而，如果集合是
非空的，那么内核选择集合中的某个信号 k（通常是最小的 k），并且强制 p 接收信号 k。收到
这个信号会触发进程采取某种行为。一旦进程完成了这个行为，那么控制就传递回 p 的逻辑控制流
中的下一条指令。每个信号类型都有一个预定义的默认行为，是下面的一种：   

+ 进程终止
+ 进程终止并转储内存
+ 进程停止（挂起）直到被 SIGCONT 信号重启
+ 进程忽略该信号

![linux-signals](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/linux-signals.png)       

进程可以通过使用 `signal` 函数修改和信号相关联的默认行为。唯一的例外是：SIGSTOP 和 SIGKILL，
它们的默认行为是不能修改的。    

```c
typedef void (*sighandler_t)(int);

sighandler_t signal(int signum. sighandler_t handler);
```    

signal 函数可以通过下列三种方法之一来改变和信号 signum 相关联的行为：   

+ 如果 handler 是 SIG_IGN，那么忽略类型为 signum 的信号
+ 如果 handler 是 SIG_DFL，那么类型为 signum 的信号行为恢复为默认行为
+ 否则，handler 就是用户定义的函数地址，这个函数被称为信号处理程序。     

当处理程序执行它的 return 语句时，控制（通常）传递回控制流中进程被信号接收中断位置处的
指令。

