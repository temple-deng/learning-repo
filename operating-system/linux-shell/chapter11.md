# 第二部分 shell 脚本编程基础

# 第 11 章 构建基本脚本

## 11.2 创建 shell 脚本文件

在创建shell脚本文件时，必须在文件的第一行指定要使用的shell。其格式为：   

```bash
#!/bin/bash
```    

在通常的shell脚本中，井号（#）用作注释行。shell并不会处理shell脚本中的注释行。然而，
shell脚本文件的第一行是个例外，# 后面的惊叹号会告诉shell用哪个shell来运行脚本。   

如果在 echo 命令后面加上一个字符串，该命令就能显示出这个文本字符串。   

```
$ echo This is a test
This is a test
```   

注意，默认情况下，不需要使用引号将要显示的文本字符串划定出来。但有时在字符串中出现引号的
话就比较麻烦了。    

```
$ echo Let's see if this'll work
Lets see if thisll work
```   

echo 命令可用单引号或双引号来划定文本字符串。如果在字符串中用到了它们，你需要在文本中
使用其中一种引号，而用另外一种来将字符串划定起来。    

如果希望把 echo 输入的文本字符串和下一条命令的输出显示在同一行中，可以用 echo 的 -n 参数：   

```
echo -n "The time and date are: "
date
```   

## 11.4 使用变量

### 11.4.1 环境变量

shell维护着一组环境变量，用来记录特定的系统信息。比如系统的名称、登录到系统上的用户名、
用户的系统ID（也称为UID）、用户的默认主目录以及shell查找程序的搜索路径。可以用 set 命令
来显示一份完整的当前环境变量列表。   

在脚本中，你可以在环境变量名称之前加上美元符（$）来使用这些环境变量。echo 命令中的环境
变量会在脚本运行时替换成当前值。只要脚本在引号中出现美元符，它就会以为你在引用一个变量。
因此如果我们并不是想要引用一个变量，那么需要转义美元符。   

### 11.4.2 用户变量

除了环境变量，shell脚本还允许在脚本中定义和使用自己的变量。定义变量允许临时存储数据并在
整个脚本中使用，从而使shell脚本看起来更像一个真正的计算机程序。    

用户变量可以是任何由字母、数字或下划线组成的文本字符串，长度不超过20个。用户变量区分
大小写，所以变量 Var1 和变量 var1 是不同的。    

使用等号将值赋给用户变量。在变量、等号和值之间不能出现空格。    

shell脚本会自动决定变量值的数据类型。与系统变量类似，用户变量可通过美元符引用。    

```bash
#!/bin/bash

days=10
guest="Katie"
echo "$guest checked in $days days ago"
days=5
guest="Jessica"
echo "$guest checked in $days days ago"
```    

重要的是要记住，引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不要使用美元符。    

### 11.4.3 命令替换

shell脚本中最有用的特性之一就是可以从命令输出中提取信息，并将其赋给变量。有两种方法可以将
命令输出赋给变量：   

- 反引号字符（\`）
- `$()` 格式   

这里注意 `${variable}` 其实通常是为了截取出一个变量名，不然的话 $variable 这样形式的，
shell 不好判断变量名到底是什么，而 `$(cmd)` 里面是个命令，用来执行命令。   

命令替换会创建一个子shell来运行对应的命令。子shell（subshell）是由运行该脚本的shell
所创建出来的一个独立的子shell（child shell）。正因如此，由该子shell所执行命令是无法
使用脚本中所创建的变量的。   

## 11.5 重定向输入和输出

### 11.5.2 输入重定向

输入重定向将文件的内容重定向到命令。   

还有另外一种输入重定向的方法，称为 *内联输入重定向*（inline input redirection）。这种方法
无需使用文件进行重定向，只需要在命令行中指定用于输入重定向的数据就可以了。   

内联输入重定向符号是远小于号`<<`。除了这个符号，你必须指定一个文本标记来划分输入数据的
开始和结尾。任何字符串都可作为文本标记，但在数据的开始和结尾文本标记必须一致。    

```
command << marker
data
marker
```   

```bash
$wc << 123
> hhh
> ggg
> hhh
> jhjj
> 123
 4  4 17
```   

## 11.6 管道

有时需要将一个命令的输出作为另一个命令的输入。这可以用重定向来实现，只是有些笨拙。   

```bash
$rpm -qa > rpm.list
$sort < rpm.list
abrt-1.1.14-1.fc14.i686
abrt-addon-ccpp-1.1.14-1.fc14.i686
abrt-addon-kerneloops-1.1.14-1.fc14.i686
abrt-addon-python-1.1.14-1.fc14.i686
....
```   

这种方法的确管用，但仍然是一种比较繁琐的信息生成方式。我们用不着将命令输出重定向到文件中，
可以将其直接重定向到另一个命令。这个过程叫作 **管道连接**（piping）。   

```
command1 | command2
```   

不要以为由管道串起的两个命令会依次执行。Linux 系统实际上会同时运行这两个命令，在系统内部
将它们连接起来。在第一个命令产生输出的同时，输出会被立即送给第二个命令。数据传输不会用到
任何中间文件或缓冲区。    

## 11.7 执行数学运算

在 shell 脚本中有两种途径来进行数学运算。    

### 11.7.1 expr 命令

expr 命令允许在命令行上处理数学表达式，但是特别笨拙：   

```
$expr 1 + 5
6
```    

expr 命令能够识别少数的数学和字符串操作符：   

- `ARG1 | ARG2`: 如果 ARG1 既不是 null 也不是零值，返回 ARG1；否则返回 ARG2
- `ARG1 & ARG2`: 如果没有参数是 null 或零值，返回 ARG1；否则返回 0
- `ARG1 < ARG2`: 如果 ARG1 小于 ARG2 返回1，否则返回0
- `ARG1 <= ARG2`
- `ARG1 = ARG2`: 如果 ARG1 等于 ARG2，返回 1；否则返回0
- `ARG1 != ARG2`
- `ARG1 >= ARG2`
- `ARG1 > ARG2`
- `ARG1 + ARG2`
- `ARG1 - ARG2`
- `ARG1 * ARG2`
- `ARG1 % ARG2`: 算术余数
- `STRING : REGEXP`: 如果 REGEXP 匹配到了 STRING 中的某个模式，返回该模式匹配
- `match STRING REGEXP`: 同上
- `substr STRING POS LENGTH`: 返回起始位置为 POS（从1开始计数）、长度为 LENGTH 个字符
的子字符串
- `index STRING CHARS`: 返回在 STRING 中找到 CHARS 字符串的位置，否则返回 0
- `length STRING`: 返回字符串 STRING 的长度
- `+ TOKEN`: 将 TOKEN 解释成字符串，即使是个关键字
- (EXPRESSION): 返回 EXPRESSION 的值    

尽管标准操作符在 expr 命令中工作得很好，但在脚本或命令行上使用它们时仍有问题出
现。许多 expr 命令操作符在shell中另有含义（比如星号）。当它们出现在 expr 命令中时，会得到
一些诡异的结果。   

```
$expr 5 * 2
expr: syntax error
```   

只能将特殊字符转义：   

```
expr 5 \* 2
```   

而且好像只支持整数的运算。   

### 11.7.2 使用方括号

在bash中，在将一个数学运算结果赋给某个变量时，可以用美元符和方括号 `$[ operation ]`
将数学表达式围起来。    

```bash
$ var1=$[1 + 5]
$ echo $var1
6
$ var2=$[$var1 * 2]
$ echo $var2
12
```   

用方括号执行shell数学运算比用 expr 命令方便很多。这种技术也适用于shell脚本。   

bash shell数学运算符只支持整数运算。   

### 11.7.3 浮点解决方案

有几种解决方案能够克服bash中数学运算的整数限制。最常见的方案是用内建的bash计算器，叫作bc。    

bash 计算器能够识别：   

- 数字（整数和浮点数）
- 变量（简单变量和数组）
- 注释（以 # 或 C 语言中的 /**/ 开始的行）
- 表达式
- 编程语句（例如 if-then语句）
- 函数    

要退出 bash 计算器，需要输入 quit。   

浮点运算是由内建变量 scale 控制的。必须将这个值设置为你希望在计算结果中保留的小数位数，
否则无法得到期望的结果。    

```bash
$ bc -q
3.44 / 5
0
scale=4
3.44 / 5
.6880
quit
```   

scale 变量的默认值是 0。    

除了普通数字，bash计算器还能支持变量。   


