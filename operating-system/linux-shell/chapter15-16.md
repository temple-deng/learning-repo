# 第 15 章 呈现数据

<!-- TOC -->

- [第 15 章 呈现数据](#第-15-章-呈现数据)
  - [15.2 在脚本中重定向输出](#152-在脚本中重定向输出)
    - [15.2.1 临时重定向](#1521-临时重定向)
    - [15.2.2 永久重定向](#1522-永久重定向)
  - [15.3 在脚本中重定向输入](#153-在脚本中重定向输入)
  - [15.3 创建自己的重定向](#153-创建自己的重定向)
    - [15.4.1 创建输出文件描述符](#1541-创建输出文件描述符)
    - [15.4.2 重定向文件描述符](#1542-重定向文件描述符)
    - [15.4.4 创建读写文件描述符](#1544-创建读写文件描述符)
    - [15.4.5 关闭文件描述符](#1545-关闭文件描述符)
  - [15.8 记录消息](#158-记录消息)
- [第 16 章 控制脚本](#第-16-章-控制脚本)
  - [16.1 处理信号](#161-处理信号)
    - [16.1.1 重温 linux 信号](#1611-重温-linux-信号)
    - [16.1.2 生成信号](#1612-生成信号)
    - [16.1.3 捕获信号](#1613-捕获信号)
    - [16.1.4 捕获脚本退出](#1614-捕获脚本退出)
    - [16.1.5 修改或移除捕获](#1615-修改或移除捕获)
  - [16.3 在非控制台下运行脚本](#163-在非控制台下运行脚本)
  - [16.4 作业控制](#164-作业控制)
    - [16.4.1 查看作业](#1641-查看作业)
    - [16.4.2 重启停止的作业](#1642-重启停止的作业)
  - [16.5 调整谦让度](#165-调整谦让度)
    - [16.5.1 nice 命令](#1651-nice-命令)
    - [16.5.2 renice 命令](#1652-renice-命令)
  - [16.6 定时运行作业](#166-定时运行作业)
    - [16.6.1 用 at 命令来计划执行作业](#1661-用-at-命令来计划执行作业)
    - [16.6.2 安排需要定期执行的脚本](#1662-安排需要定期执行的脚本)
    - [16.6.3 使用新 shell 启动脚本](#1663-使用新-shell-启动脚本)

<!-- /TOC -->

## 15.2 在脚本中重定向输出

有两种方法在脚本中重定向输出：   

- 临时重定向行输出
- 永久重定向脚本中的所有命令    

### 15.2.1 临时重定向    

```bash
echo "This is an error message" >&2
```    

话说这里 2 为什么出现在 `>` 后边了又。这行会在脚本的 STDERR 文件描述符所指向的位置显示文本。     

### 15.2.2 永久重定向    

用 exec 命令告诉 shell 在脚本执行期间重定向某个特定的文件描述符。    

```bash
exec 1>testout
```    

## 15.3 在脚本中重定向输入    

```bash
exec 0< testfile
```    

## 15.3 创建自己的重定向    

在 shell 中最多可以有 9 个打开的文件描述符。其他 6 个从 3-8 的文件描述符均可用作输入或输出重定向。    

### 15.4.1 创建输出文件描述符    

```bash
#!/bin/zsh

exec 3>test13out

echo "This should display on the monitor"
echo "and this should be stored in the file" >&3
echo "Then this should be back on the monitor"
```   

### 15.4.2 重定向文件描述符    


你可以分配另外一个文件描述符给标准文件描述符，反之亦然。这意味着你可以将 STDOUT 的原来位置重定向另一个文件描述符，
然后再利用该文件描述符重定向回 STDOUT。    

```bash
exec 3>&1
exec 1>test14out

echo "This should store in the output file"
echo "along with this line."

exec 1>&3

echo "Now things should be back to normal"
```     

第二个exec命令将STDOUT重定向到文件， shell现在会将发送给STDOUT的输出直接重定向到
输出文件中。但是，文件描述符3仍然指向STDOUT原来的位置，也就是显示器。如果此时将输出
数据发送给文件描述符3，它仍然会出现在显示器上，尽管STDOUT已经被重定向了。     

在向STDOUT（现在指向一个文件）发送一些输出之后，脚本将STDOUT重定向到文件描述符
3的当前位置（现在仍然是显示器）。这意味着现在STDOUT又指向了它原来的位置：显示器。    

### 15.4.4 创建读写文件描述符     

由于是对同一个文件进行数据读写，shell 会维护一个内部指针，指明在文件中的当前位置。任何读或写都会从文件指针上次的位置开始。    

```bash
#!/bin/zsh

exec 3<> testfile

read line <&3
echo "Read: $line"
echo "This is a test line" >&3
```   

testfile:   

```txt
This is the first line.
This is the second line.
This is the third line.
```    

执行完以后：   

```
This is the first line.
This is a test line
ine.
This is the third line.
```     

### 15.4.5 关闭文件描述符    

```
exec 3>&-
```     

## 15.8 记录消息     

将输出同时发送到显示器和日志文件。    

```bash
date | tee testfile
```    

如果希望是追加模式，用 `-a` 选项。    

```bash
date | tee -e testfile
```     

# 第 16 章 控制脚本    

## 16.1 处理信号

### 16.1.1 重温 linux 信号

- 1 - SIGHUP - 挂起进程
- 2 - SIGINT - 终止进程
- 3 - SIGQUIT - 停止进程
- 9 - SIGKILL - 无条件终止进程
- 15 - SIGTERM - 尽可能终止进程
- 17 - SIGSTOP - 无条件停止进程，但不是终止进程
- 18 - SIGTSTP - 停止或暂停进程，但不终止进程
- 19 - SIGCONT - 继续运行停止的进程


默认情况下，bash shell会忽略收到的任何SIGQUIT (3)和SIGTERM (5)信号（正因为这样，
交互式shell才不会被意外终止）。但是bash shell会处理收到的SIGHUP (1)和SIGINT (2)信号。    

如果bash shell收到了SIGHUP信号，比如当你要离开一个交互式shell，它就会退出。但在退
出之前，它会将SIGHUP信号传给所有由该shell所启动的进程（包括正在运行的shell脚本）。    

通过SIGINT信号，可以中断shell。 Linux内核会停止为shell分配CPU处理时间。这种情况发
生时， shell会将SIGINT信号传给所有由它所启动的进程，以此告知出现的状况。    

### 16.1.2 生成信号     

ctrl + c 会生成 SIGINT 信号，并将其发送给当前在 shell 中运行的所有进程。   

ctrl + z 会生成一个 SIGTSTP 信号，停止 shell 中运行的任何进程。停止进程跟终止进程不同：停止进程会让程序继续保留在内存中，并能从上次停止的位置继续运行。    

### 16.1.3 捕获信号    

trap 命令允许指定 shell 脚本要监看并从 shell 中拦截的 linux 信号。如果脚本收到了 trap 命令中列出的信号，该信号不再由 shell 处理，而是交由本地处理。   

```bash
trap commands signals
```     

```bash
#!/bin/zsh

trap "echo ' Sorry! I have trapped Ctrl-c'" SIGINT

echo This is a test script

count=1
while [ $count -le 10 ]
do
    echo "Loop #$count"
    sleep 1
    count=$[ $count + 1 ]
done

echo "This is the end of the test script"
```     

### 16.1.4 捕获脚本退出

除了在 shell 脚本中捕获信号，你也可以在脚本退出时进行捕获。这是在 shell 完成任务时执行命令的一种简便方法。    

要捕获 shell 脚本的退出，只要在 trap 命令后加上 EXIT 信号就行。    

```bash
trap "echo Goodbye" EXIT
```    

### 16.1.5 修改或移除捕获

要想在脚本中的不同位置进行不同的捕获处理，只需重新使用带有新选项的trap命令。     

也可以删除已设置好的捕获，只需要在 trap 命令与希望恢复默认行为的信号列表之间加上两个破折号就行了。    

```bash
trap "echo ' Sorry... Ctrl-C is trapped.'" SIGINT

trap -- SIGINT
```   

也可以在trap命令后使用单破折号来恢复信号的默认行为。单破折号和双破折号都可以
正常发挥作用。    

## 16.3 在非控制台下运行脚本

有时你会想在终端会话中启动shell脚本，然后让脚本一直以后台模式运行到结束，即使你退
出了终端会话。这可以用nohup命令来实现。     

nohup命令运行了另外一个命令来阻断所有发送给该进程的SIGHUP信号。这会在退出终端会话时阻止进程退出。     

```bash
nohup ./test1.sh &
```     

由于nohup命令会解除终端与进程的关联，进程也就不再同STDOUT和STDERR联系在一起。
为了保存该命令产生的输出， nohup命令会自动将STDOUT和STDERR的消息重定向到一个名为
nohup.out的文件中。     


## 16.4 作业控制    

启动、停止、终止以及恢复作业的这些功能统称为作业控制。通过作业控制，就能完全控制 shell 环境中所有进程的运行方式了。   


### 16.4.1 查看作业   

jobs 命令。    

- `-l` 列出进程的 PID 以及作业号
- `-n` 只列出上次 shell 发出的通知后改变了状态的作业
- `-p` 只列出作业的 PID
- `-r` 只列出运行中的作业
- `-s` 只列出已停止的作业     

你可能注意到了jobs命令输出中的加号和减号。带加号的作业会被当做默认作业。在使用
作业控制命令时，如果未在命令行指定任何作业号，该作业会被当成作业控制命令的操作对象。     

当前的默认作业完成处理后，带减号的作业成为下一个默认作业。任何时候都只有一个带加
号的作业和一个带减号的作业，不管shell中有多少个正在运行的作业     

### 16.4.2 重启停止的作业     

要以后台模式重启一个作业，可用 bg 命令加上作业号。    

要以前台模式重启作业，可用带有作业号的 fg 命令。   

## 16.5 调整谦让度    

调度优先级是个整数值，从-20（最高优先级）到+19（最低优先级）。默认情况下， bash shell 以优先级0来启动所有进程。   

### 16.5.1 nice 命令     

nice命令允许你设置命令启动时的调度优先级。要让命令以更低的优先级运行，只要用nice的-n命令行来指定新的优先级级别。   

```bash
nice -n 10 ./test4.sh > test4.out &
```    

只能降低优先级，不能提高。   

### 16.5.2 renice 命令

有时你想改变系统上已运行命令的优先级。这正是renice命令可以做到的。它允许你指定运行进程的PID来改变它的优先级。   

```bash
renice -n 10 -p 5055
```    

## 16.6 定时运行作业

### 16.6.1 用 at 命令来计划执行作业    

at命令允许指定Linux系统何时运行脚本。 at命令会将作业提交到队列中，指定shell何时运
行该作业。 at的守护进程atd会以后台模式运行，检查作业队列来运行作业。大多数Linux发行
版会在启动时运行此守护进程。    

atd守护进程会检查系统上的一个特殊目录（通常位于/var/spool/at）来获取用at命令提交的
作业。默认情况下， atd守护进程会每60秒检查一下这个目录。有作业时， atd守护进程会检查
作业设置运行的时间。如果时间跟当前时间匹配， atd守护进程就会运行此作业。

```bash
at [-f filename] time
```      

默认情况下， at命令会将STDIN的输入放到队列中。你可以用-f参数来指定用于读取命令（脚本文件）的文件名。    

time参数指定了Linux系统何时运行该作业。如果你指定的时间已经错过，at命令会在第二天的那个时间运行指定的作业。     

at命令能识别多种不同的时间格式:    

- 标准的小时和分钟格式，比如 10:15
- AM/PM 指示符，比如 10:15PM
- 特定可命名时间，比如 now, noon, midnight     

除了指定运行作业的时间，也可以通过不同的日期格式指定特定的日期。    

- 标准日期格式，比如 MMDDYY, MM/DD/YY 或 DD.MM.YY
- 文本日期，比如 Jul 4
- 你也可以指定时间增量
  + 当前时间 +25min
  + 明天 10:15 PM
  + 10:15+7天

```bash
at -f test13.sh now
```    

atq命令可以查看系统中有哪些作业在等待。    

artm 命令来删除等待中的作业。只要指定想要删除的作业号就行了。    

### 16.6.2 安排需要定期执行的脚本

Linux系统使用cron程序来安排要定期执行的作业。 cron程序会在后台运行并检查一个特殊的表（被称作cron时间表），以获知已安排执行的作业。     

cron 时间表采用一种特殊的格式来指定作业何时运行：   

```bash
min hour dayofmonth month dayofweek command
```      

cron时间表允许你用特定值、取值范围（比如1~5）或者是通配符（星号）来指定条目。例如，如果想在每天的10:15运行一个命令，可以用cron时间表条目：    

```bash
15 10 * * * command
```      

话说老实说，上面这个命令根本没有主命令啊，这感觉直接调用大概率会失败。    

每个系统用户都可以用自己的的 cron 时间表来运行安排好的任务。Linux 提供的 crontab 命令来处理 cron 处理表。
要列出已有的 cron 时间表，可以用 -l 选项。    

```bash
crontab -l
```     

要为 cron 时间表添加条目，可以用 -e 选项。在添加条目时，crontab 命令会启用一个文本编辑器。    

如果你创建的脚本对精确的执行时间要求不高，用预配置的 cron 脚本目录会更方便。有 4 个基本目录：hourly, daily, monthly 和 weekly。     

```bash
ls /etc/cron.*ly
```     

cron程序的唯一问题是它假定Linux系统是7× 24小时运行的。如果某个作业在cron时间表中安排运行的时间已到，但这时候Linux系统处于关机状态，那么这个作业就不会被运行。当系统开机时， cron程序不会再去运行那些错过的作业。要解决这个问
题，许多Linux发行版还包含了anacron程序。      

如果anacron知道某个作业错过了执行时间，它会尽快运行该作业。这意味着如果Linux系统
关机了几天，当它再次开机时，原定在关机期间运行的作业会自动运行。    

anacron程序只会处理位于cron目录的程序，比如/etc/cron.monthly。它用时间戳来决定作业
是否在正确的计划间隔内运行了。每个cron目录都有个时间戳文件，该文件位于/var/spool/anacron。    

### 16.6.3 使用新 shell 启动脚本    

每次启动一个新 shell 时，bash shell 都会运行 .bashrc 文件。   