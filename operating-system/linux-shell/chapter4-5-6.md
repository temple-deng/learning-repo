# 第 4 章 更多的 bash shell 命令

<!-- TOC -->

- [第 4 章 更多的 bash shell 命令](#第-4-章-更多的-bash-shell-命令)
  - [4.1 监测程序](#41-监测程序)
    - [4.1.1 探查进程](#411-探查进程)
    - [4.1.2 实时监测进程](#412-实时监测进程)
    - [4.1.3 结束进程](#413-结束进程)
  - [4.2 监测磁盘空间](#42-监测磁盘空间)
    - [4.2.1 挂载存储媒体](#421-挂载存储媒体)
    - [4.2.2 使用 df 命令](#422-使用-df-命令)
    - [4.2.3 使用 du 命令](#423-使用-du-命令)
  - [4.3 处理数据文件](#43-处理数据文件)
    - [4.3.1 排序数据](#431-排序数据)
    - [4.3.2 搜索数据](#432-搜索数据)
    - [4.3.3 压缩数据](#433-压缩数据)
    - [4.3.4 归档数据](#434-归档数据)
- [第 5 章 理解 shell](#第-5-章-理解-shell)
  - [5.2 shell 的父子关系](#52-shell-的父子关系)
    - [5.2.1 进程列表](#521-进程列表)
    - [5.2.2 别处心裁的子 shell 用法](#522-别处心裁的子-shell-用法)
  - [5.3 理解 shell 的内建命令](#53-理解-shell-的内建命令)
    - [5.3.1 外部命令](#531-外部命令)
    - [5.3.2 内建命令](#532-内建命令)
- [第 6 章 使用 Linux 环境变量](#第-6-章-使用-linux-环境变量)
  - [6.1 什么是环境变量](#61-什么是环境变量)
    - [6.1.1 全局环境变量](#611-全局环境变量)
    - [6.1.2 局部环境变量](#612-局部环境变量)
  - [6.2 设置用户定义变量](#62-设置用户定义变量)
    - [6.2.1 设置局部用户定义变量](#621-设置局部用户定义变量)
    - [6.2.2 设置全局环境变量](#622-设置全局环境变量)
  - [6.3 删除环境变量](#63-删除环境变量)
  - [6.4 默认的 shell 环境变量](#64-默认的-shell-环境变量)
  - [6.5 定位系统环境变量](#65-定位系统环境变量)
    - [6.5.1 登录 shell](#651-登录-shell)
    - [6.5.2 交互式 shell 进程](#652-交互式-shell-进程)
    - [6.5.3 非交互式 shell](#653-非交互式-shell)
    - [6.5.4 环境变量持久化](#654-环境变量持久化)
  - [6.7 数组变量](#67-数组变量)

<!-- /TOC -->

本章将介绍 Linux 系统管理命令，通过这些命令探查 Linux 系统的内部信息。   

## 4.1 监测程序

### 4.1.1 探查进程

默认情况下，`ps` 命令只会显示运行在当前控制台下的属于当前用户的进程。   

Linux 系统中使用的 GNU ps 命令支持 3 种不同类型的命令行参数：   

+ Unix 风格的参数，前面加单破折线
+ BST 风格的参数，前面不加破折线
+ GNU 风格的参数，前面加双破折线    

**Unix 风格的参数**    


参数 | 描述
----------|---------
 -A | 显示所有进程
 -N | 显示与指定参数不符的所有进程
 -a | 显示除控制进程(session leader)和无终端进程外的所有进程
 -d | 显示除控制进程之外的所有进程（bash 属于控制进程）
 -e | 显示所有进程
 -C cmdlist | 显示包含在 cmdlist 列表中的进程
 -G grplist | 显示组 ID 在 grplist 列表中的进程
 -U userlist | 显示属主的用户 ID 在 userlist 列表中的进程
 -g grplist | 显示会话或组 ID 在 grplist 列表中的进程
 -p pidlist | 显示 PID 在 pidlist 列表中的进程
 -s sesslist | 显示会话 ID 在 sesslist 列表中的进程
 -t ttylist | 显示终端 ID 在 ttylist 列表中的进程
 -u userlist | 显示有效用户 ID 在 userlist 列表中的进程
 -F | 显示更多额外输出（相对 -f 参数而言）
 -f | 显示完整格式的输出
 -j | 显示任务信息
 -l | 显示长列表
 -H | 用层级格式来显示进程（树状，用来显示父进程）
 -L | 显示进程中的线程

`ps -ef`

+ UID：启动这些进程的用户
+ PID：进程ID
+ PPID：父进程的进程 ID（如果该进程是由另一个进程启动的）
+ C：进程生命周期中的 CPU 利用率
+ STIME：进程启动时的系统时间
+ TTY：进程启动时的终端设备
+ TIME：启动进程需要的累计 CPU 时间
+ CMD：启动的程序名称

使用 -l 多出的列：   

+ F：内核分配给进程的系统标记
+ S：进程的状态（O 代表正在运行；S代表在休眠；R代表可运行，正等待运行；Z 代表僵化；T 代表停止）
+ PRI：进程的优先级（越大的数字代表越低的优先级）
+ NI：谦让度值用来参与决定优先级
+ ADDR：进程的内存地址
+ SZ：加入进程被换出，所需交换空间的大致大小
+ WCHAN：进程休眠的内核函数的地址    

**BST 风格的参数**    


参数 | 描述
----------|---------
 T | 显示跟当前终端关联的所有进程
 a | 显示跟任意终端关联的所有进程
 g | 显示所有进程，包括控制进程（但其实好像还是只显示出和任意终端关联的进程）
 r | 仅显示运行中的进程
 x | 显示所有的进程，甚至包括未分配任何终端的进程
 U userlist | 显示归 userlist 列表中某用户 ID 所有的进程
 p pidlist | 显示 PID 在 pidlist 列表中的进程
 t ttylist | 显示所关联的终端在 ttylist 列表中的进程
 l |　采用长模式
 u | 采用基于用户的格式显示
 k sort | 指定用以将输出排序的列
 m | 在进程后显示线程

BSD 风格的 l 参数，能输出更详细的进程状态码（STAT 列）。双字符状态码能比 Unix 风格输出的
单字符状态码更清楚地表示进程的当前状态。    

第一个字符采用了和 Unix 风格 S 列相同的值，表示进程是在休眠、运行还是等待。第二个参数进一步说明
进程的状态：    

+ &lt;：该进程运行在高优先级上
+ N：该进程运行在低优先级上
+ L：该进程有页面锁定在内存中
+ s：该进程是控制进程
+ l：该进程是多线程的
+ +：该进程运行在前台    

GNU 的先略过。   

### 4.1.2 实时监测进程

![top](https://raw.githubusercontent.com/temple-deng/markdown-images/master/linux/top.png)    

`top` 输出的第一部分显示的是系统的概况：第一行显示了当前时间、系统的运行时间、登录的用户数以及
系统的平均负载。    

平均负载有 3 个值：最近 1 分钟的、最近 5 分钟的和最近 15 分钟的平均负载。值越大说明系统的负载
越高。    

第二行显示了进程概要信息——top命令的输出中将进程叫做任务。下一行显示了 CPU 的概要信息。top 根据
进程的属主（用户还是系统）和进程的状态（运行、空闲还是等待）将 CPU 利用率分成几类输出。   

后面两行说明了系统内存的状态。    

+ VIRT：进程占用的虚拟内存总量
+ RES：进程占用的物理内存总量
+ SHR：进程和其他进程共享的内存总量
+ %CPU：进程使用的 CPU 时间比例
+ %MEM：进程使用的内存占可用内存的比例
+ TIME+：自进程启动到目前为止的 CPU 时间总量   

默认情况下，top 命令在启动时会按照 %CPU 值对进程排序。可以在 top 运行时使用多种交互命令重新
排序。每个交互式命令都是单字符，在 top 命令运行时键入可改变 top 的行为。键入 f 进入一个字段管理
的界面，在这个界面里面我们可以选择进行排序的字段，调整列的顺序。    

### 4.1.3 结束进程

在 Linux 中，进程之间通过 **信号** 来通信。进程的信号就是预定义好的式消息，进程能识别它并决定
忽略还是作出反应。进程如何处理信号是由开发人员通过编程来决定的。    


信号 | 名称 | 描述
---------|----------|---------
 1 | HUP | 挂起
 2 | INT | 中断
 3 | QUIT | 结束运行
 9 | KILL | 无条件终止
 11 | SEGV | 段错误
 15 | TERM | 尽可能终止
 17 | STOP | 无条件停止运行、但不终止
 18 | TSTP | 停止或暂停，但继续在后台运行
 19 | CONT | 在 STOP 或 TSTP 之后恢复执行

在 Linux 上有两个命令可以向运行中的进程发出进程信号。   

**kill 命令**   

`kill` 命令可通过进程 ID 给进程发信号。默认情况下，`kill` 命令会向命令行中列出的全部 PID 发送
一个 TERM 信号。    

要发送进程信号，你必须是进程的属主或登录为 root 用户。    

**killall 命令**    

`killall` 命令非常强大，它支持通过进程名而不是 PID 来结束进程。`killall` 命令也支持通配符。   

```bash
$ killall http*
```   

上例中的命令结束了所有以 http 开头的进程。   

## 4.2 监测磁盘空间

### 4.2.1 挂载存储媒体

在使用新的存储媒体之前，需要把它放到虚拟目录下。这项工作称为 **挂载**。    

在现今的图形化桌面环境里，大多数 Linux 发行版都能自动挂载特定类型的可移动存储媒体。例如 U 盘。   

**mount 命令**    

默认情况下，`mount` 命令会输出当前系统上挂载的设备列表：   

![mount](https://raw.githubusercontent.com/temple-deng/markdown-images/master/linux/mount.png)    

`mount` 命令提供如下四部分信息：   

+ 媒体的设备文件名
+ 媒体挂载到虚拟目录的挂载点
+ 文件系统类型
+ 已挂载媒体的访问状态

要手动在虚拟目录中挂载设备，需要以 root 用户身份登录，或是以 root 用户身份运行 sudo 命令：   

```bash
$ mount -t type device directory
```    

type 参数指定了磁盘被格式化的文件系统类型。如果是和 Windows 共用这些存储设备，通常得使用下列
文件系统类型：   

+ vfat：Windows 长文件系统
+ ntfs：Windows NT、XP、Vista 以及 Win7 中使用的文件系统    

后面两个参数定义了该存储设备的设备文件的位置以及挂载点在虚拟目录中位置。    

```bash
$ mount -t vfat /dev/sdb1 /media/disk
```    

下表列出了 `mount` 命令的其他参数。   


参数 | 描述
----------|---------
 -a | 挂载 /etc/fstab 文件中指定的所有文件系统
 -f | 使 mount 命令模拟挂载设备，但不真的挂载
 -F | 和 -a 参数一起使用时，会同时挂载所有文件系统
 -v | 详细模式，将会说明挂载设备的每一步
 -I | 不启用任何 /sbin/mount.filesystem 下的文件系统帮助文件
 -l | 给 ext2, ext3 或 XFS 文件系统自动添加文件系统标签
 -n | 挂载设备，但不注册到 /etc/mtab 已挂载设备文件中
 -r | 将设备挂载为只读的
 -L label | 将设备按指定 label 挂载
 -U uuid | 将设备按指定 uuid 挂载    

卸载设备的命令是 `umount`：   

```bash
$ umount [directory | device]
```    

`umount` 命令支持通过设备文件或者是挂载点来指定要卸载的设备。如果有任何程序正在使用设备上的文件，
系统就不会允许你卸载它。     

### 4.2.2 使用 df 命令

`df` 命令查看所有已挂载磁盘的使用情况。    

![df](https://raw.githubusercontent.com/temple-deng/markdown-images/master/linux/df.png)   

### 4.2.3 使用 du 命令

`du` 命令可以显示某个特定目录（默认情况下是当前目录）的磁盘使用情况。这一个方法可用来快速判断
系统上某个目录下是不是有超大文件。     

默认情况下，`du`命令会显示当前目录下所有的文件、目录和子目录的磁盘使用情况，他会以磁盘块为单位
来表明每个文件或目录占用了多大存储空间。     

+ `-c`：显示所有已列出文件总的大小
+ `-h`：按用户易读的格式输出大小
+ `-s`：显示每个输出参数的总计     

## 4.3 处理数据文件

### 4.3.1 排序数据

默认情况下，`sort` 命令按照会话指定的默认语言的排序规则对文本文件中的数据行进行排序。`-n` 参数
告诉 `sort` 命令把数字识别为数字而不是字符。   

`-M` 参数按月排序，Linux 的日志文件经常会在每行的起始位置有一个时间戳。    

### 4.3.2 搜索数据

```bash
grep [options] pattern [file]
```    

`grep` 命令会在输入或指定的文件中查找包含匹配指定模式的字符的行。    

如果要进行反向搜索，可加 `-v` 参数，如果要显示匹配模式的行所在的行号，可加 `-n` 参数，如果只要
知道有多少行含有匹配的模式，可用 `-c` 参数。如果要指定多个匹配模式（或的关系），可用 `-e` 参数。   

### 4.3.3 压缩数据

+ bzip2, .bz2
+ compress, .Z
+ gzip, .gz
+ zip, .zip

gzip 包含有以下的工具：   

+ gzip：用来压缩文件
+ gzcat：用来查看压缩过的文本文件的内容（然而使用时提示是 `zcat` 命令）
+ gunzip：用来解压文件（这个命令可以正常使用）

`gzip` 命令会压缩你在命令行指定的文件，也可以在命令行指定多个文件名甚至用通配符来批量压缩文件。   

### 4.3.4 归档数据

```bash
$ tar function [options] object1 object2 ...
```    

function 参数定义了 tar 命令该做什么。    


功能 | 长名称 | 描述
---------|----------|---------
 -A | --concatenate | 将一个已有 tar 归档文件追加到另一个已有 tar 归档文件
 -c | --create | 创建一个新的 tar 归档文件
 -d | --diff or --delete | 检查归档文件和文件系统的不同之处或者从已有 tar 归档文件中删除
 -r | --append | 追加文件到已有 tar 归档文件末尾
 -t | --list | 列出已有归档文件的内容
 -u | --update | 将比 tar 归档文件中已有的同名文件新的文件追加到该 tar 归档文件中的末尾
 -x | --extract | 从已有归档文件中提取文件

下面是和这些功能常用的一些选项：   


选项 | 描述
----------|---------
 -C dir | 切换到指定目录
 -f file | 输出结果到文件或设备 file
 -j | 将输出重定向给 bzip2 命令来压缩内容
 -p | 保留所有文件权限
 -v | 在处理文件时显示文件
 -z | 将输出重定向给 gzip 命令来压缩内容

```bash
tar -cvf test.tar test/ test2/
```    

上面的命令创建了归档文件 test.tar

```bash
$ tar -tf test.tar
```    

```bash
$ tar -xvf
```   

# 第 5 章 理解 shell

## 5.2 shell 的父子关系

在 CLI 提示符后输入 /bin/bash 命令或其他等效的 bash 命令时，会创建一个新的 shell 程序。这个
shell 程序被称为 **子 shell**。    

### 5.2.1 进程列表

你可以在一行中指定要依次运行的一系列命令，只要在命令之间加入分号即可。    

```bash
$ pwd; ls; cd /etc ; pwd; cd ; pwd; ls
```   

在上面的例子中，所有的命令依次执行，不存在任何问题。不过这并不是进程列表。命令列表想要成为进程
列表，这些命令必须包含在括号里。   

```bash
$ (pwd ; ls ; cd /etc ; pwd; cd ; pwd; ls)
```    

括号的加入使命令列表变成了进程列表，生成了一个子 shell 来执行对应的命令。   

要想知道是否生成了子shell,得借助一个使用了环境变量的命令。这个命令就是 echo $BASH_SUBSHELL 。
如果该命令返回 0 ,就表明没有子shell。如果返回1 或者其他更大的数字,就表明存在子shell。    

### 5.2.2 别处心裁的子 shell 用法

进程列表、协程和管道都利用了子 shell。   

**探索后台模式**    

在后台模式中运行的命令可以在处理命令的同时让出 CLI。    

`sleep` 命令接受一个参数，该参数是你希望进程等待（睡眠）的秒数。     

```bash
$ sleep 3000&
[1] 2396
```   

方括号中是后台作业号，之后的内容是后台作业的进程 ID。    

可以使用 `jobs` 命令来显示后台作业信息，`jobs` 命令可以显示出当前运行在后台模式中所有用户的进程。   

**协程**    

协程可以同时做两件事，它在后台生成一个子 shell，并在这个子 shell 中执行命令。   

要进行协程处理，得使用 `coproc` 命令，还有要在子 shell 中执行的命令。    

```bash
$ coproc sleep 10
[1] 2544
```    

## 5.3 理解 shell 的内建命令

### 5.3.1 外部命令

外部命令，有时候也被称为文件系统命令，是存在于 bash shell 之外的程序。他们并不是 shell 程序
的一部分。外部命令程序通常位于 /bin, /sbin/, /usr/bin, /usr/sbin 中。   

当外部命令执行时，会创建出一个子进程。这种操作被称为 **衍生**(forking)。作为外部命令，`ps`命令
执行时会创建出一个子进程。      

当进程必须执行衍生操作时,它需要花费时间和精力来设置新子进程的环境。所以说,外部
命令多少还是有代价的。    

### 5.3.2 内建命令

内建命令和外部命令的区别在于前者不需要使用子进程来执行，它们已经和 shell 编译成了一体，作为
shell 工具的组成部分存在。不需要借助外部程序文件来运行。    

可以用 `type` 命令来了解某个命令是否是内建的。   

因为既不需要通过衍生出子进程来执行,也不需要打开程序文件,内建命令的执行速度要更
快,效率也更高。    

要注意,有些命令有多种实现。例如 echo 和 pwd 既有内建命令也有外部命令。两种实现略有
不同。要查看命令的不同实现,使用 type 命令的 -a 选项。    

命令历史记录被保存在隐藏文件 .bash_history 中，它位于用户的主目录中。这里要注意的是，bash 命令
的历史记录是先存放在内存中，当 shell 退出时采被写入到历史文件中。  

可以在退出shell会话之前强制将命令历史记录写入.bash_history文件。要实现强制写入,需
要使用 history 命令的 -a 选项。    

可以唤回历史列表中任意一条命令。只需输入惊叹号和命令在历史列表中的编号即可。    

**命令别名**    

`alias` 命令是另一个 shell 的内建命令。`alias -p` 查看当前可用的别名。    

可以用 alias 命令创建属于自己的别名：   

```bash
$ alias li='ls -li'
```   

要注意,因为命令别名属于内部命令,一个别名仅在它所被定义的shell进程中才有效。不过好在有办法能够让
别名在不同的子shell中都奏效。    

# 第 6 章 使用 Linux 环境变量

## 6.1 什么是环境变量

bash shell 用一个叫作 **环境变量** 的特性来存储有关 shell 会话和工作环境的信息。这项特性
允许你在内存中存储数据，以便程序或 shell 中运行的脚本能够轻松访问到它们。   

在 bash shell 中，环境变量分为两类：   

+ 全局变量
+ 局部变量    

### 6.1.1 全局环境变量

全局环境变量对于 shell 会话和所有生产的子 shell 都是可见的。局部变量则只对创建它们的 shell 可见。   

Linux 系统在你开始 bash 会话时就设置了一些全局环境变量。系统环境变量基本上都是使用全大写字母，
以区别于普通用户的环境变量。    

要查看全局变量，使用 `env` 或者 `printenv` 命令。   

要显示个别环境变量的值，可以使用 `printenv` 命令，但是不要用 env 命令。   

```bash
$ printenv HOME
```   

也可以使用 `echo` 显示变量的值，在这种情况下引用某个环境变量的时候，必须在变量前面加上一个美元符。   

### 6.1.2 局部环境变量

Linux系统也默认定义了标准的局部环境变量。不过你也可以定义自己的局部变量,如你所想,这些变量被称为
用户定义局部变量。    

查看局部环境变量的列表有点复杂。遗憾的是,在Linux系统并没有一个只显示局部环境
变量的命令。 `set` 命令会显示为某个特定进程设置的所有环境变量,包括局部变量、全局变量
以及用户定义变量。     

## 6.2 设置用户定义变量

### 6.2.1 设置局部用户定义变量

可以通过等号给环境变量赋值，值可以是数值或字符串。   

```bash
$ my_variable=Hello
$ echo $my_variable
Hello
```    

如果要给变量赋一个含有空格的字符串值，必须用引号来界定字符串的首和尾。    

记住，变量名、等号和值之间没有空格，这一点非常重要。如果在赋值表达式中加上了空格，shell 会把
值当成一个单独的指令。   

### 6.2.2 设置全局环境变量

在设定全局环境变量的进程所创建的子进程中，该变量都是可见的。（然而在其他非子 shell 中是不可用的）
创建全局环境变量的方式是先创建一个局部环境变量，然后再把他导出到全局环境中。    

这个过程通过 `export` 命令来完成，变量名前面不需要美元符。   

```bash
$ my_variable="I am Global now"
$ export my_variable
```    

修改子 shell 中全局环境变量不会影响到父 shell 中该变量的值。这种改变仅在子 shell 中有效，
并不会被反映到父 shell 中。   

## 6.3 删除环境变量

使用 `unset` 删除环境变量，不需要加美元符。   

如果在子进程中删除了一个全局环境变量，这只对子进程有效。该全局环境变量在父进程中依然可用。    

## 6.4 默认的 shell 环境变量


变量 | 描述
----------|---------
 CDPATH | 冒号分隔的目录列表，作为 cd 命令的搜索路径（但是 Ubuntu 里面没有这个变量）
 HOME | 当前用户的主目录
 IFS | shell 用来将文本字符串分割成字段的一系列字符
 MAIL | 当前用户收件箱的文件名
 MAILPATH | 冒号分隔的当前用户收件箱的文件名列表
 OPTARG | getopts 命令处理的最后一个选项参数值
 OPTIND | getopts 命令处理的最后一个选项参数的索引号
 PATH | shell 查找命令的目录列表，由冒号分隔
 PS1 | shell 命令行界面的主提示符
 PS2 | shell 命令行界面的次提示符
 BASH | 当前 shell 实例的全路径名
 LANG | shell 的语言环境类别
 LC_ALL | 定义一个语言环境类别，能够覆盖 LANG 变量

省了很多。    

## 6.5 定位系统环境变量

在登入 Linux 系统启动一个 bash shell 时，默认情况下 bash 会在几个文件中查找命令。这些文件
叫做 **启动文件** 或 **环境文件**。bash 检查的启动文件取决于你启动 bash shell 的方式。启动
bash shell 有 3 种方式：   

+ 登录时作为默认登录 shell
+ 作为非登录 shell 的交互式 shell
+ 作为运行脚本的非交互式 shell     

### 6.5.1 登录 shell

当你登录 Linux 系统时，bash shell 会作为登录 shell 启动。登录 shell 会从 5 个不同的启动文件
里读取命令：    

+ /etc/profile
+ $HOME/.bash_profile
+ $HOME/.bashrc
+ $HOME/.bash_login
+ $HOME/.profile    

要留意的是有些 Linux 发行版使用了可拆卸式认证模块（Pluggable Authentication Modules, PAM）。
在这种情况下，PAM 文件会在 bash shell 启动之前处理，这些文件中可能会包含环境变量。PAM 文件包括
/etc/environment 文件和 $HOME/.pam_environment 文件。   

**/etc/profile**   

/etc/profile 文件是 bash shell 默认的主启动文件。不同的 Linux 发行版在这个文件里放了不同的
命令。本机 Ubuntu 上是这样:    

```shell
# /etc/profile: system-wide .profile file for the Bourne shell (sh(1))
# and Bourne compatible shells (bash(1), ksh(1), ash(1), ...)

if [ "$PS1" ]; then
  if [ "$BASH" ] && [ "$BASH" != "/bin/sh" ]; then
    # The file bash.bashrc already sets the default PS1/
    # PS1='\h:\w$ '
    if [ -f /etc/bash.bashrc ]; then
      . /etc/bash.bashrc
    fi
  else
    if [ "`id -u`" -eq 0 ]; then
      PS1='# '
    else
      PS1='$ '
    fi
  fi
fi

if [ -d /etc/profile.d ]; then
  for i in /etc/profile.d/*.sh; do
    if [ -r $i ]; then
      . $i
    fi
  done
  unset i
fi
``` 

**$HOME 目录下的启动文件**    

大多数 Linux 发行版只用到这四个启动文件中的一到两个：   

+ $HOME/.bash_profile
+ $HOME/.bashrc
+ $HOME/.bash_login
+ $HOME/.profile  

shell 会按照下列顺序，运行第一个被找到的文件，余下的则被忽略：   

1. $HOME/.bash_profile
2. $HOME/.bash_login
3. $HOME/.profile     

注意这个列表中并没有 $HOME/.bashrc 文件。这是因为该文件通常通过其他文件运行的。   

### 6.5.2 交互式 shell 进程

如果你的 bash shell 不是登录系统时启动的（比如是在命令行提示符下敲入 bash 时启动的），那么你
启动的 shell 叫做交互式 shell。    

如果 bash 是作为交互式 shell 启动的，它就不会访问 /etc/profile 文件，只会检查用户 HOME 目录
中的 .bashrc 文件。     

### 6.5.3 非交互式 shell

系统执行 shell 脚本时用的就是这种 shell。    

为了处理这种情况，bash shell 提供了 BASH_ENV 环境变量。当 shell 启动一个非交互式 shell 进程
时，它会检查这个环境变量来查看要执行的启动文件。如果有指定的文件，shell 会执行该问文件里的命令，
这通常包括 shell 脚本变量设置。   

### 6.5.4 环境变量持久化

最好是在 /etc/profile.d 目录中创建一个已 .sh 结尾的文件。把所有新的或修改过的全局环境变量设置
放在这个文件中。    

在大多数发行版中，存储个人用户永久性 bash shell 变量的地方是 $HOME/.bashrc 文件。这一点适用
于所有类型的 shell 进程。     

## 6.7 数组变量

环境变量有一个很酷的特性就是，它们可以作为 **数组** 适用。   

要给某个环境变量设置多个值，可以把值放在括号里，值与值之间用空格分隔。   

```bash
$ mytest=(one two three four five)
```   

但如果直接显示这个变量，就只会显示第一个值。要引用一个单独的数组元素，就必须用代表它在数组中位置
的数值索引值。索引值要用方括号括起来，从零开始：   

```bash
$ echo ${mytest[2]}
```   

要显示整个数组变量，可用星号作为通配符放在索引值的位置：   

```bash
$ echo ${mytest[*]}
one two three four five
```  

也可以改变某个索引值位置的值：   

```bash
$ mytest[2]=seven
```   

甚至能用 `unset` 命令删除数组中的某个值，但是要小心，这可能会有点复杂：   

```bash
$ unset mytest[2]
$ echo ${mytest[*]}
one two four five
$ echo ${mytest[2]}

$ echo ${mytest[3]}
four
```    

可以看出直接访问索引 2 的元素时，显示为空。    

Last Update: 2018.11.30
