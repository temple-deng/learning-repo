# 第 4 章 文件系统

<!-- TOC -->

- [第 4 章 文件系统](#第-4-章-文件系统)
  - [4.1 文件](#41-文件)
    - [4.1.1 文件命名](#411-文件命名)
    - [4.1.3 文件类型](#413-文件类型)
    - [4.1.4 文件访问](#414-文件访问)
    - [4.1.5 文件属性](#415-文件属性)
    - [4.1.6 文件操作](#416-文件操作)
  - [4.2 目录](#42-目录)
    - [4.2.4 目录操作](#424-目录操作)
  - [4.3 文件系统的实现](#43-文件系统的实现)
    - [4.3.1 文件系统布局](#431-文件系统布局)
    - [4.3.2 文件的实现](#432-文件的实现)
    - [4.3.3 目录的实现](#433-目录的实现)
    - [4.3.4 共享文件](#434-共享文件)
    - [4.3.5 日志结构文件系统](#435-日志结构文件系统)
    - [4.3.6 日志文件系统](#436-日志文件系统)
    - [4.3.7 虚拟文件系统](#437-虚拟文件系统)
  - [4.4 文件系统管理和优化](#44-文件系统管理和优化)
    - [4.4.1 磁盘空间管理](#441-磁盘空间管理)
    - [4.4.4 文件系统性能](#444-文件系统性能)

<!-- /TOC -->

## 4.1 文件

### 4.1.1 文件命名

有些文件系统区分大小写，有点不区分，UNIX 属于前者，而MS-DOS 上使用的老的文件系统则不区分。老的
MS-DOS 使用的 FAT-16以及其扩展版的 FAT-32 应该都是不区分的。不过新版的 Windows 都用的
是先进的本地文件系统 NTFS，所以也是区分的。       

Windows 为文件的扩展名赋予了含义。用（或进程）可以在操作系统中注册扩展名，并且规定哪个程序“拥有”
该扩展名。当用户双击某个文件名时，“拥有”该文件扩展名的程序就启动并运行该文件。     

### 4.1.3 文件类型

很多操作系统支持多种文件类型。如 UNIX 和 Windows 中都有普通文件和目录。UNIX 还有字符
特殊文件和块特殊文件。     

普通文件一般分为 ASCII 文件和二进制文件。ASCII 文件的最大优势是可以显示和打印，还可以用
文本编辑器编辑。二进制文件有一定的内部结构，使用该文件的程序才了解这种结构。   

### 4.1.4 文件访问

早期操作系统只有一种文件访问方式：顺序访问。    

当用磁盘来存储文件时，可以不按顺序地读取文件中的字节或记录，或者按照关键字而不是位置来访问记录。这种能
够以任何次序读取其中字节或记录的文件称作随机访问文件。    

有两种方法可以指示从何处开始读取文件。一种是每次 `read` 操作都给出开始读文件的位置。另一种是用一个特殊的
`seek` 操作设置当前位置，在 `seek` 操作后，从这个当前位置顺序地开始读文件。UNIX 和 Windows 使用的是
后一种方法。     

### 4.1.5 文件属性

文件都有文件名和数据。另外所有操作系统还会保存其他与文件相关的信息，如文件创建的日期和时间、文件大小等。
这些附加信息称之为文件 **属性**，或者叫 **元数据**。文件的属性在不同系统中差别很大。    

![file-properties](https://raw.githubusercontent.com/temple-deng/markdown-images/master/operating-system/file-properties.png)

### 4.1.6 文件操作

以下是与文件有关的最常用的一些系统调用：   

1. create
2. delete
3. open.使用文件之前，必须先打开文件。open调用的目的是，把文件属性和磁盘地址表装入内存
4. close.
5. read
6. write
7. append
8. seek
9. get attributes
10. set attributes
11. rename     

## 4.2 目录

### 4.2.4 目录操作

不同系统中管理目录的系统调用的差别比管理文件的系统调用差别大，下面以 UNIX 为例给出一组调用的操作：    

1. create。创建目录
2. delete。删除目录，只有空目录可删除。只包含目录项"." 和 ".." 的目录被认为是空目录，这两个目录项
通常不能删除。
3. opendir。目录内容可被读取，与打开和读文件相同，在读目录前，必须打开目录。
4. closedir。关闭目录。
5. readdir。系统调用 readdir 返回打开目录的下一个目录项。
6. rename。
7. link。链接技术允许在多个目录中出现同一个文件。这个系统调用指定一个存在的文件和一个路径名，并建立
从该文件到路径所指名字的链接。这样，可以在多个目录中出现同一个文件。这种类型的链接增加了该文件 i-node
计数器的计数，称为硬链接。
8. unlink。删除目录项。如果被解决连接的文件只出现在一个目录中，则将它从文件系统中删除。如果它出现在多个目录
中，则只删除指定路径名的连接，依然保留其他路径名的链接。    

## 4.3 文件系统的实现

### 4.3.1 文件系统布局

文件系统存放在磁盘上。多数磁盘划分为一个或多个分区，每个分区中有一个独立的文件系统（划重点）。磁盘的
0号扇区称为 **主引导记录**（Master Boot Record, MBR），用来引导计算机。在MBR 的结尾是分区表。该表
给出了每个分区的起始和结束地址。表中的一个分区被标记为活动分区。在计算机被引导时，BIOS 读入并执行
MBR。MBR 做的第一个件事是确定活动分区，读入它的第一个块，称为 **引导块**（boot block），并执行之。
引导块中的程序将装载该分区中的操作系统。     

![file-table](https://raw.githubusercontent.com/temple-deng/markdown-images/master/operating-system/file-table.png)

除了从引导块开始之外，磁盘分区的布局是随着文件系统的不同而变化的。文件系统经常包含如下的几个项目。    

+ **超级块**：包含文件系统的所有关键参数，在计算机启动时，或者在该文件系统首次使用时，超级块会被
读入内存。超级块中的典型信息包括：确定文件系统类型用的魔数、文件系统中块的数量以及其他重要的管理信息。
+ **空闲块的信息**
+ **i节点**
+ **根目录**
+ **文件和目录**     

### 4.3.2 文件的实现

文件存储实现的关键问题是记录各个文件分别用到了哪些磁盘块。不同的系统采用不同的方法：    

+ **连续分配**   

最简单的分配方案是把每个文件作为一连串连续数据块存放在磁盘上。在目录项中只需记录第一块的磁盘地址
和文件的块数即可。         

连续分配的读操作性能较好，因为在单个操作中就可以从磁盘上读出整个文件。只需要一次寻找，之后
就不再需要寻道和旋转延迟。   

+ **链表分配**     

第二种方案是为每个文件构造磁盘块链表，每个块的第一个字作为指向下一块的指针，块的其他部分存放数据。在目录项
中，只需要存放第一个块的磁盘地址即可。     

问题是随机访问会很慢，第二个就是由于指针占据了一些字节，所以要读出完整的一个块的大小的信息，
就需要从两个磁盘块中获得和拼接信息。    

+ **采用内存中的表进行链表分配**     

将每个磁盘块的指针字放到内存中的表上，内存中的这样一个表格称为 **文件分配表**（File Allocation Table, FAT）。
但是这样的话对于大磁盘的话，内存中的这张表会很大。    

+ **i 节点**    

给每个文件赋予称为 **i 节点**的数据结构，其中列出了文件属性和文件块的磁盘地址，只有在对应的文件打开时，其 i 节点
才在内存中。这样的话相对于上一个方案，i 节点的方案所占的内存比较小。    

![i-node](https://raw.githubusercontent.com/temple-deng/markdown-images/master/operating-system/i-node.png)


### 4.3.3 目录的实现

在读文件前，必须先打开文件。打开文件时，操作系统利用用户给出的路径名找到相应的目录项。目录
项中提供了查找文件磁盘块所需要的信息。因系统而异，这些信息可能是 i 节点号。无论怎样，目录
的主要功能是把 ASCII 文件名映射成定位文件数据所需的信息。       

与此密切相关的问题是何处存放文件属性。一种显而易见的方法是存放在目录项中。    

对于采用 i 节点的系统，还有另一种方法，即把文件属性存放在 i 节点中而不是目录项中。这种情形
下，目录项会更短：只有文件名和 i 节点号。   

处理可变长度文件名字的一种方案是，每个目录项有一个固定部分，这个固定部分通常以目录项的长度
开始，后面是固定格式的数据，通常包括所有者、创建时间、包含信息以及其他属性（话说不是文件
属性放在 i 节点中嘛）。这个固定长度的头的后面是一个任意长度的实际文件名。这个方案的缺点
是移走文件后留下的空隙不好处理。     

处理可变长度文件名字的一种方法是，使目录项自身都有固定长度，而将文件名放置在目录后面的堆中。这一方法
的优点是当一个文件目录项被移走后，另一个文件的目录项总是可以适合这个空隙。不过话说那文件名移除后该怎么办，
堆是会立刻压缩呢，还是保留空隙隔一段时间压缩一次。    

对于非常长的目录（这里应该是指里面文件特别多），线性查找一个文件名速度太慢。加快速度的一个方法是使用散列表。
用文件名进行散列。     

### 4.3.4 共享文件

共享文件是方便的，但也带来一些问题。如果目录中包含磁盘地址，则当链接文件时，必须把 C 目录
中的磁盘地址复制到 B 目录中。如果 B 或 C 随后又往该文件中添加内容，则新的数据块将只列入
进行添加工作的用户的目录中。其他的用户对此改变是不知道的。    

有两种方案可以解决这一问题。第一种方案就是 i 节点，把磁盘块的信息放在单独的数据结构中，
而不是目录中。（那么就有个问题啊，硬链接可以跨分区链接嘛，感觉是不成的）      

另一种方案就是让系统建立一个类型为 LINK 的新文件，并把该文件放在 B 的目录下，使得 B 与
C 的一个文件存在链接。新的文件中只包含了它所链接的文件的路径名。当 B 读该链接文件时，操作
系统查看到要读的文件是 LINK 类型，则找到该文件所链接的文件的名字，并去读那个文件，这就是
**符号链接**。   

### 4.3.5 日志结构文件系统

促使设计 **日志结构文件系统**（Log-structured File System, LFS）的主要原因是，CPU 的速度越来越快，
内存容量越来越大，同时磁盘高速缓存也迅速地增加。进而，不需要磁盘访问操作，就有可能满足直接来自文件系统
高速缓存的很大一部分只读请求。未来多数的磁盘访问是写操作。     

写操作往往是零碎的。出于这一原因，LFS 的设计者决定重新实现一种 UNIX 文件系统，该系统即使面对一个大部分
由零碎的随机写操作组成的任务，同样能够充分利用磁盘的带宽。其基本思想是将整个磁盘结构化为一个日志。每隔一段时间，
或是有特殊需要时，被缓冲在内存中的所有未决的写操作都被放到一个单独的段中，作为在日志末尾的一个邻接段写入磁盘。
这个单独的段可能会包括 i 节点、目录块、数据块或者都有。每一个段的开始都是该段的摘要，说明该段中
都包含有哪些内容。    

这种设计中，要在磁盘中找到一个 i 节点就比较麻烦了，为了找到 i 节点，必须要维护一个由 i节点编号索引组成的
i节点图。在这个图中的表项 i 指向磁盘中的第i个i节点。这个图保存在磁盘上，但是也保存在高速缓存中，大多数
情况下这个图的最常用部分还是在内存中。     

总而言之，所有的写操作最初都被缓冲在内存中，然后周期性地把所有已缓冲的写作为一个单独的段，
在日志的末尾处写入磁盘。要打开一个文件，则首先需要从 i 节点图中找到文件的 i 节点。    

这样的话随着时间的推移，磁盘空间会被整个日志占满，而很多被删除的文件还在磁盘上占据着空间。为了解决这个问题，
LFS 有一个清理线程，该线程周期地扫描日志进行磁盘压缩。该线程首先读日志中的第一个段的摘要，检查有哪些i节点
和文件。然后该线程查看当前i节点图，判断该节点是否有效已经文件块是否在使用中。如果没有使用，则该信息被丢弃。如果
仍然使用，那么i节点和块就进入内存等待写回到下一段中，接着，原来的段被标记为空间，以便日志可以把它用来放新的
数据。     

### 4.3.6 日志文件系统

日志结构文件系统由于和现有的文件系统不匹配，所有没能广泛使用，不过其思想被其他文件系统借鉴。其基本思想
是保存一个用于记录系统下一步将要做什么的日志。这样当系统在完成它们即将完成的任务前崩溃时，重新启动后，
可以通过查看日志，获取崩溃前计划完成的任务，并完成它们。这样的文件系统称为 **日志文件系统**。    

日志系统会将每次将要完成的动作写到一个日志项中，然后日志项被写入磁盘。只有当日志项已经被写入，不同的
操作才可以进行。当所有的操作成功完成后，擦除日志项。如果系统这时崩溃，系统恢复后，文件系统可以通过检查
日志来查看是不是有未完成的操作。如果有，可以重新运行所有未完成的操作。不过这里有东西没说明白啊，比如我
写入一个文件时，数据要不要保存在日志项中，保存的话，日志项会不会太大，不保存的话，崩溃后是无法恢复的把。    

### 4.3.7 虚拟文件系统

即使在同一个操作系统下，都可能会使用到很多不同文件系统。Windows 通过指定不同的盘符来处理这些不同
的文件系统，比如 "c:", "d:"。当一个进程打开一个文件，盘符是显式或者隐式存在的，所有 Windows 知道
向哪个文件系统传递请求，不需要尝试将不同类型文件系统整合为统一的模式。    

而UNIX 则做了这样的尝试，即将多种文件系统整合到一个统一的结构中。由于Sun公司之前的工作，绝大多数UNIX
操作系统都使用 **虚拟文件系统**（Virtual File System, VFS）概念尝试将多种文件系统统一成一个有序的结构。
关键的思想是抽象出所有文件系统都共有的部分，并且将这部分代码放在单独的一层，该层调用底层的实际文件系统来具体管理
数据。    

所有和文件系统相关的系统调用在最初的处理上都指向虚拟文件系统。这些来自用户进程的调用，都是标准的POSIX 
系统调用，比如 open, read, write 等。因此，VFS 对用户进程有一个“上层”接口。同时，其对实际的文件系统还有
一个“下层”的接口，这个接口包含很多功能调用，这样VFS能使每一个文件系统完成任务。     

当系统启动时，根文件系统在 VFS 中注册。另外，当装载其他文件系统时，不管是在启动时还是在操作过程中，
它们也必须在VFS 中注册，当一个文件系统注册时，它做的最基本的工作就是提供一个包含VFS 所需要的函数地址的列表。    

## 4.4 文件系统管理和优化

### 4.4.1 磁盘空间管理

一旦选定了块大小，下一个问题就是怎样跟踪空闲块。有两种方法被广泛采用。第一种是采用磁盘块
链表，链表中的每个块包含尽可能多的空闲磁盘块号。对于 1KB 大小的块和 32 位的磁盘块号，空闲
表中每个块包含有 255 个空闲块的块号（需要有一个位置存放指向下一个块的指针）。     

另一种空闲磁盘空间管理方式是采用位图。     

### 4.4.4 文件系统性能

+ **高速缓存**    

最常用的减少磁盘访问次数技术是 **块高速缓存**或者 **缓冲区高速缓存**。在本书中，高速缓存
指的是一系列的块，它们在逻辑上属于磁盘，但实际上基于性能的考虑被保存在内存中。    

管理高速缓存有不同的算法，常用的算法是：检查全部的读请求，查看在高速缓存中是否有所需要的块。
如果存在，可执行读操作而无须访问磁盘。如果该块不在高速缓存中，首先要把它读到高速缓存，然后
再复制到所需地方。    

在 UNIX 中有一个系统调用 sync，它强制性地把全部修改过的块立即写回磁盘。系统启动时，在后台
运行一个通常名为 update 的程序，它在无限循环中不断执行 sync 系统调用，每两次调用之间
休眠 30 s。    

+ **块提前读**    

在需要用到块之前，视图提前将其写入高速缓存，从而提高命中率。不过，块提前读策略只适用于实际
顺序读取的文件。对随机访问文件，不起作用。    

+ **减少磁盘臂运动**     

把可能顺序访问的块放在一起，最好是在同一柱面上，从而减少磁盘臂的移动次数。     
