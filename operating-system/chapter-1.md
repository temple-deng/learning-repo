# 第 1 章 引论

<!-- TOC -->

- [第 1 章 引论](#第-1-章-引论)
  - [1.1 什么是操作系统](#11-什么是操作系统)
    - [1.1.1 作为扩展机器的操作系统](#111-作为扩展机器的操作系统)
    - [1.1.2 作为资源管理者的操作系统](#112-作为资源管理者的操作系统)
  - [1.3 计算机硬件简介](#13-计算机硬件简介)
    - [1.3.1 处理器](#131-处理器)
    - [1.3.2 存储器](#132-存储器)
    - [1.3.4 I/O 设备](#134-io-设备)
    - [1.3.5 总线](#135-总线)
    - [1.3.6 启动计算机](#136-启动计算机)
  - [1.5 操作系统概念](#15-操作系统概念)
    - [1.5.1 进程](#151-进程)
    - [1.5.2 地址空间](#152-地址空间)
    - [1.5.3 文件](#153-文件)
  - [1.6 系统调用](#16-系统调用)
    - [1.6.0 系统调用补充内容](#160-系统调用补充内容)
    - [1.6.1 用于进程管理的系统调用](#161-用于进程管理的系统调用)
    - [1.6.2 用于文件管理的系统调用](#162-用于文件管理的系统调用)
    - [1.6.4 各种系统调用](#164-各种系统调用)
  - [1.8 依靠 C 的世界](#18-依靠-c-的世界)
    - [1.8.3 大型变成项目](#183-大型变成项目)
  - [总结 第 1 章 引论](#总结-第-1-章-引论)
    - [1.1 什么是操作系统](#11-什么是操作系统-1)
    - [1.2 操作系统的历史](#12-操作系统的历史)
    - [1.3 计算机硬件简介](#13-计算机硬件简介-1)
    - [1.5 操作系统概念](#15-操作系统概念-1)

<!-- /TOC -->

多数计算机有两种运行模式： 内核态和用户态。软件中最基础的部分是操作系统，它运行在内核态（也称为管态、核心
态）。在这个模式中，操作系统具有对所有硬件的完全访问权，可以执行机器能够运行的任何指令。软件的其余部分
则运行在用户态下。在用户态下，只使用了机器指令中的一个子集。特别地，那么会影响机器的控制或可进行 I/O 操作
的指令，在用户态中的程序里是禁止的。   

## 1.1 什么是操作系统

操作系统有两个基本上独立的任务，即为应用程序员提供一个资源集的清晰抽象，并管理这个硬件资源，而不仅仅是一堆
硬件。    

### 1.1.1 作为扩展机器的操作系统

在机器语言一级上，多数计算机的体系结构是很原始的，以 SATA 硬盘为例，多数程序员是使用一些叫做硬盘
驱动的软件来与硬件交互。这类软件提供了读写硬盘块的接口，而不用深入细节。   

但是即使在这个层面，对于大多数应用来说还是太底层了，因此，所有的操作系统都提供使用硬盘的又一层抽象：文件。    

### 1.1.2 作为资源管理者的操作系统

把操作系统看做向应用程序提供基本抽象的概念，是一种自顶向下的观点。按照另一种自底向上的观点，操作系统
则用来管理一个复杂系统的各个部分。现代计算机包含处理器、存储器、磁盘、鼠标等许多设备。从这个角度看，
操作系统的任务是在相互竞争的程序之间有序地控制对处理器、存储器以及其他I/O接口设备的分配。    

## 1.3 计算机硬件简介

### 1.3.1 处理器

CPU 从内存中取出指令并执行之。在每个 CPU 基本周期中，首先从内存中取出指令，解码以确定其类型和操作数，
接着执行之，然后取指、解码并执行下一条命令。   

由于访问内存得到指令或者数据的时间要比执行指令花费的时间长的多，因此，所有的 CPU 内都有一些用来保存关键
变量和临时数据的寄存器。    

除了用来保存变量和临时结构的通用寄存器以外，多数计算机还有一些对程序员可见的专用寄存器。其中之一是
**程序计数器**，它保存了将要取出的下一条指令的内存地址。在指令取出之后，程序计数器就被更新以便指向
后继的指令。  

另一个寄存器是**堆栈指针**，它指向内存中当前栈的顶端，该栈包含了每个执行过程的栈帧。一个过程中的
栈帧中保存了有关的输入参数、局部变量以及那些没有保存在寄存器中的临时变量。感觉栈帧有点像程序中进入
一个局部作用域一样，比如在 JS 中函数调用进入一个 Execute Context。       

另一个寄存器是**程序状态字**（Program Status Word, PSW）。这个寄存器包含了条件码位、CPU 优先级、
模式（用户态还是内核态），以及其他各种控制位。    

在时间多路复用CPU中，操作系统经常会中止正在运行某个程序并启动（或再启动）另一个程序。每次停止一个运行着
的程序时，操作系统必须保存所有的寄存器值，这样在稍后该程序被再次运行时，可以把这些寄存器重新装入。（应该是
保存在进程表中了）     

为了改善性能，CPU 设计师早就放弃了同时读取、解码和执行一条指令的简单模型。许多现代 CPU 具有同时
取出多条指令的机制。例如，一个 CPU 可以有单独的取指单元、解码单元和执行单元，于是当它执行指令 n 时，
还可以对指令 n+1 解码，并且读取指令 n+2。这样的机制称为**流水线**。在多数的流水线设计中，一旦一条
指令被取进流水线中，它就必须被执行完毕，即便前一条取出的指令是条件转移，它也必须被执行完毕。流水线使得
编译器和操作系统的编写者很头疼，因为它造成了在机器中实现这些软件的复杂性问题。　　　　

比流水线更先进的设计是**超标量CPU**。在这种设计中，有多个执行单元，例如，一个CPU 用于整数算术运算，
一个CPU 用于浮点算术运算，一个CPU 用于布尔运算。两个或更多的指令被同时取出、解码并装入暂存缓存区中，直至
它们执行完毕。这里应该是一个 CPU 内部的执行单元可以按功能分成多个小部件。    

为了从操作系统中获得服务，用户程序必须使用**系统调用**以陷入内核并调用操作系统。**TRAP**指令把用户态
切换成内核态，并启用操作系统。当有关工作完成之后，在系统调用后面的指令把控制权返回给用户程序。     

然而，计算机（这里理论上应该是指操作系统吧）使用的是陷阱而不是一条指令（即TRAR 指令吧）来执行系统调用。其他的多数陷阱是由硬件引起的，用于警告有异常情况的发生。在所有的情况下，操作系统都得到控制权并决定如何处理异常情况。     

多线程或者超线程 CPU 允许保持两个不同的线程状态，然后在纳秒级别的时间尺度内来回切换，也就是说并不是多线程
并行运行，只是提供了快速的线程上下文切换。     

### 1.3.2 存储器

存储器系统的顶层是 CPU 中的寄存器，它们用与 CPU 相同的材料制成，所以和 CPU 一样快。显然，访问它们
是没有时延的，其典型的存储容量是，在 32位 CPU为 32 × 32位，在 64位 CPU为 64 × 64，也
就是 512B 咯。    

下一层是高速缓存，被分割成高速缓存行，典型大小为64字节（注意这个大小是缓存行的大小，而高速缓存的大小是不定，
比如L1、L2、L3缓存大小肯定是不一样的），地址0至63对应高速缓存行0，地址64到127对应
高速缓存行1，依次类推。高速缓存命中通常需要两个时钟周期，如果未命中就要访问内存了。这里的两个时钟周期应该
是平均的命中时间，因为从后面可以得知，L1缓冲命中是无时延的，但是L2是有1到2个周期的，L3肯定就更多了。       

多数现代 CPU 设计了两个缓存。第一级或称为 L1 缓存总是在 CPU 中，通常用来将已解码的指令调入 CPU 的
执行引擎。典型的 L1 缓存大小为 16KB，另外往往还设计有二级缓存，称为 L2 缓存。L1 和 L2 缓存之间
的差别在于时序。对 L1 缓存的访问，不存在任何时延；而对 L2 缓存的访问则会延时1或2个时钟周期。   

ROM 在工厂中就被编程完毕，然后再也不能被修改。   

EEPROM（电可擦除可编程ROM） 和闪存也是非易失性的，但是与 ROM 相反，它们可以擦除和重写。闪存的擦除次数过多，会被磨损。       

还有一类存储器是 CMOS，它是易失性的。许多计算机利用 CMOS 存储器保持当前时间和日期。CMOS 存储器和递增时间
的时钟电路由一块小电池驱动。CMOS 还可以保存配置参数。    

### 1.3.4 I/O 设备

I/O 设备一般包括两个部分：设备控制器和设备本身。控制器是插在电路板上的一块芯片或一组芯片，这块电路板物理地
控制设备。它从操作系统接受命令，例如从设备读数据，并且完成数据的处理。     

现在 SATA 是很多计算机的标准硬盘接口。由于实际的设备接口隐藏在控制器中，所以，操作系统看到的是对控制器
的接口，这个接口可能和设备接口有很大的区别。    

I/O 设备的另一个部分就是实际设备的自身。设备本身有个相对简单的接口，这是因为接口即不能做很多工作，又已经
被标准化了。例如，标准化后任何一个 SATA 磁盘控制器就可以适配任一种SATA 磁盘。   

每类设备控制器都是不同的，所以，需要不同的软件进行控制。专门与控制器对话，发出命令并接收响应的软件，称为设备
驱动程序。每个控制器厂家必须为所支持的操作系统提供相应的设备驱动程序。**为了能够使用设备驱动程**
**序，必须把驱动程序装入到操作系统中，这样它就可以在核心态运行**。   

因为操作系统是操作系统厂商写的，驱动是设备厂商写的，所以要有种方法把驱动程序装到操作系统中。    

也就是说通常应用程序和操作系统打交道，然后操作系统和驱动打交道，驱动再去操作控制器，控制器再去和硬件提供的
接口对话。    

要将设备驱动程序装入操作系统，有三个途径。第一个途径是将内核与设备驱动程序重新链接，然后重启系统。许多 UNIX 系统
以这种方式工作。第二个途径是在一个操作系统文件中设置一个入口，并通知该文件需要一个设备驱动程序，然后重启系统。重启
时操作系统会去寻找所需的设备驱动程序并装载之。Windows 就是这种方式。第三种途径事实，操作系统能够在运行时接受
新的设备驱动程序并立即安好，无须重启，热插拔设备，诸如 USB 都需要动态可装载设备驱动程序。     

每个设备控制器都有少量用于通信的寄存器。例如，一个最小的磁盘控制器也会有用于指定磁盘地址、内存地址、扇区计数和方向
（读或写）的寄存器。要激活控制器，设备驱动程序从操作系统获得一条命令，然后翻译成对应的值，并写进设备寄存器中。
所有设备寄存器的集合构成了 I/O 端口空间。   

在有些计算机中，设备寄存器被映射到操作系统的地址空间，这样，它们就可以像普通存储字一样读出和写入。在
这种计算机中，不需要专门的I/O指令。在另外的一些计算机中，设备寄存器被放入一个专门的I/O端口空间中。
在这些机器中，提供在内核态中可使用的专门**IN**和**OUT**指令，供设备驱动程序读写这些寄存器用。    

实现输入和输出方式有三种。在最简单的方式中，用户程序发出一个系统调用，内核将其翻译成一个对应设备驱动程序
的过程调用。然后设备驱动程序启动I/O并在一个连续不断的循环中检查该设备，看设备是否完成了工作。当 I/O 结束
后，设备驱动程序把数据送到指定的地方并返回。然后操作系统将控制权返回给调用者。这种方式称为**忙等待**，其
缺点是要占据 CPU，CPU 一直轮询设备知道 I/O 操作完成。    

第二种方式是设备驱动程序启动设备并且让该设备在操作完成时发出一个中断。设备驱动程序在这个时刻返回。操作系统
接着在需要时阻塞调用者并安排其他工作进行。     

一旦 CPU 决定取中断，通常程序计数器和 PSW （这是上一条程序的相关寄存器值吧）就被压入当前堆栈中，并且 CPU 被切换到用户态。设备编号（由中断
控制器放到总线上）可以成为部分内存的一个引用，用于寻找该设备中断处理程序的地址。这部分内存称为**中断向量**。当中断处理程序（中断设备的设备驱动程序的一部分）开始后，它取走已入栈的程序计算器和PSW，并保存之，然后查询设备的状态。    

第三种方式是，为 I/O 使用一种特殊的**直接存储器访问**（DMA）芯片，它可以控制在内存和某些控制器之间
的位流，无须 CPU 的干预。CPU 对 DMA 芯片进行设置，接着启动 DMA。当 DMA 芯片完成时，它引发一个中断，其处理
方式同上。   

### 1.3.5 总线

直到发明PCIe总线的2004年，大多数总线都是并行且共享的。共享总线架构表示多个设备使用一些相同的
导线传输数据。因此，当多个设备同时需要发送数据时，需要仲裁器决定哪个设备可以使用总线。PCIe 恰
好相反，它使用分离的端到端的链路。传统 PCI 使用的并行总线架构表示通过多条导线发送数据的每一个
字。PCIe 使用**串行总线架构**，通过一条被称为数据通路的链路传递集合了所有位的一条消息。这样做简单了很多，
因为不用再确保32位在同一时刻精确地到达目的地。通过将多个数据通路并行起来，并行性仍可有效利用，例如，可以
使用32个数据通过并行传输32条消息。      

CPU 通过 DDR4 总线与内存对话，通过 PCIe 总线与外围图形设备对话，通过 DMI(Direct Media Interface)
总线经集成中心与所有其他设备对话。而集成中心通过通用串行总线与USB 设备对话，通过 SATA 总线与硬盘和
DVD 驱动器对话，通过 PCIe 传输以太网帧。都是 PCIe 设备，怎么显卡的地位和其他设备还不一样呢。       

SCSI 总线是一种高速总线，用在高速硬盘、扫描仪和其他需要较大带宽的设备上。     

要在图中的环境下工作，操作系统必须了解有些什么外部设备连接到计算机上，并对它们进行配置。这种需求
导致 Inter 和 微软设计了一种名为 **即插即用**的I/O 系统。即插即用的工作是，系统自动地收集有关
I/O 设备的信息，集中赋予中断级别和I/O 地址，然后通知每块卡使用的数值。这项工作与计算机的启动密切
相关。     

那这其实理论上是在 BIOS 中需要完成的工作把，进行硬件自检，然后向 I/O 设备的驱动器中写入其使用的
中断级别和 I/O 地址？   

### 1.3.6 启动计算机

简要启动过程如下。在每台计算机上有一块双亲版。在双亲板上有一个称为**基本输入输出系统**BIOS的程序，
在BIOS 中有底层 I/O 软件，包括读键盘、写屏幕、进行磁盘 I/O 以及其他过程。现在这个程序放在闪速 RAM 中，
但它是非易失性的，这点很重要，意味着 BIOS 程序可以持久保存，不过操作系统可以更新 BIOS 程序。    

在计算机启动时，BIOS 开始运行。它首先检查所安装的 RAM 数量，键盘和其他设备是否已安装并正常响应。接着，
它开始扫描 PCIe 和 PCI 总线并找出连在上面的所有设备。即插即用设备也被记录下来。如果现有的设备和系统上一次
启动时的设备不同，则新的设备将被配置。     

然后，BIOS 通过尝试存储在 CMOS 存储器中的设备清单决定启动设备。用户可以在系统刚启动之后进入一个 BIOS
配置程序，对设备清单进行修改。典型地，如果存在 USB 设备，则系统试图从中启动；如果失败，系统将从硬盘启动。
启动设备上的第一个扇区被读入内存并执行。这个扇区中包含一个对保存在启动扇区末尾的分区表检查的程序，以确定
哪个分区是活动的。（也就是分两部分嘛，一部分的启动程序，一部分的分区表）。然后，从该分区读入第二个启动
装载模块。来自活动分区的这个装载模块被读入操作系统，并启动之。     

然后，操作系统询问 BIOS，以获得配置信息。对于每种设备，系统检查对应的设备驱动程序是否存在。如果
没有，系统要求用户插入含有该设备驱动程序的 CD 或者从网络上下载驱动程序。一旦有了全部的设备驱动
程序，操作系统就将它们调入内核。然后初始化有关表格，创建需要的任何背景进程，并在每个终端上启动
登录程序或 GUI。  

## 1.5 操作系统概念

### 1.5.1 进程

进程本质上是一个正在执行的一个程序。与每个进程相关的是**地址空间**，这是从某个最小值的存储位置到某个
最大值的存储位置的列表。在这个地址空间中，进程可以进行读写。该地址空间中存放有可执行程序、程序的数据和堆栈。
与每个进程有关的还有资源集，通常包括寄存器、打开的文件清单、突出的报警、有关进程清单，以及运行该程序
所需要的所有其他信息。在操作系统中，与一个进程有关的所有信息，除了该进程自身地址空间的内容以外，均放在操作系统
的一张表中，称为**进程表**，进程表是数组（或链表）结构，当前存在的每个进程都要占用其中的一项。    

在限定的秒数流逝之后，操作系统向该进程发送一个警告信号。此信号引起该进程暂时挂起，无论该进程正在
做什么，系统将其寄存器的值保存到堆栈，并开始运行一个特别的信号处理过程，比如重新发送可能丢失的
信息。这些信号是软件模拟的硬件中断，除了定时器到期之外，该信号可以由各种原因产生。许多由硬件检测
出来的陷阱，如执行了非法指令或使用了无效地址等，也被转换成该信号并交给这个进程。    

### 1.5.2 地址空间

在许多32位或64位地址的计算机中，分别有 2<sup>32</sup> 或 2<sup>64</sup>字节的地址空间。怎么
算的呢，32位系统，那一次性总线只有传送一个32位的地址，所以空间就是2的32次方了，每个地址保存一个
字节的数据，以32位来算就是最大支持4G的内存。    

### 1.5.3 文件

每个进程有一个**工作目录**，对于没有以斜线开头给出绝对地址的路径，将在这个工作目录下寻找。       

在读写文件之前，首先要打开文件，检查其访问权限。若权限许可，系统将返回一个小整数，称作**文件描述符**，
供后续操作使用。若禁止访问，系统则放回一个错误码。    

在 UNIX 中另外的总要概念是**特殊文件**，提供特殊文件是为了使 I/O 设备看起来像文件一般。这样，就像
使用系统调用读写文件一样，I/O 设备也可以通过同样的系统进行读写。有两类特殊文件：**块特殊文件**和**字符特殊文件**。
块特殊文件指那些可随机读取的块组成的设备，如磁盘。字符特殊文件用于打印机和其他接收或输出字符流的设备。    

**管道**是一类虚文件，它可连接两个进程。    

## 1.6 系统调用

任何单 CPU 计算机一次只能执行一条指令。如果一个进程正在用户态运行一个用户程序，并且需要一个系统服务，
比如从一个文件读数据，那么它必须执行一个陷阱或系统调用指令，将控制转移到操作系统。操作系统接着通过参数检查
找出所需要的调用进程。然后，它执行系统调用，并把控制返回给在系统调用后面跟随着的指令。    

以 read 系统调用为例，说明一下系统调用的步骤。用户程序在调用 read 后，程序将参数压进堆栈（1~3步）。接着
调用 read 库（第4步）。   

在可能是由汇编语言写成的库过程中，一般把系统调用的编号放在操作系统所期望的地方，如寄存器中（第5步）。
然后执行一个 TRAP 指令，将用户态切换到内核态，并在内核中的一个固定位置开始执行（第6步）。TRAP 指令实际上
与过程调用指令非常类似非常类似，它们后面都跟随一个来自远处位置的指令，以及供以后使用的一个保存在栈中
的返回地址。     

跟随在 TRAP 指令后的内核代码开始检查系统调用编号，然后分派给正确的系统调用处理器，这通常是通过一张
由系统调用编号所引用的、指向系统调用处理器的指针表来完成（第7步）。此时，系统调用处理器运行（第8步）。
一旦系统调用处理器完成其工作，控制可能会在跟随在 TRAP 后面的指令中返回给用户空间库过程（第9步）。
这个过程接着以通常的过程调用返回的方式，返回到用户程序（第10步）。    

### 1.6.0 系统调用补充内容


先声明下面的内容不一定对，因为在别处看到，系统调用是通过陷阱实现的，而不是中断。   

操作系统一般是通过中断从用户态切换到内核态。中断就是一个硬件或软件请求，要求CPU暂停当前的工作，
去处理更重要的事情。比如，在x86机器上可以通过int指令进行软件中断，而在磁盘完成读写操作后会向
CPU发起硬件中断。     

一般地，系统调用都是通过软件中断实现的，x86系统上的软件中断由int $0x80指令产生，而128号异常
处理程序就是系统调用处理程序system_call()。    

Linux中每个系统调用都有相应的系统调用号作为唯一的标识，内核维护一张系统调用表，sys_call_table，
表中的元素是系统调用函数的起始地址，而系统调用号就是系统调用在调用表的偏移量。在x86上，系统调用
号是通过eax寄存器传递给内核的。    

所以整个系统调用的库中的代码可能干了这几件事。首先，用户程序为系统调用设置参数。其中一个参数是
系统调用编号。参数设置完成后，程序执行“系统调用”指令。x86系统上的软中断由int产生。这个指令会
导致一个异常：产生一个事件，这个事件会致使处理器切换到内核态并跳转到一个新的地址，并开始执行
那里的异常处理程序。此时的异常处理程序实际上就是系统调用处理程序，应该就是 system_call() 函数。
它与硬件体系结构紧密相关。       

新地址的指令会保存程序的状态，计算出应该调用哪个系统调用（查询 sys_call_table），调用内核中
实现那个系统调用的函数，恢复用户程序状态，然后将控制权返还给用户程序。      

因为所有的系统调用陷入内核的方式都一样，所以仅仅是陷入内核空间是不够的。因此必须把系统调用号
一并传给内核。所以就有了我们启动中断前，先把系统调用号和其他参数保存在寄存器中的操作。      

除了系统调用号以外，大部分系统调用都还需要一些外部的参数输人。所以，在发生异常的时候，应该把这些
参数从用户空间传给内核。最简单的办法就是像传递系统调用号一样把这些参数也存放在寄存器里。
在x86系统上，ebx, ecx, edx, esi和edi按照顺序存放前五个参数。需要六个或六个以上参数的情况不多见。       

用户空间的返回值也通过寄存器传递。在x86系统上，它存放在eax寄存器中。    

总结一下，以 read 系统调用为例，在调用了 read 库过程后，进入库过程代码，首先库过程将系统调用
编号及其他参数保存到寄存器中，之后执行 int $0x80　进行中断（注，貌似不同硬件架构的这个指令可能会不同），
中断后根据中断码 128 调到中断向量处，这个中断处理程序就是 system_call()，然后这个函数开始执行，
注意中断让程序进入内核态，在这个函数中，先将寄存器中保存的参数压入栈中，然后根据系统调用编号，
调用 sys_call_table 中对应的特定系统调用代码。      

```asm
ENTRY(entry_INT80_32)
  ASM_CLAC
  pushl   %eax            /* pt_regs->orig_ax */
  SAVE_ALL pt_regs_ax=$-ENOSYS    /* save rest */

  /*
    * User mode is traced as though IRQs are on, and the interrupt gate
    * turned them off.
    */
  TRACE_IRQS_OFF

  movl    %esp, %eax
  call    do_int80_syscall_32
...
```    

它将存在 eax 中的系统调用号压入栈中，然后调用 SAVE_ALL 将其他寄存器的值压入栈中进行保存。     

保存完毕后，关闭中断，将当前栈指针保存到 eax ，调用 
do_int80_syscall_32 => do_syscall_32_irqs_on ，该函数在 arch/x86/entry/common.c 中定义：

```c
static __always_inline void do_syscall_32_irqs_on(struct pt_regs *regs)
{
    struct thread_info *ti = current_thread_info();
    unsigned int nr = (unsigned int)regs->orig_ax;

#ifdef CONFIG_IA32_EMULATION
    current->thread.status |= TS_COMPAT;
#endif

    if (READ_ONCE(ti->flags) & _TIF_WORK_SYSCALL_ENTRY) {
        /*
         * Subtlety here: if ptrace pokes something larger than
         * 2^32-1 into orig_ax, this truncates it.  This may or
         * may not be necessary, but it matches the old asm
         * behavior.
         */
        nr = syscall_trace_enter(regs);
    }

    if (likely(nr < IA32_NR_syscalls)) {
        /*
         * It's possible that a 32-bit syscall implementation
         * takes a 64-bit parameter but nonetheless assumes that
         * the high bits are zero.  Make sure we zero-extend all
         * of the args.
         */
        regs->ax = ia32_sys_call_table[nr](
            (unsigned int)regs->bx, (unsigned int)regs->cx,
            (unsigned int)regs->dx, (unsigned int)regs->si,
            (unsigned int)regs->di, (unsigned int)regs->bp);
    }

    syscall_return_slowpath(regs);
}
```   

下面是 POSIX 标准中常用的几个系统调用：   

+ 进程管理
  - `pid = fork()`: 创建与父进程相同的子进程
  - `pid = waitpid(pid, &statloc, options)`: 等待一个子进程终止
  - `s = execve(name, argv, environp)`: 替换一个进程的核心映像
  - `exit(status)`: 终止进程执行并返回状态
+ 文件管理
  - `fd = open(file, how, ...)`: 打开一个文件供读、写或两者
  - `s = close(fd)`: 关闭一个打开的文件
  - `n = read(fd, buffer, nbytes)`: 把数据从文件读到缓冲区
  - `n = write(fd, buffer, nbytes)`: 把数据从缓冲区写到文件中
  - `position = lseek(fd, offset, whence)`: 移动文件指针
  - `s = stat(name, &buf)`: 取得文件的状态信息
+ 目录和文件系统管理
  - `s = mkdir(name, mode)`: 创建新目录
  - `s = rmdir(name)`: 删除一个空目录
  - `s = link(name1, name2)`: 创建一个新目录项name2，并指向 name1
  - `s = unlink(name)`: 删去一个目录项
  - `s = mount(special, name, flag)`: 安装一个文件系统
  - `s = unmount(special)`: 卸载一个文件系统
+ 杂项
  - `s = chdir(dirname)`: 改变工作目录
  - `s = chmod(name, mode)`: 修改一个文件的保护位
  - `s = kill(pid, signal)`: 发送信号给一个进程
  - `seconds = time(&seconds)`: 自1970.1.1 起的流逝时间   

上面的系统调用中，若出错 s 为 -1。    


注意一下，上面我们虽然说是系统调用，但更专业的来说，它们其实是系统调用的库过程。理论上来说，将 POSIX
过程映射到系统调用并不是一对一的（也就说库过程是库过程，系统调用是系统调用）。POSIX 标准定义了构造
所必须提供的一套过程，但是并没有规定它们是系统调用、库调用还是其他的形式。不过，多数 POSIX 过程确实
进行系统调用，通常是一个过程直接映射到一个系统调用上。    

个人感觉系统调用，是会产品进程切换的，应该是进行系统调用的时候，先把关键数据保存到寄存器上，然后执行中断指令，
此时陷入内核态，然后跳到一段内核代码中，内核代码中再去系统调用表中查询处理程序的地址，然后跳到对应位置，
执行完以后，再转回用户态，转到系统调用后面的地址上。    

### 1.6.1 用于进程管理的系统调用

`fork` 在 UNIX 中是唯一可以在 POSIX 中创建进程的调用。它创建一个原有进程的精确副本，包括所有
的文件描述符、寄存器等内容。fork 调用返回一个值，在子进程中该值为零，并且在父进程中等于子进程的进程标识符。   

`waitpid` 可以等待一个特定的子进程，或者通过将第一个参数设为 -1的方式，等待任何一个老的子进程。
在waitpid 完成后，将把第二个参数 statloc 所指向的地址设置为子进程的退出状态。    

现在考虑 shell 如何使用 fork。在键入一条命令后，shell 调用 fork 创建一个新的进程。这个子进程必须执行
用户的指令。通过使用 execve 系统调用可以实现这一点，这个系统调用会引起其整个核心映像（就是内存吧）
被一个文件所替代，该文件由第一个参数给定。     

下面是一个高度简化的shell 实现:    

```c
#define TRUE 1

while(TRUE) {
  type_prompt()      /* 输出命令提示符 */
  read_command(command, parameters)    /* 读入命令 */
  
  if(fork() != 0) {
    waitpid(-1, &status, 0);     /* 父代码 */
  } else {
    execve(command, parameters, 0)   /* 子代码 */
  }
}
```    

首先在读入命令后，fork 子进程，然后父进程执行 `waitpid` 调用，而子进程这时是与父进程完全相同的状态，
但是在子进程中 `fork()` 调用返回的是0，因此进入 else 条件，执行具体的命令，执行完后子进程退出，
父进程进入下一轮循环，那这里来看，`waitpid` 应该是一个阻塞调用。   

`execve` 有三个参数：将要执行的文件名称，一个指向变量数组的指针，以及一个指向环境数组的指针。   

以 `cp` 程序为例，cp程序及多数 C 程序的主程序都有声明: `main(argc, argv, envp)`。   

其中argc 是该命令行内有关参数数目的计数器，包括程序名称。例如 `cp file1 file2`，argc 为3。   

argv 是一个指向数组的指针，该数组的元素 i 是指向命令行第 i 个字符串的指针，在上例中，argv[0] 是
'cp', argv[1] 指向 'file1， argv[2] 指向 'file2'。    

第三个参数是一个指向环境的指针，该环境是一个数组，含有 name=value 的赋值形式。这个envp 好像就是
execve 中的第三个参数。         

`exit` 有一个参数——退出状态（0至255），该参数通过 waitpid 的 statloc 返回父进程。    

在 UNIX 中的进程将其存储空间分为三段：**正文段**（如程序代码）、**数据段**（如变量）以及**堆栈段**。
数据向上增长而堆栈向下增长。    

```
--------------
|   堆栈      |
--------------
|   空闲区    |
|            |
--------------
|   数据      |
--------------
|   正文      |
--------------
```    


### 1.6.2 用于文件管理的系统调用

要读写一个文件，首先要使用 `open` 打开文件，这个系统调用通过绝对路径名或指向工作目录的相对路径名指定要打开的
文件的名称，而代码 O_RDONLY、O\_WRONLY 或 O\_RDWR 的含义分别是只读、只写或者两者都可以。为了创建
一个新文件，使用O_CREAT 参数（注意没 E）。然后可使用返回的文件描述符进行读写操作，接着，可以用 `close`
关闭文件。     

与每个文件相关的是一个指向文件当前位置的指针。在顺序读（写）时，该指针通常指出要读出（写入）的下一个
字节。`lseek` 调用可以改变该位置指针的值。    

`lseek` 有3个参数：第一个是文件的描述符，第二个是文件位置，第三个说明该文件位置是相对于文件起始
位置、当前位置还是文件的结尾。在修改了指针之后，lseek 返回的值是文件中的绝对位置。    

UNIX 为每个文件保存了该文件的类型（普通文件、特殊文件、目录等）、大小、最后修改时间以及其他信息。程序
可以通过 stat 系统调用查看这些信息。第一个参数指定了要被检查的文件；第二个参数是一个指针，该指针
指向存放这些信息的结构。对于一个打开的文件来说，fstat 调用完成同样的工作。   

### 1.6.4 各种系统调用

kill 系统调用供用户或用户进程发送信号用。若一个进程准备好捕捉一个特定的信号，那么，在信号到来时，运行一个
信号处理程序。如果该进程没有准备好，那么信号的到来会杀掉该进程。    


## 1.8 依靠 C 的世界

### 1.8.3 大型变成项目

为了构建操作系统，每个 .c 被C 编译器编译成一个目标文件。目标文件使用后缀 .o，含有目标机器的二进制
代码（说明不同的机器编译出的目标文件是不同的）。随后它们可以直接在 CPU 上运行。     

C编译器的第一道称为**C 预处理器**。在它读入每个 .c 文件时，每当遇到一个 #include 指令，就取来
该名称的头文件，并加以处理、扩展宏、处理条件编译，然后将结果传递给编译器的下一道，仿佛它们原先就包含在
该文件中一样。    

由于操作系统非常大，每当文件修改后就重新编译是无法忍受的。另一方面，改变了用在成千上万个文件中的一个关键
头文件，确实需要重新编译这些文件。     

在 UNIX 中，有个名为 `make` 的程序，它读入 Makefile，该 Makefile 说明哪个文件与哪个文件有关。
make 的作用是，在构建操作系统二进制码时，检查此刻需要哪个目标文件，而且对于每个文件，检查自上次目标文件
创建之后是否有任何它依赖的文件已经被修改了。如果有，目标文件需要重新编译。在make 确定了哪个 .o 文件需要
重新编译之后，调用 C 编译器重新编译这些文件。    

一旦所有的 .o 文件就绪，这些文件被传递给称为 **linker** 的程序，将其组合成一个可执行的二进制文件。
在 linker 完成后，得到一个可执行程序，在 UNIX 称为 a.out 文件。    


## 总结 第 1 章 引论

现在的计算机由许多的部件组成，如果应用程序员在开发程序的时候直接与这些设备打交道，则必须掌握各个设备的各种的细节，难度很大，所以，计算机一般安装了一层软件，即操作系统，为应用程序提供一个更简单易用的计算机模型，并管理计算机中的设备。    

计算机，或者严格来说是CPU 有两种运行模式，用户态和内核态，操作系统运行在内核态，其他软件都运行在用户态。    

用户接口程序（shell 或者GUI），顾名思义，是操作系统与用户交互的程序部分，处在用户态程序的最底层，允许我们运行其他用户程序。所以严格来说，通常我们启动用户程序的时候都是用户接口程序来启动的。     

整章分了8个小节。第一小节介绍了什么是操作系统。第二小节介绍了操作系统的历史。第三小节介绍了计算机的硬件。
第四小节是介绍了一些不同的操作系统。第五小节介绍了一些操作系统中的常见概念。第六小节介绍了系统调用。
剩下两节分别介绍了操作系统的结构与C的世界。         

### 1.1 什么是操作系统   

很难直接给出操作系统的定义，但是从操作系统的基本工作我们可以简单看出操作系统的内容，操作系统有两个主要的任务，一个是为应用程序提供计算机模型资源集的抽象，来让用户程序可以更关注程序逻辑编程而不是复杂的硬件设备，另一个就是管理协调计算机的各个硬件设备。    

操作系统的实际客户是应用程序。它们直接与操作系统及其抽象打交道。相反，最终用户则是与用户接口所提供的抽象打交道，也就是用户接口程序shell或者GUI。    

从资源管理的角度来看，操作系统的任务是在相互竞争的程序之间有序地控制对处理器、存储器以及其他I/O 接口设备的分配。    

### 1.2 操作系统的历史

简单来说可以分为5个阶段，最初的真空管和穿孔卡片时代。第二代就是晶体管和批处理系统的时代。第三代是集成电路和多道程序设计的时代，第四代就是个人计算机时代。第五代就是现今的移动计算机时代。    

### 1.3 计算机硬件简介

第一部分就是CPU，在每个CPU基本周期中，从内存中取指，解码然后执行。每个CPU都是一套可执行的专门指令集。    

除了用来保存变量和临时结果的通用寄存器，计算机还有一些对程序员可见的专用寄存器，例如程序计数器，保存了将要取出的下一条指令的内存地址，堆栈指针，指向当前内存堆栈的顶端，程序状态字，保存一些进程的控制位。     

现代 CPU 都有流水线设计，在这种设计中，CPU有单独的取指单元、解码单元和执行单元，这样在执行第n个指令时，可以解码第n+1条指令，并取出第n+2条指令。    

比流水线更先进的是超标量CPU，在这种设计中，CPU有多个取指单元、解码单元和执行单元。因此可以同时取出并解码多条指令，并放到暂存缓冲区中，只要有执行单元空闲，就会从缓冲区中取出一条指令执行。   

为了从操作系统中活动服务，用户程序必须使用系统调用以陷入内核并调用操作系统。TRAP 指令把用户态切换成内核态，并启用操作系统。注意TRAP 指令与系统调用的区别，应该是普通的用户程序使用系统调用，然后系统调用的代码中会使用TRAP指令，使用后，用户程序陷入内核，这时候理论上由操作系统接手控制权，之后系统调用完成后再将控制权返回给用户程序。     

第二部分就是存储器，典型的计算机中的存储器可以分为寄存器、高速缓存、内存。内存是RAM，其次可能在计算机中还存在
一些其他类型的存储器，例如ROM，EEPROM，闪存，CMOS。     

磁盘的就没什么好介绍的了。   

第四部分就是 I/O 设备了，I/O设备可以分成两部分，一部分是控制器，另一部分就是设备本身。由于每类设备的
设备控制器是不同的，所以，需要不同的软件进行控制。专门与控制器对话，发出命令并接收响应的软件叫做驱动程序。   

### 1.5 操作系统概念

第一个概念是进程，进程的话主要部分就是其地址空间以及其在进程表中占用的一个表项中存储的进程相关内容的数据。    


