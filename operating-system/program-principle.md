# 程序员的自我修养

<!-- TOC -->

- [程序员的自我修养](#程序员的自我修养)
- [第一章 概述](#第一章-概述)
- [第二章 编译和链接](#第二章-编译和链接)
  - [2.1 被隐藏了的过程](#21-被隐藏了的过程)
    - [2.1.1 预编译](#211-预编译)
    - [2.1.2 编译](#212-编译)
    - [2.1.3 汇编](#213-汇编)
  - [2.2 编译器做了什么](#22-编译器做了什么)
    - [2.2.1 词法分析](#221-词法分析)
    - [2.2.2 语法分析](#222-语法分析)
    - [2.2.3 语义分析](#223-语义分析)
    - [2.2.5 目标代码生成与优化](#225-目标代码生成与优化)
  - [2.3 链接](#23-链接)
  - [2.4 模块拼装——静态链接](#24-模块拼装静态链接)
- [第 3 章 目标文件](#第-3-章-目标文件)
  - [3.1 目标文件的格式](#31-目标文件的格式)
  - [3.2 目标文件是什么样的](#32-目标文件是什么样的)
  - [3.3 挖掘 simple.o](#33-挖掘-simpleo)
    - [3.3.1 代码段](#331-代码段)
    - [3.3.2 数据段和只读数据段](#332-数据段和只读数据段)
    - [3.3.3 BSS 段](#333-bss-段)
    - [3.3.4 其他段](#334-其他段)
  - [3.4 ELF 文件结构描述](#34-elf-文件结构描述)
    - [3.4.1 文件头](#341-文件头)
    - [3.4.2 段表](#342-段表)
    - [3.4.3 重定位表](#343-重定位表)
    - [3.4.4 字符串表](#344-字符串表)
  - [3.5 链接的接口 —— 符号](#35-链接的接口--符号)
    - [3.5.1 ELF 符号表结构](#351-elf-符号表结构)
- [第 4 章 静态链接](#第-4-章-静态链接)
  - [4.1 空间与地址分配](#41-空间与地址分配)
    - [4.1.1 按序叠加](#411-按序叠加)
    - [4.1.2 相似段合并](#412-相似段合并)
    - [4.1.3 符号地址的确定](#413-符号地址的确定)
  - [4.2 符号解析与重定位](#42-符号解析与重定位)
    - [4.2.1 重定位](#421-重定位)
    - [4.2.2 重定位表](#422-重定位表)
    - [4.2.4 指令修正方式](#424-指令修正方式)
  - [4.4 静态库链接](#44-静态库链接)
- [第 6 章 可执行文件的装载与进程](#第-6-章-可执行文件的装载与进程)
  - [6.3 从操作系统角度看可执行文件的装载](#63-从操作系统角度看可执行文件的装载)
    - [6.3.1 进程的建立](#631-进程的建立)
- [第 7 章 动态链接](#第-7-章-动态链接)
  - [7.1 为什么要动态链接](#71-为什么要动态链接)
  - [7.2 简单的动态链接例子](#72-简单的动态链接例子)
- [第 10 章 内存](#第-10-章-内存)
  - [10.3 堆与内存管理](#103-堆与内存管理)
    - [10.3.1 什么是堆](#1031-什么是堆)

<!-- /TOC -->

# 第一章 概述

从整个层次结构上来看，开发工具与应用程序是属于同一个层次，因为它们都使用一个接口，那就是
操作系统应用程序编程接口 API。应用程序接口的提供者是运行库，什么样的运行库提供什么样的
API，比如 Linux 下的 Glibc 库提供 POSIX 的 API；Windows 的运行库提供 Windows API。
运行库使用操作系统提供的系统调用接口。    

**二元信号量** 是最简单的一种锁，它只有两种状态：占用和非占用。它适合只能被唯一一个线程
独占访问的资源。    

对于允许多个线程并发访问的资源，多元信号量简称 **信号量**。    

互斥量和二元信号量很类似，资源仅同时允许一个线程访问，但和信号量不同的是，信号量在整个系统
可以被任意线程获取并释放，也就是说，同一个信号量可以被系统中的一个线程获取之后由另一个线程
释放。而互斥量则要求哪个线程获取了互斥量，哪个线程就要负责释放这个锁。     

**读写锁**致力于一种更加特定的场合的同步。对于一段数据，多个线程同时读取总是没有问题，但
假设操作都不是原子型，只要有一个线程试图对这个数据进行修改，就必须使用同步手段来避免出错。
如果我们使用上述信号量、互斥量或临界区中的任何一种来进行同步，尽管可以保证程序正确，但
对于读取频繁，而仅仅偶尔写入的情况，会显得非常低效。读写锁可以避免这个问题。对于同一个锁，
读写锁有两种获取方式，**共享的** 或 **独占的**。  

当锁处于自由的状态时，试图以任何一种方式获取锁都能成功，并将锁置于对应的状态。如果锁处于
共享状态，其他线程以共享的方式获取锁仍然会成功。然而，如果其他线程试图以独占的方式获取
已经处于共享状态的锁，那么它将必须等待锁被所有的线程释放。相应地，处于独占状态的锁将阻止
任何其他线程获取该锁，不论他们试图以哪种方式获取。   

# 第二章 编译和链接

## 2.1 被隐藏了的过程

```c
#include <stdio.h>

int main() {
  printf("Hello World\n");
  return 0;
}
```    

在 Linux 下，当我们使用 GCC 来编译 Hello World 程序时：   

```bash
$ gcc hello.c
$ ./a.out
Hello World
```    

事实上，上述过程可以分解过 4 个步骤，分别是 **预处理**(Prepressing)、**编译**(Compilation)、
**汇编**(Assembly) 和 **链接**(Linking)。     

![2-1](https://raw.githubusercontent.com/temple-deng/markdown-images/master/program/2-1.png)  

### 2.1.1 预编译

首先是源代码文件 hello.c 和相关的头文件，如 stdio.h 等被预编译器 cpp 预编译成一个 .i 文件。
第一步预编译过程相当于如下命令：   

`$ gcc -E hello.c -o hello.i`     

预编译过程主要处理那些源代码文件中的以 "#" 开始的预编译指令。比如 "#include", "#define"
等，主要处理规则如下：    

+ 将所有的 `#define` 删除，并且展开所有的宏定义
+ 处理所有条件预编译指令，比如 `#if, #ifdef #elif #else #endif`
+ 处理 `#include` 预编译指令，将被包含的文件插入到该预编译指令的位置。注意，这个过程是
递归进行的，也就是说被包含的文件可能还包含其他文件
+ 删除所有的注释
+ 添加行号和文件名标识，比如 #2 "hello.c" 2，以便于编译时编译器产生调试用的行号信息及
用于编译时产生编译错误或警告时能够显示行号
+ 保留所有的 `#pragma` 编译器指令，因为编译器要用

经过预编译后的 .i 文件不包含任何宏定义，因为所有的宏都已经被展开，并且包含的文件也已经被
插入到 .i 文件中。     

### 2.1.2 编译

编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生成相应的汇编
代码文件。      

编译过程相当于如下命令：   

`$ gcc -S hello.i -o hello.s`    

gcc 这个命令只是一些后台程序的包装，它会根据不同的参数要求去调用预编译编译程序 cc1、汇编器
as、链接器ld。   

### 2.1.3 汇编

汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。所以汇编
器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，也不需要做指令优化。

```
$ as hello.s -o hello.o
// or
$ gcc -c hello.s -o hello.o
```   

## 2.2 编译器做了什么

编译过程一般可以分为 6 步：扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化。   

`array[index] = (index + 4) * (2 + 6)`    

### 2.2.1 词法分析

首先源代码程序被输入到 **扫描器**，它只是简单地进行词法分析，运用一种类似于 **有限状态机**（FSM）
的算法可以很轻松地将源代码的字符序列分割成一系列的 **记号**。    

词法分析产生的记号一般可以分为如下几类：关键字、标识符、字面量和特殊符号（如加号、等号）。
在识别记号的同时，扫描器也完成了其他工作。比如将标识符存放到符号表，将数字、字符串常量
存放到文字表等，以便后面的步骤备用。     

### 2.2.2 语法分析

接下来 **语法分析器** 将对由扫描器产生的记号进行语法分析，从而产生 **语法树**。整个分析
过程采用了 **上下文无关语法**。简单地讲，由语法分析器生成的语法树就是以 **表达式** 为
节点的树。

![2-2](https://raw.githubusercontent.com/temple-deng/markdown-images/master/program/2-2.png)

### 2.2.3 语义分析

接下来进行的是语义分析，由 **语义分析器**来完成。编译器所能分析的语义是 **静态语义**，所谓
静态语义是指在编译器可以确定的语义，与之对应的 **动态语义** 就是只有在运行期才能确定的语义。   

静态语义通常包含声明和类型的匹配，类型的转换。比如当一个浮点型的表达式赋值给一个整型的表达式
时，其中隐含了一个浮点型到整型转换的过程。    

经过语义分析阶段以后，整个语法树的表达式都被标识了类型，如果有些类型需要做隐式转换，语义分析
程序会在语法树中插入相应的转换节点。    

![2-3](https://raw.githubusercontent.com/temple-deng/markdown-images/master/program/2-3.png)

### 2.2.5 目标代码生成与优化

源代码级优化器产生中间代码标志着下面的过程都属于编辑器后端。编辑器后端主要包括 **代码生成器**
和 **目标代码优化器**。代码生成器将中间代码转换成目标机器代码，这个过程十分依赖于目标
机器，因为不同的机器有着不同的字长、寄存器、整数数据类型等。    

```asm
movl index, %ecx           ; value of index to ecx
addl $4, %ecx              ; ecx = ecx + 4
mull $8, %ecx              ; ecx = ecx * 8
movl index, %eax           ; value of index to eax
movl $ecx, array(, eax, 4) ; array[index] = ecx
```   

最后目标代码优化器对上述的目标代码进行优化，比如选择合适的寻址方式、使用位移来代替乘法
运算、删除多余的指令等。      

经过上述步骤后，源代码终于被编译成了目标代码。但是这个目标代码有一个问题：index 和 array
的地址还没有确定。如果 index 和 array 定义在在跟上面的源代码同一个编译单元里面，那么编译器
可以为 index 和 array 分配空间，确定他们的地址；那如果是定义在其他的程序模块呢。    

事实上，定义在其他模块的全局变量和函数在最终运行时的绝对地址都要在最终链接的时候才能确定。
所以现代的编译器可以将一个源代码文件编译成一个未链接的目标文件，然后由链接器最终将这些
目标文件链接起来形成可执行文件。     

## 2.3 链接

在一个程序被分割成多个模块之后，这些模块之间最后如何组合形成单一的程序是必须解决的问题。
模块之间如何组合的问题可以归结为模块之间如何通信的问题，最常见的属于静态语言的 C/C++ 模块
之间通信有两种方式，一种是模块间的函数调用，另外一种是模块间的变量访问。函数调用须知道目标
函数的地址，变量访问也须知道目标变量的地址，所以这两种方式都可以归结为一种方式，那就是模块间的符号引用。模块间依靠符号来通信类似与拼图版，定义符号的模块多出一块区域，引用该符号的模块刚好少了
那一块区域，两者一起拼接刚好完美组合。这个模块的拼接过程就是 **链接**。    

## 2.4 模块拼装——静态链接

链接的主要内容就是把各个模块之间相互引用的部分都处理好，使得各个模块之间能够正确地衔接。
从原理上来讲，它的工作无非就是用一些指令对其他符号地址的引用加以修正。链接过程主要包括了
**地址和空间分配**、**符号决议**(Symbol Resolution) 和 **重定位** 等这些步骤。
注意这点的重定位和我们之前内存管理中重定位是不一样的，这里的重定位是指需要把应用的外部
函数和变量的地址在链接时修改成真正的地址。

![2-4](https://raw.githubusercontent.com/temple-deng/markdown-images/master/program/2-4.png)

最简单的静态文件链接过程如图所示，每个模块的源代码文件经过编译器编译成 **目标文件**，
目标文件和 **库**(Library)一起链接形成最终可执行文件。而最常见的库就是 **运行时库**
(Runtime Library)，它是支持程序运行的基本函数的集合。库其实是一组目标文件的包，就是
一些最常用的代码编译成目标文件后打包存放。


# 第 3 章 目标文件

目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能
有些符号或有些地址还没有被调整。其实它本身就是按照可执行文件格式存储的，只是跟真正的可
执行文件在结构上稍有不同。     

## 3.1 目标文件的格式

现在 PC 平台流行的可执行文件格式主要是 Windows 下的 **PE**（Portable Executable)
和 Linux 的 **ELF**(Executable Linkable Format)，它们都是 COFF(Common file format)
的变种。     

不光是可执行文件按照可执行文件的格式存储。**动态链接库**(DLL, Dynamic Linking Library)
(Windows 的 .dll 和 Linux 的 .so)及 **静态链接库**(Static Linking Library)(Windows
的 .lib 和 Linux 的 .a)文件都按照可执行文件格式存储。     

ELF 文件标准里面把系统中采用 ELF 格式的文件归为如下 4 类：   


ELF 文件类型 | 说明 | 实例
---------|----------|---------
 可重定位文件 Relocatable File | 这类文件包含了代码和数据，可以被用来链接成可执行文件或共享目标文件，静态链接库也可归为这一类 | Linux 的 .o，Windows 的 .obj
 可执行文件 Executable File | 这类文件包含了可以直接执行的程序，它的代表就是 ELF 可执行文件 | 比如 /bin/bash 文件，Windows 的 .exe 文件
 共享目标文件 Shared Object File | 这类文件包含了代码和数据，可以在以上情况下使用，一种是链接器可以使用这种文件跟其他的可重定位文件和共享目标文件链接，产生新的目标文件。第二种是动态链接器可以将这种共享目标文件与可执行文件结合，作为进程映像的一部分来运行 | Linux 的 .so，Windows 的 .dll
 核心转储文件 Core Dump File | 当进程意外终止时，系统可以将该进程的地址空间的内容及终止时的一些其他信息转储到核心转储文件 | Linux 下的 core dump

## 3.2 目标文件是什么样的

目标文件中至少有编译后的机器指令代码、数据，除了这些内容外，目标文件中还包括了链接时所
需要的一些信息，比如符号表、调试信息、字符串等。一般目标文件将这些信息按不同的属性，以
"节 Section" 的形式存储，有时也叫 "段 Segment"。      

程序源代码编译后的机器指令经常被放在 **代码段**(Code Section)里，代码段最常见的名字
有 .code 或 .text；全局变量和局部静态变量数据经常被放在 **数据段**(Data Section)，
数据段的一般名字叫 .data。     

![3-1](https://raw.githubusercontent.com/temple-deng/markdown-images/master/program/3-1.png)

假设图中的目标文件格式是 ELF，从图中可以看到，ELF 文件的开始是一个文件头，它描述整个
文件的文件属性，包括文件是否可执行、是静态链接还是动态链接、目标硬件、目标操作系统等
信息，文件头还包括一个 **段表**(Section Table)，段表其实是一个描述文件中各个段的
数组。段表描述了文件中各个段在文件中的偏移位置及段的属性等，从段表里面可以得到每个段
的所有信息。文件头后面就是各个段的内容。    

对照图来看，一般 C 语言的编译后执行语句都编译成机器代码，保存在 .text 段；已初始化
的全局变量和局部静态变量都保存在 .data 段；未初始化的全局变量和局部静态变量一般放在
一个叫 .bss 的段里。我们知道未初始化的全局变量和局部静态变量默认值都为 0 ，本来它们
也可以被放在 .data 段的，但是因为它们都是 0，所以为它们在 .data 段分配空间并且存放
数据 0 是没有必要的。程序运行的时候它们的确是要占内存空间的，并且可执行文件必须记录
所有未初始化的全局变量和局部静态变量的大小综合，记为 .bss 段。所以 .bss 段只是
为未出世的全局变量和局部静态变量预留位置而已，它并没有内容，所以它在文件中也不占据
空间。     

## 3.3 挖掘 simple.o

```c
int printf(const char* format, ...);

int global_init_var = 84;
int global_uninit_var;

void func1(int i) {
  printf("%d\n", i);
}

int main(void) {
  static int static_var = 85;
  static int static_var2;

  int a = 1;
  int b;

  func1(static_var + static_var2 + a + b);
  return a;
}
```   

使用 GCC 来编译这个文件（参数 -c 表示只编译不连接）：    

`$ gcc -c simple.c`     

我们可以使用 objdump 来查看 object 内部的结构：    

`$ objdump -h simple.o`    

参数 -h 把文件的各个段的基本信息打印出来，从上面的结果来看，simple.o 的段数量比我们
想象中的要多，除了最基本的代码段、数据段和 BSS 段以外，还有 3 个段（这里 eh_frame 书
上的例子中并没有）分别是 **只读数据段**(.rodata)、**注释信息段**(.comment)和
**堆栈提示段**(.note_GNU-stack)。     

![3-2](https://raw.githubusercontent.com/temple-deng/markdown-images/master/program/3-2.png)

先来看看几个重要的段的属性，最容易理解是段的长度 size 和段所在的位置 file offset。每个
段的第 2 行中的 "CONTENTS, ALLOC" 等表示段的各种属性。CONTENTS 表示该段在文件中
存在，我们可以看到 BSS 没有 CONTENTS。    

有一个专门的 size 命令，它可以用来查看 ELF 文件的代码段、数据段和 BSS 段的长度。     

### 3.3.1 代码段

`objdump` 的 -s 参数可以将所有段的内容以十六进制的方式打印出来，-d 参数可以将所有包含
指令的段反汇编。     

![3-3](https://raw.githubusercontent.com/temple-deng/markdown-images/master/program/3-3.png)

### 3.3.2 数据段和只读数据段

.data 段保存的是那些已经初始化了的全局静态变量和局部静态变量。代码中一个两个这样的变量
每个 4 字节，一共 8 个字节，所以 .data 段大小为 8 字节。    

代码中我们调用 printf 的时候，用到一个字符串常量 "%d\n"，它是一种只读数据，所以被放到了
.rodata 段。.rodata 段存放的是只读数据，一般是程序里面的只读变量和字符串常量。     

### 3.3.3 BSS 段

.bss 段存放的是未初始化的全局变量和局部变态的变量，如上述代码中 global_uninit_var 和
static_var2 就是被存放在 .bss 段，其实更准确的说法是 .bss 为它们预留了空间。但是我们
可以看到该段的大小只有 4 个字节，这与两个变量的大小 8 个字节不符。    

其实我们可以通过符号表看到，只有 static_var2 被存放在了 .bss 段，而 global_uninit_var
却没有被存放在任何段，只是一个未定义的  "COMMON" 符号。这其实是跟不同的语言与不同的编译器
实现有关，有些编译器会将全局的未初始化变量存放在目标文件 .bss 段，有些则不存放，只是预留
一个未定义的全局变量符号，等到最终链接成可执行文件的时候再在 .bss 段分配文件。     

### 3.3.4 其他段

除了 .text, .data, .bss 这 3 个最常用的段之外， ELF 文件也有可能包含有其他的段，用来
保存与程序相关的其他信息。    


常用的段名 | 说明 
----------|---------
 .rodata | Read Only Data，存放只读数据，比如字符串常量，全局 const 常量
 .comment | 存放的是编译器版本信息 
 .debug | 调试信息 
 .dynamic | 动态链接信息
 .hash | 符号哈希表
 .line | 调试时的行号表，即源代码行号与编译后指令的对应表
 .note | 额外的编译器信息
 .strtab | String Table 字符串表，用于存储 ELF 文件中用到的各种字符串
 .symtab | Symbol Table 符号表
 .shstrtab | Section String  Table 段名表
 .plt, got | 动态链接的跳转表和全局入口表
 .init, .fini | 程序初始化与终结代码段    

这些段的名字都是由 . 作为前缀，表示这些表的名字是系统保留的，应用程序也可以使用一些非系统
保留的名字作为段名。但是应用程序自定义的段名不能使用 , 作为前缀。    

## 3.4 ELF 文件结构描述

下图是 ELF 目标文件的总体结构，省去了一些繁琐的结构。    

![3-4](https://raw.githubusercontent.com/temple-deng/markdown-images/master/program/3-4.png)

ELF 目标文件格式的最前部是 ELF 文件头，它包含了描述整个文件的基本属性，比如 ELF 文件版本、
目标机器型号、程序入口地址等。紧接着时 ELF 文件各个段。其中 ELF 文件中与段有关的重要结构
就是 **段表**，该表描述了 ELF 文件包含的所有段的信息，比如每个段的段名、段的长度、在文件
中的偏移、读写权限及段的其他属性。    

### 3.4.1 文件头

我们可以使用 `readelf` 命令来详细查看 ELF 文件。  

![3-5](https://raw.githubusercontent.com/temple-deng/markdown-images/master/program/3-5.png)

从上面的结果可以看到，ELF 的文件头中定义了 **ELF 魔数**、**文件机器字节长度**、**数据存储方式**、
**版本**、**运行平台**、**ABI版本**、**ELF重定位类型**、**硬件平台**、**硬件平台版本**、
**入口地址**、**程序头入口和长度**、**段表的位置和长度**及 **段的数量**。      


字段 | 含义 
---------|----------
 Version| ELF 版本号，一般为 1
 Entry point address | 入口地址，规定 ELF 程序的入口虚拟地址，操作系统在加载完程序后从这个地址开始执行进程的指令。可重定位文件一般没有入口地址，则这个值为0
 Start of section headers | 段表在文件中的偏移
 Size of section headers | 段表描述符的大小
 section header string table index | 段表字符串所在的段在段表中的下标

16 个字节的魔数被 ELF 标准规定用来标识 ELF 文件的平台属性，比如字节序、ELF 文件版本等。    

```
7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
```   

最开始的 4 个字节是所有 ELF 文件都必须相同的标识码，分别为 7f, 45, 4c, 46。这种魔数用来
确认文件的类型，操作系统在加载可执行文件的时候会确认魔数是否正确，如果不正确会拒绝加载。    

接下来的一个字节是用来标识 ELF 的文件类的，01 表示 32 位，02 表示 64 位，第 6 个字节是
字节序。第 7 个字节规定 ELF 文件的主版本号。后面的 9 个字节 ELF 标准没有定义，一般填 0.     

### 3.4.2 段表

段表是保存 ELF 文件中各个段的基本属性的结构。编译器、链接器和装载器都是依靠段表来定位
和访问各个段的属性的。    

`objdump -h` 命令只是把 ELF 文件中关键的段显示了出来，而省略了其他的辅助性的段，比如：
符号表、字符串表、段名字符串表、重定位表等。我们可以使用 readelf 工具来查看 ELF 文件的段，
它显示出来的结果才是真正的段表结构：   

![3-6](https://raw.githubusercontent.com/temple-deng/markdown-images/master/program/3-6.png)

ELF 段表的这个数组的第一个元素是无效的段描述符，其类型是 NULL。   


字段 | 解释  
---------|----------
 Name | 段名，段名是一个字符串，它位于一个叫做 .shstrtab 的字符串表
 Type | 段的类型
 Flags | 段的标志位
 Address | 段虚拟地址，如果该段可以被加载，则这个字段为该段被加载后在进程地址空间的中的虚拟地址，否则为0
 Offset | 段偏移，如果该段存在与文件中，则表示该段在文件中的偏移；否则无意义
 Size | 段的长度
 Link 和 Info | 段链接信息
 Align | 段地址对齐
 EntSize | 项的长度，一些段包含了一些固定大小的项，比如符号表，对于这种段，表示每个项的大小，如果为 0，则表示该段不包含固定大小的项

段的类型：    


常量 | 值 | 含义
---------|----------|---------
 NULL | 0 | 无效段
 PROGBITS | 1 | 代码段、数据段
 SYMTAB | 2 | 符号表
 STRTAB | 3 | 字符串表
 RELA | 4 | 重定位表
 HASH | 5 | 符号表的哈希表
 DYNAMIC | 6 | 动态链接信息
 NOTE | 7 | 提示性信息
 NOBITS | 8 | 表示该段在文件中没内容，比如 .bss 段
 REL | 9 | 该段包含了重定位信息
 SHLIB | 10 | 保留
 DNYSYM | 11 | 动态链接符号表

### 3.4.3 重定位表

有一个叫 .rela.text 的段，其段类型为 RELA，即一个 **重定位表**。链接器在处理目标文件时，
需要对目标文件中的某些部位进行重定位，即代码段和数据段中那些对绝对地址的引用的位置。这些
重定位信息都记录在 ELF 文件的重定位表里面，对于每个要重定位的代码段或数据段，都有一个
相应的重定位表。例如 .rela.text 是 text 段的重定位表，因为 text 段中包含一个绝对地址的
引用，即对 printf 函数的调用；而 data 段中没有对绝对地址的引用，所以没有 .rela.data。    

### 3.4.4 字符串表

ELF 文件中用到了很多字符串，比如段名、变量名等，因为字符串的长度往往是不定的，所以用固定
的结构来表示它比较困难。一般常见的做法是把字符串集中起来存放到一个表，然后用字符串在表中
的偏移来引用字符串。    

一般字符串表在 ELF 文件中也以段的形式保存，常见的段名为 strtab 和 shstrtab，这两个字符串
表分别为字符串表和段表字符串表。字符串表用来保存普通的字符串，比如符号的名字，段表字符串
表用来保存段表中用到的字符串，最常见的就是段名。     

## 3.5 链接的接口 —— 符号

在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。
比如目标文件 B 用到了目标文件 A 中的函数 foo，那么我们就称目标文件 A 定义了函数 foo，称
目标文件 B 引用了函数 foo。这两个概念同样也适用于变量。每个函数或变量都有自己独特的名字，
才能避免链接过程中不同函数和变量之间的混淆。在链接中，我们将函数和变量统称为 **符号**，
函数名或变量名就是 **符号名**。    

符号表里记录了目标文件所用到的所有符号，每个定义的符号有一个定义的值，叫做符号值，对于变量
和函数来说，符号值就是他们的地址。除了函数和变量之外，还有几种不常用到的符号。我们将符号表
中所有的符号进行分类，它们有可能是下面这些类型中的一种：   

+ 定义在本目标文件的全局符号，可以被其他目标文件引用。比如 simple.o 里面的 func1, main 和
global_init_var
+ 在本目标文件中引用的全局符号，却没有定义在本目标文件，这一般叫做 **外部符号**，也就是
我们前面所讲的符号引用。
+ 段名，这种符号往往由编译器产生，它的值就是该段的起始地址。但是段名不是在字符串表中吗？
+ 局部符号，这类符号只在编译单元内部可见，比如 static_var 和 static_var2
+ 行号信息，即目标文件指令与源代码中代码行的对应关系，它是可选的。

![3-7](https://raw.githubusercontent.com/temple-deng/markdown-images/master/program/3-7.png)   

### 3.5.1 ELF 符号表结构

符号表的结构很简单，它是一个 Elf64_Sym 结构的数组，每个 Elf64_Sym 结构对应一个符号。这个
数组的第一个元素，也就是下标为 0 的元素为无效的未定义符号，Elf64_Sym 结构定义如下：   

```c
typedef struct {
  Elf64_Word st_name;
  Elf64_Addr st_value;
  Elf64_Word st_size;
  unsigned char st_info;
  unsigned char st_other;
  Elf64_Half st_shndx;
} Elf64_Sym;
```    


字段 | 解释
---------|----------
 st_name | 符号名，这个字段包含了该符号名在字符串表中的下标，也就说其实 ELF 中乱七八糟的各种名字最终都指向了字符串表，原结构中只是一个偏移量
 st_value | 符号对应的值，这个值跟符号有关，可能是一个绝对值，也可能是一个地址等
 st_size | 符号大小，对于包含数据的符号，这个值是该数据类型的大小，比如一个 double 型的符号它占用 8 个字节，如果为0，代表符号大小为0或未知
 st_info | 符号类型和绑定信息
 st_other | 保留
 st_shndx | 符号所在段

**符号类型和绑定信息**，该成员低 3 位表示符号的类型，高 28 位表示符号的绑定信息。    

符号绑定信息

宏定义名 | 值 | 说明
---------|----------|---------
 STB_LOCAL | 0 | 局部符号，对于目标文件的外部不可见
 STB_GLOBAL | 1 | 全局符号，外部可见
 STB_WEAK | 2 | 弱引用

符号类型：    

宏定义名 | 值 | 说明
---------|----------|---------
 STT_NOTYPE | 0 | 未知类型符号
 STT_OBJECT | 1 | 该符号是个数据对象，比如变量、数组等
 STT_FUNC | 2 | 该符号是个函数或其他可执行代码
 STT_SECTION | 3 | 该符号表示一个段，这种符号必须是 STB_LOCAL 的
 STT_FILE | 4 | 该符号表示文件名，一般都是该目标文件所对应的源文件名

符号所在段(st_shndx)，如果符号定义在本目标文件中，那么这个成员表示符号所在的段在段
表中的下标。如果符号不是定义在本目标文件中，或者对于某些特殊符号，st_shndx 的值有些特殊：   

宏定义名 | 值 | 说明
---------|----------|---------
 SHN_ABS | 0xfff1 | 表示该符号包含了一个绝对的值，比如表示文件名的符号就属于这种类型
 SHN_COMMON | 0xfff2 | 表示该符号是一个 COMMON 块类型的符号，一般来说，未初始化的全局符号定义就是这种类型
 SHN_UNDEF | 0 | 表示该符号未定义，这个符号表示该符号在本目标文件被引用到，但是定义在其他目标文件中    

符号值，如果这个符号是一个函数或变量的定义，那么符号的值就是这个函数或变量的地址，更准确
的讲应该按下面这几种情况区别对待：   

+ 在目标文件中，如果是符号的定义，且不是 COMMON 块类型，则 st_value 表示该符号在段中的
偏移。
+ 在目标文件中，如果符号是 COMMON 类型，则 st_value 表示该符号的对齐属性
+ 在可执行文件中，st_value 表示符号的虚拟地址     

现在我们根据 simple.o 的符号表来解释一下：   

+ func1 和 main 函数都定义在源文件中，它们所在的位置都是代码段，所以 Ndx 为1，它们是函数，
所以类型是 FUNC,它们是全局可见的，所以是 GLOBAL，size 表示函数指令所占的字节数；value 表示
函数相对于代码段起始位置的偏移量。main 的偏移量 22 正好是 func1 的长度 34
+ global_init_var 是以初始化的全局变量，它被定义在 .data 段
+ global_uninit_var 是未初始化的全局变量，它是一个 SHN_COMMON 类型符号，它本身并没有存在
于 .bss 段中。    

# 第 4 章 静态链接

## 4.1 空间与地址分配

对于链接器来说，整个链接过程中，它就是将几个输入目标文件加工后合并成一个输出文件。我们知道，
可执行文件中的代码段和数据段都是由输入的目标文件中合并而来的。那么链接过程的第一个问题就是，
对于多个输入目标文件，如何将各个段合并到输出文件。    

### 4.1.1 按序叠加

最简单的方案，就是将输入的目标文件按照次序叠加起来。这样做的问题是，输出文件会有很多
零散段（因为段之间并没有合并嘛），这就很浪费空间了。    

### 4.1.2 相似段合并

链接器在合并各个段的同时，也将 .bss 合并，并且分配虚拟空间。    

链接器为目标文件分配地址和空间，这句话中的地址和空间有两个含义：第一个是在输出的可执行文件中的
空间；第二个是在装载后的虚拟地址中的虚拟地址空间。对于有实际数据的段，比如 .text 和 .data 来说，
它们在文件中和虚拟地址中都要分配空间，因为它们在这两者中都存在；而对于 .bss 这样的段来说，分配
空间的意义只局限于虚拟地址空间，因为它装载文件中并没有内容。事实上，我们这里谈到的空间分配只
关注于虚拟地址空间的分配。    

现在的链接器空间分配的策略基本上都采用上述方法中的第二种，使用这种方法的链接器一般都采用一种叫
**两步链接**的方法。    

第一步，空间与地址分配，扫描所有的输入目标文件，并且获得它们各个段的长度、属性和位置，并且将输入
目标文件中的符号表中的所有的符号定义和符号引用收集起来，统一放到一个全局符号表。这一步中，链接器
将能够获得所有输入目标文件的段长度，并且将它们合并，计算出输出文件中各个段合并后的长度和位置，
并建立映射关系。   

第二步，符号解析与重定位，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码
中的地址等。     

### 4.1.3 符号地址的确定

在第一步的扫描和空间分配阶段，链接器按照前面介绍的空间分配方法进行分配，这时候输入文件中的各个段在链接后的虚拟地址就已经确定了，比如 .text 段起始地址为 0x09048094, .data 段的起始地址为 0x08049108。    

当前面一步完成以后，链接器开始计算各个符号的虚拟地址。因为各个符号在段内的相对位置是固定的。    

## 4.2 符号解析与重定位

### 4.2.1 重定位

```
18: c7 44 24 04 00 00 00 00  movl $0x0, 0x4(%esp)

26: e8 fc ff ff ff      call 27 <main+0x27>
2b: 83 c4 24            add %0x24, %esp
```    

对于 shared 的引用是一条 mov 指令，这条指令总共 8 个字节，它的作用是将 shared 的地址赋值到
ESP 寄存器 + 4 的偏移地址中区，前面 4 个字节是指令码，后面 4 个字节是 shared 的地址，由于在
编译目标文件时，编译器并不知道 shared 和 swap 的地址，所以暂时把地址 0 看作是 shared 的地址。   

对 swap 调用的指令，这条指令共 5 个字节，前面的 e8 是操作码，这时一条近址相对位移调用指令，
后面的 4 个字节就是被调用函数的相对于 **调用指令的下一条指令的偏移量**。在没有重定位之前，相对
位移被置为 0xfffffffc，他是常量 -4 的补码形式。    

紧跟在这条 CALL 指令后面的那条指令为 add 指令，add指令的地址为 0x2b，而相对于 add 指令为 -4
的地址即 0x2b - 4 = 0x27。所以这条 CALL 指令的实际调用地址为 0x27。    

### 4.2.2 重定位表

我们可以使用 objdump 来查看目标文件的重定位表：   

```
$ objdump -r a.o

a.o:      file format elf32-i386

RELOCATION RECORDS FOR [.text]:
OFFSET      TYPE      VALUE
0000001c   R_386_32   shared
00000027   R_386_PC32  swap
```    

这个命令可以用来查看 a.o 里面要重定位的地方，即 a.o 所有引用到外部符号的地址。每个要被重定位
的地方叫一个 **重定位入口**，我们可以看到 a.o 里面有两个重定位入口。重定位入口的偏移表示该入口
在要被重定位的段中的位置。这里的 0x1c 和 0x27 分别就是代码段中 mov 指令和 call 指令的地址部分。   

### 4.2.4 指令修正方式

IA-32 架构下 ELF 文件的重定位入口所修正的指令寻址方式只有两种：   

+ 绝对近址 32 位寻址
+ 相对近址 32 位寻址     


宏定义 | 值 | 重定位修正方法
---------|----------|---------
 R_386_32 | 1 | 绝对寻址修正 S + A
 R_386_PC32 | 2 | 相对寻址修正 S + A - P     

+ A = 保存在被修正位置的值
+ P = 被修正的位置（相对于段开始的偏移量或者虚拟地址）
+ S = 符号的实际地址

## 4.4 静态库链接

一个静态库可以简单地看成是一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件。    

# 第 6 章 可执行文件的装载与进程

## 6.3 从操作系统角度看可执行文件的装载

### 6.3.1 进程的建立

创建一个进程，然后装载相应的可执行文件并且执行。在有虚拟内存的情况下，上述过程最开始只需要做
三件事情：    

+ 创建一个独立的虚拟地址空间
+ 读取可执行文件头，并且建立虚拟地址空间与可执行文件的映射关系
+ 将 CPU 的指令寄存器设置成可执行文件的入口地址，启动运行     

# 第 7 章 动态链接

## 7.1 为什么要动态链接

空间浪费是静态链接的一个问题，另一个问题是静态链接对程序的更新、部署和发布也会带来很多麻烦。      

动态链接的基本思想是把程序按照模块拆分成各个相对独立的部分，在程序运行时才将它们链接在一起形成
一个完整的程序，而不是像静态链接一样把所有的程序模块都链接成一个单独的可执行文件。    

目前主流的操作系统几乎都支持动态链接，在 Linux 中，ELF 动态链接文件被称为动态共享对象(DSO, Dynamic
Shared Objects)，它们一般都是以 .so 为扩展名的一些文件；Windows 中，动态链接称为动态链接库
(Dynamical Linking Library)。    

## 7.2 简单的动态链接例子

```c
// p1.c
#include "Lib.h"

int main() {
  foobar(1);
  return 0;
}
```   

```c
// p2.c
#include "Lib.h"

int main() {
  foobar(2);
  return 0;
}
```

```c
// Lib.c
#include <stdio.h>

void foobar(int i) {
  printf("Printing from Lib.so %d\n", i);
}
```    

```c
// lib.h
#ifndef LIB_H
#define LIB_H

void foobar(int i);

#endif
```    

使用 GCC 将 Lib.c 编译成一个共享对象文件：   

`$ gcc -fPIC -shared -o Lib.so Lib.c`     

然后分别编译链接 p1.c 和 p2.c:   

```
$ gcc -o p1 p1.c ./Lib.so
$ gcc -o p2 p2.c ./Lib.so
```   

在 p1.o 链接形成可执行文件这一步时，如果是静态链接，这一步会把 p1.o 和 Lib.o 链接到一起，
产生可执行文件 p1。但是在这里，Lib.o 没有被链接进来，链接的输入目标文件只有 p1.o。     

当链接器将 p1.o 链接成可执行文件时，这时候链接器必须确定 p1.o 中所引用的 foobar() 函数
的性质。如果 foobar() 是一个定义在其他静态目标模块中的函数，那么链接器将会按照静态链接的
规则，将 p1.p 中的 foobar 地址引用重定位；如果 foobar() 是一个定义在某个动态共享对象
中的函数，那么链接器会将这个符号的引用标记为一个动态链接的符号，不对他进行地址重定位，
把这个过程留到装载时再进行。    

对于静态链接的可执行文件来说，整个进程只有一个文件要被映射，那就是可执行文件本身。但是对于
动态链接来说，除了可执行文件本身之外，还有他所依赖的共享目标文件。      

动态链接器与普通共享对象一样被映射到了进程的地址空间，在系统开始运行 p1 之前，首先会把
控制权交给动态链接器，由它完成所有的动态链接工作以后再把控制权交给 p1,然后开始执行。    

# 第 10 章 内存

## 10.3 堆与内存管理

相对于栈而言，堆这片内存面临一个稍微复杂的行为模式：在任意时刻，程序可能发出请求，要么
申请一段内存，要么释放一段已申请过的内存，而且申请的大小从几个字节到数 G 都是有可能的。    

### 10.3.1 什么是堆

光有栈对于面向过程的程序设计还远远不够，因为栈上的数据在函数返回的时候就会被释放掉，所以
无法将数据传递至函数外部。而全局变量没有办法动态地产生，只能在编译的时候定义，有很多情况
下缺乏表现力。在这种情况下，堆是唯一的选择。   

堆是一块巨大的内存空间，常常占据整个虚拟空间的绝大部分。在这片空间里，程序可以请求一块
连续内存，并自由地使用，这块内存在程序主动放弃之前都会一直保持有效。