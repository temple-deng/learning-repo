# 第 3 章 文件 IO

<!-- TOC -->

- [第 3 章 文件 IO](#第-3-章-文件-io)
  - [3.1 引言](#31-引言)
  - [3.2 文件描述符](#32-文件描述符)
  - [3.3 函数 open 和 openat](#33-函数-open-和-openat)
  - [3.4 函数 creat](#34-函数-creat)
  - [3.5 函数 close](#35-函数-close)
  - [3.6 函数 lseek](#36-函数-lseek)
  - [3.7 函数 read](#37-函数-read)
  - [3.8 函数 write](#38-函数-write)
  - [3.9 IO 的效率](#39-io-的效率)
  - [3.10 文件共享](#310-文件共享)
  - [3.11 原子操作](#311-原子操作)
  - [3.12 函数 dup 和 dup2](#312-函数-dup-和-dup2)
  - [3.13 函数 sync, fsync 和 fdatasync](#313-函数-sync-fsync-和-fdatasync)
  - [3.14 函数 fcntl](#314-函数-fcntl)
  - [3.16 /dev/fd](#316-devfd)

<!-- /TOC -->

## 3.1 引言

UNIX 系统中的大多数文件 IO 只需用到 5 个函数：open, read, write, lseek, close。    

本章描述的函数经常被称为不带缓冲的 IO。术语不带缓冲指的是每个 read 和 write 都调用内核中的一个
系统调用。这些不带缓冲的I/O函数不是ISO C的组成部分，但是，它们是POSIX.1和Single UNIX
Specification的组成部分。    

## 3.2 文件描述符

对于内核而言，所有打开的文件都通过文件描述符引用。文件描述符是一个非负整数。当打开一个现有文件或
创建一个新文件时，内核向进程返回一个文件描述符。当读、写一个文件时，使用 open 或 creat 返回的
文件描述符标识该文件，将其作为参数传送给 read 或 write。    

按照惯例，UNIX系统 shell 把文件描述符0与进程的标准输入关联，文件描述符1与标准输出关联，文件
描述符2与标准错误关联。这是各种 shell以及很多应用程序使用的惯例，与UNIX内核无关。尽管如此，如果
不遵循这种惯例，很多UNIX系统应用程序就不能正常工作。    

在符合POSIX.1的应用程序中，幻数0、1、2虽然已被标准化，但应当把它们替换成符号常量STDIN_FILENO、
STDOUT_FILENO 和 STDERR_FILENO 以提高可读性。这些常量都在头文件 &lt;unistd.h&gt; 中定义。    

文件描述符的变化范围是0~OPEN_MAX-1（进程打开的最大文件数）。早期的UNIX系统实现采用的上限值是
19（允许每个进程最多打开 20 个文件)，但现在很多系统将其上限值增加至63。   

对于FreeBSD 8.0、Linux 3.2.0、Mac OS X 10.6.8以及Solaris 10，文件描述符的变化范围几乎
是无限的，它只受到系统配置的存储器总量、整型的字长以及系统管理员所配置的软限制和硬限制的约束。    

## 3.3 函数 open 和 openat

调用 open 或 openat 函数可以打开或创建一个文件。    

```c
#include <fcntl.h>

int open(const char *path, int oflag, ... /* mode_t mode */);
int openat(int fd, const char *path, int oflag, ... /* mode_t mode */);
```     

两函数的返回值：若成功，返回文件描述符；若出错，返回 -1。    

我们将最后一个参数写为 ...，ISO C 用这种方法表明余下的参数的数量及其类型是可变的。对于 open 函数
而言，仅当创建新文件时才使用最后这个参数。在函数原型中将此参数放置在注释中。   

path 参数是要打开或创建文件的名字。oflag 参数可用来说明此函数的多个选项。用下列一个或多个常量
进行“或”运算构成 oflag 参数（这些常量在头文件 &lt;fcntl.h&gt; 中定义）：   

- O_RDONLY: 只读打开
- O_WRONLY: 只写
- O_RDWR
- O_EXEC: 只执行打开
- O_SEARCH: 只搜索打开（应用于目录）    

在上面的这 5 个常量中必须指定一个且只能指定一个，而下面的这些常量则是可选：   

- O_APPEND: 每次写时都追加到文件的尾端
- O_CLOEXEC: 把 FD_CLOEXEC 常量设置为文件描述符标志
- O_CREAT: 若此文件不存在则创建它。使用此选项时，open 函数需同时说明第3个参数 mode（openat
函数需说明第4个参数mode），用mode指定该新文件的访问权限位
- O_DIRECTORY: 如果 path 引用的不是目录，则出错
- O_EXCL: 如果同时指定了 O_CREAT，而文件已经存在，则出错。用此可以测试一个文件是否存在，如果
不存在，则创建此文件。
- O_NOCTTY: 如果 path 引用的是终端设备，则不将该设备分配作为此进程的控制终端
- O_NOFOLLOW: 如果 path 引用的是一个符号链接，则出错
- O_NONBLOCK: 如果 path 引用的是一个 FIFO、一个块特殊文件或一个字符特殊文件，则此选项为文件的
本次打开操作和后续的 IO 操作设置非阻塞方式
- O_SYNC: 使每次 write 等待物理I/O操作完成，包括由该 write 操作引起的文件属性更新所需的I/O
- O_TRUNC: 如果此文件存在，而且为只写或读-写成功打开，则将其长度截断为 0
- O_TTY_INIT: 如果打开一个还未打开的终端设备，设置非标准 termios 参数值，使其符合 Single
UNIX Specification
- O_DSYNC: 使每次 write 要等待物理 IO 操作完成，但是如果该写操作并不影响读取刚写入的数据，则
不需等待文件属性被更新    
O_DSYNC 和 O_SYNC 标志有微妙的区别。仅当文件属性需要更新以反映文件数据变化（例如，更新文件
大小以反映文件中包含了更多的数据）时，O_DSYNC 标志才影响文件属性。而设置 O_SYNC 标志后，数据
和属性总是同步更新。当文件用 O_DSYNC 标志打开，在重写其现有的部分内容时，文件时间属性不会同步
更新。与此相反，如果文件是用 O_SYNC 标志打开，那么对该文件的每一次 write 都将在 write 返回
前更新文件时间，这与是否改写现有字节或追加写文件无关。  
- O_RSYNC: 使每一个以文件描述符作为参数进行的 read 操作等待，直至所有对文件同一部分挂起的写操作
都完成。    

由 open 和 openat 函数返回的文件描述符一定是最小的未用描述符数值。这一点被某些应用程序用来在
标准输入、标准输出或标准错误上打开新的文件。例如，一个应用程序可以先关闭标准输出，然后打开另一个
文件，执行打开操作前就能了解到该文件一定会在文件描述符 1 上打开。   

fd 参数把 open 和 openat 函数区分开，共有 3 种可能性：   

1. path 参数指定的是绝对路径名，在这种情况下，fd 参数被忽略，openat 函数相当于 open
2. path 参数指定的是相对路径名，fd 参数指出了相对路径名在文件系统中的开始地址。fd 参数是通过
打开相对路径名所在的目录来获取（啥玩意啊）
3. path 参数指定了相对路径名，fd 参数具有特殊值 AT_FDCWD。在这种情况下，路径名在当前工作目录
中获取，openat函数在操作上与open函数类似         

## 3.4 函数 creat

也可调用 creat 函数创建一个新文件。    

```c
#include <fcntl.h>
int creat(const char *path, mode_t mode);
```    

返回值：若成功，返回为只写打开的文件描述符；若出错，返回 -1    

此函数等效于： `open(path, O_WRONLY | O_CREAT | O_TRUNC, mode)`    

## 3.5 函数 close

可调用 close 函数关闭一个打开文件：    

```c
#include <unistd.h>

int close(int fd);
```    

返回值：若成功，返回 0；若出错，返回-1    

关闭文件时会释放该进程加在该文件上的所有记录锁。    

当一个进程终止时，内核自动关闭它所有的打开文件。    

## 3.6 函数 lseek

每个打开文件都有一个与其相关联的“当前文件偏移量”（current file offset）。它通常是一个非负整数，
用以度量从文件开始处计算的字节数。通常，读、写操作都从当前文件偏移量处开始，并使偏移量增加所读写
的字节数。按系统默认的情况，当打开一个文件时，除非指定 O_APPEND 选项，否则该偏移量被设置为0。    

可以调用 lseek 显示地为一个打开文件设置偏移量：   

```c
#include <unistd.h>
off_t lseek(int fd, off_t offset, int whence);
```    

返回值：若成功，返回新的文件偏移量；若出错，返回为 -1。   

对参数offset的解释与参数whence的值有关：  

- 若 whence 是 SEEK_SET，则将该文件的偏移量设置为距文件开始处 offset 个字节
- 若 whence 是 SEEK_CUR，则将该文件的偏移量设置为其当前值加 offset，offset 可为正或负
- 若 whence 是 SEEK_END，则将该文件的偏移量设置为文件长度加 offset，offset 可为正为负    

如果文件描述符指向的是一个管道、FIFO 或网络套接字，则 lseek 返回 -1，并将 errno 设置为 ESPIPE。   

3个符号常量SEEK_SET、SEEK_CUR和SEEK_END是在System V中引入的。在System V之前，whence 被
指定为 0（绝对偏移量）、1（相对于当前位置的偏移量）或 2（相对文件尾端的偏移量）。很多软件仍然
把这些数字直接写在代码里。    

在 lseek 中的字符 l 表示长整型。在引入 off_t 数据类型之前，offset 参数和返回值是长整型的。
lseek是在UNIX V7中引入的，当时C语言中增加了长整型。    

下面的例子测试 stdin 能否被设置偏移量：   

```c
#include <stdio.h>
#include <unistd.h>

int main(void) {
  if (lseek(STDIN_FILENO, 0, SEEK_CUR) == -1) {
    printf("cannot seek\n");
  } else {
    printf("seek OK\n");
  }

  return 0;
}
```    

如果用交互方式调用此程序：   

```bash
$ ./3-1.lseek < ./3-1.lseek.c
seek OK
```    

通常，文件的当前偏移量应当是一个非负整数，但是，某些设备也可能允许负的偏移量。但对于普通文件，
其偏移量必须是非负值。因为偏移量可能是负值，所以在比较 lseek 的返回值时应当谨慎，不要测试它是否
小于0，而要测试它是否等于−1。    

lseek 仅将当前的文件偏移量记录在内核中，它并不引起任何I/O操作。然后，该偏移量用于下一个读或写
操作。    

文件偏移量可以大于文件的当前长度，在这种情况下，对该文件的下一次写将加长该文件，并在文件中构成
一个空洞，这一点是允许的。位于文件中但没有写过的字节都被读为0。   

文件中的空洞并不要求在磁盘上占用存储区。具体处理方式与文件系统的实现有关，当定位到超出文件尾端
之后写时，对于新写的数据需要分配磁盘块，但是对于原文件尾端和新开始写位置之间的部分则不需要分配
磁盘块。   

```c
#include <fcntl.h>
#include "apue.h"

char buf1[] = "abcdefghij";
char buf2[] = "ABCDEFGHIJ";

int main(void) {
  int fd;

  if ((fd = creat("file.hole", FILE_MODE)) < 0) {
    err_sys("creat error");
  }

  if (write(fd, buf1, 10) != 10) {
    err_sys("buf1 write error");
  }

  if (lseek(fd, 16384, SEEK_SET) == -1) {
    err_sys("lseek error");
  }

  if (write(fd, buf2, 10) != 0) {
    err_sys("buf2 write error");
  }

  exit(0);
}
```   

## 3.7 函数 read

调用 read 函数从打开文件中读数据。   

```c
#include <unistd.h>

ssize_t read(int fd, void *buf, size_t nbytes);
```    

返回值：读到的字节数，若已到文件尾，返回 0；若出错，返回 -1。    

有多种情况可使实际读到的字节数少于要求读的字节数：   

- 读普通文件时，在读到要求字节数之前已到达了文件尾端。
- 当从终端设备读时，通常一次最多读一行
- 当从网络读时，网络中的缓冲机制可能造成返回值小于所要求读的字节数
- 当从管道或 FIFO 读时，如若管道包含的字节少于所需的数量，那么 read 将只返回实际可用的字节数
- 当从某些面向记录的设备（如磁带）读时，一次最多返回一个记录
- 当一信号造成中断，而已经读了部分数据量时

## 3.8 函数 write

```c
#include <unistd.h>

ssize_t write(int fd, const void *buf, size_t nbytes);
```    

返回值：若成功，返回已写字节数；若出错，返回 -1。    

## 3.9 IO 的效率

下面的程序只使用 read 和 write 函数复制一个文件：   

```c
#include "apue.h"

#define BUFFSIZE 4096

int main(void) {
  int n;
  char buf[BUFFSIZE];

  while ((n = read(STDIN_FILENO, buf, BUFFSIZE)) > 0) {
    if (write(STDOUT_FILENO, buf, n) != n) {
      err_sys("write error");
    }
  }

  if (n < 0) {
    err_sys("read error");
  }

  return 0;
}
```    

## 3.10 文件共享

UNIX 系统支持在不同进程间共享打开文件。在介绍 dup 函数之前，先要说明这种共享。为此先介绍内核
用于所有I/O的数据结构。    

内核使用 3 种数据结构表示打开文件，它们之间的关系决定了在文件共享方面一个进程对另一个进程可能产生
的影响：    

1. 每个进程在进程表都有一个记录项，记录项中包含一张打开文件描述符表，可将其视为一个矢量（话说，
这里的矢量是值什么，难道就是一个指针外带一些表格信息的数据结构？），每个描述符占用一项。与每个
描述符相关联的是：
  - 文件描述符标志（close_on_exec）
  - 指向一个文件表项的指针
2. 内核为所有打开文件维持一张文件表。每个文件表项包含：
  - 文件状态标志（读、写、添写、同步和非阻塞等）
  - 当前文件偏移量
  - 指向该文件 v 节点表项的指针
3. 每个打开文件（或设备）都有一个 v 节点（v-node）结构。v 节点包含了文件类型和对此文件进行各种
操作函数的指针。对于大多数文件，v节点还包含了该文件的 i 节点。这些信息是在打开文件时从磁盘上读入
内存的，所以，文件的所有相关信息都是随时可用的    

Linux 没有使用 v 节点，而是使用了通用的 i 节点结构。虽然两种实现有所不同，但在概念上， v节点与
i节点是一样的。两者都指向文件系统特有的i节点结构。    

下图展示了一个进程对应的 3 张表之间的关系：   

![file-core-arch](https://raw.githubusercontent.com/temple-deng/markdown-images/master/unix/3-7.file-core-arch.png)   

我们假定第⼀个进程在⽂件描述符3上打开一个⽂件，⽽另⼀个进程在⽂件描述符4上打开该⽂件。打开该⽂件
的每个进程都获得各⾃的⼀个⽂件表项，但对⼀个给定的⽂件只有⼀个v节点表项。之所以每个进程都获得⾃⼰
的⽂件表项，是因为这可以使每个进程都有它⾃⼰的对该⽂件的当前偏移量。    

给出了这些数据结构后，现在对前⾯所述的操作进⼀步说明：   

- 在完成每个 write 后，在文件表项中的当前文件偏移量即增加所写入的字节数。如果这导致当前文件偏移量
超出了当前文件长度，则将 i 节点表项中的当前文件长度设置为当前文件偏移量
- 如果用 O_APPEND 标志打开一个文件，则相应标志也被设置到文件表项的文件状态标志中。每次对这种具有
追加写标志的文件执行写操作时，文件表项中的当前文件偏移量首先会被设置为 i 节点表项中的文件长度。这
就使得每次写入的数据都追加到文件的当前尾端处
- 若一个文件用 lseek 定位到文件当前的尾端，则文件表项中的当前文件偏移量被设置为 i 节点表项中的
当前文件长度
-  lseek 函数只修改文件表项中的当前文件偏移量，不进行任何操作    

可能有多个⽂件描述符项指向同⼀⽂件表项。在3.12节中讨论dup函数时，我们就能看到这⼀点。在fork后
也发⽣同样的情况，此时⽗进程、⼦进程各⾃的每⼀个打开⽂件描述符共享同⼀个⽂件表项。   

## 3.11 原子操作

1. **追加一个文件**    

考虑⼀个进程，它要将数据追加到⼀个⽂件尾端。早期的UNIX系统版本并不⽀持open的O_APPEND选项，所以
程序被编写成下列形式：   

```c
if (lseek(fd, OL, 2) < 0) {
  if (write(fd, buf, 100) != 100) {
    err_sys("lseek error");
    err_sys("write error");
  }
}
```    

对单个进程而言，这段程序能正常工作，但若有多个进程同时使用这种方法将数据追加写到同一文件，则会产生
问题。   

假设两个独立的进程 A,B 都对同一文件进行追加写操作。每个进程都已打开了该文件，但未使用 O_APPEND
标志。此时，各数据结构的之间的关系如图所示。每个进程都有它自己的文件表项，但是共享一个 v 节点选项。
假定进程 A 调用了 lseek，它将进程 A 的该文件当前偏移量设置为 1500 字节（当前文件尾端处）。然后
内核切换进程。进程 B 执行 lseek，也将其对该文件的当前偏移量设置为 1500。然后 B 调用 write，它
B 的该文件当前文件偏移量增加至 1600。然后，内核又进行了进程切换，使进程 A 恢复运行。当 A 调用
write 时，就从其当前文件偏移量1500处开始讲数据写入到文件。这样也就覆盖了进程 B 刚才写入到该文件
中的数据。   

![atomic-open](https://raw.githubusercontent.com/temple-deng/markdown-images/master/unix/3-8.png)    

问题出在逻辑操作“先定位到⽂件尾端，然后写”，它使⽤了两个分开的函数调⽤。解决问题的⽅法是使这两个
操作对于其他进程⽽⾔成为⼀个原⼦操作。任何要求多于⼀个函数调⽤的操作都不是原⼦操作，因为在两个
函数调⽤之间，内核有可能会临时挂起进程。    

UNIX系统为这样的操作提供了⼀种原⼦操作⽅法，即在打开⽂件时设置 O_APPEND 标志。正如前⼀节中所述，
这样做使得内核在每次写操作之前，都将进程的当前偏移量设置到该⽂件的尾端处，于是在每次写之前就不再
需要调⽤lseek。   

2. **创建一个文件**    

对 open 函数的 O_CREAT 和 O_EXCL 选项进⾏说明时，我们已见到另⼀个有关原⼦操作的例⼦。当同时
指定这两个选项，⽽该⽂件又已经存在时，open 将失败。我们曾提及检查⽂件是否存在和创建⽂件这两个操
作是作为⼀个原⼦操作执⾏的。如果没有这样⼀个原⼦操作，那么可能会编写下列程序段：   

```c
if ((fd = open(pathname, O_WRONLY)) < 0) {
  if (errno == ENOENT) {
    if ((fd = creat(path, mode)) < 0) {
      err_sys("creat error");
    } else {
      err_sys("open error");
    }
  }
}
```    

如果在 open 和 creat 之间，另⼀个进程创建了该⽂件，就会出现问题。若在这两个函数调⽤之间，另⼀个
进程创建了该⽂件，并且写⼊了⼀些数据，然后，原先进程执⾏这段程序中的 creat，这时，刚由另⼀进程
写⼊的数据就会被擦去。如若将这两者合并在⼀个原⼦操作中，这种问题也就不会出现。    

## 3.12 函数 dup 和 dup2

下面两个函数都可用来复制一个现有的文件描述符：   

```c
#include <unistd.h>

int dup(int fd);

int dup2(int fd, int fd2);
```    

两函数的返回值：若成功，返回新的文件描述符；若出错，返回 -1 值。    

由 dup 返回的新文件描述符一定是当前可用文件描述符中的最小值（那这个意思，文件描述符不仅仅是一个
整数，还和很多其他东西关联着，这个数字反而不是特别的重要？复制的过程，文件描述符代表的数字会被
变动？）。对于 dup2，可以用 fd2 参数指定新描述符的值。如果 fd2 已经打开，则先将其关闭。如若
fd 等于 fd2，则 dup2 返回 fd2，而不关闭它。    

这些函数返回的新文件描述符与参数 fd 共享同一个文件表项。    

![dup1](https://raw.githubusercontent.com/temple-deng/markdown-images/master/unix/3-9.png)    

复制一个描述符的另一种方法是使用 fcntl 函数，实际上，调用：   

```c
dup(fd);
```   

等效于：   

```c
fcntl(fd, F_DUPFD, 0);
```    

而调用:   

```c
dup2(fd, fd2);
```    

等效于：    

```c
close(fd2);
fcntl(fd, F_DUPFD, fd2);
```    

## 3.13 函数 sync, fsync 和 fdatasync

传统的 UNIX 系统实现在内核中设有缓冲区高速缓存或页高速缓存，大多数磁盘 IO 都通过缓冲区进行。
当我们向文件写入数据时，内核通常先将数据复制到缓冲区中，然后排入队列，晚些时候再写入磁盘。这种
方式呗称为 **延迟写**（delayed write）。    

通常，当内核需要重用缓冲区来存放其他磁盘块数据时，它会把所有延迟写数据块写入磁盘。为了保证磁盘上
实际文件系统与缓冲区内容的一致性，UNIX 系统提供了额 sync, fsync, fdatasync 三个函数。   

```c
#include <unistd.h>

int fsync(int fd);
int fdatasync(int fd);

// 返回值：若成功，返回 0，若出错，返回 -1

void sync(void);
```    

sync 只是将所有修改过的块缓冲区排入写队列，然后就返回，它并等待实际写磁盘操作结束。   

通常，称为 update 的系统守护进程周期性地调用（一般每隔 30 秒）sync 函数。这就保证了定期冲洗
（flush）内核的块缓冲区。命令 sync(1) 也调用 sync。那其实也就是说，一般调用了 sync 命令后，
我们还应该等待一段时间，等待真正的写操作完成。   

fsync 函数只对由文件描述符 fd 指定的一个文件起作用，并且等待写磁盘操作结束才返回。fsync 可用于
数据库这样的应用程序。    

fdatasync 函数类似于 fsync，但它只影响文件的数据部分。而除数据外，fsync 还会同步更新文件的属性。   

## 3.14 函数 fcntl

fcntl 函数可以改变已经打开文件的属性：   

```c
#include <fcntl.h>

int fnctl(int fd, int cmd, ... /* int arg */);
```    

返回值：若成功，则依赖 cmd；若出错，返回 -1。    

fcntl 函数有以下 5 种功能：   

1. 复制一个已有的描述符（cmd=F_DUPFD 或 F_DUPFD_CLOEXEC）
2. 获取/设置文件描述符标志（cmd=F_GETFD 或 F_SETFD）
3. 获取/设置文件状态标志（cmd=F_GETFL 或 F_SETFL）
4. 获取/设置异步 IO 所有权（cmd=F_GETOWN 或 F_SETOWN）
5. 获取/设置记录锁（cmd=F_GETLK, F_SETLK, F_SETLKW）    

- F_DUPFD: 复制⽂件描述符fd。新⽂件描述符作为函数值返回。它是尚未打开的各描述符中⼤于或等于
第3个参数值（取为整型值）中各值的最⼩值。新描述符与 fd 共享同⼀⽂件表项。但是，新描述符有它⾃⼰
的⼀套⽂件描述符标志，其 FD_CLOEXEC ⽂件描述符标志被清除。
- F_DUPFD_CLOEXEC: 复制⽂件描述符，设置与新描述符关联的 FD_CLOEXEC ⽂件描述符标志的值，返
回新⽂件描述符。
- F_GETFD: 对应于 fd 的⽂件描述符标志作为函数值返回。当前只定义了⼀个⽂件描述符标志FD_CLOEXEC
- F_SETFD: 对于fd设置⽂件描述符标志。新标志值按第3个参数（取为整型值）设置。
- F_GETFL: 对应于fd的⽂件状态标志作为函数值返回。我们在说明open函数时，已描述了⽂件状态标志。 
- F_SETFL: 将⽂件状态标志设置为第3个参数的值（取为整型值）。可以更改的⼏个标志是：O_APPEND、
O_NONBLOCK、O_SYNC、O_DSYNC、O_RSYNC、O_FSYNC和O_ASYNC。
- F_GETOWN: 获取当前接收SIGIO和SIGURG信号的进程ID或进程组ID。 
- F_SETOWN: 设置接收SIGIO和SIGURG信号的进程ID或进程组ID。正的arg指定⼀个进程ID，负的arg
表⽰等于arg绝对值的⼀个进程组ID。    

fcntl的返回值与命令有关。如果出错，所有命令都返回 －1，如果成功则返回某个其他值。下列4个命令有
特定返回值：F_DUPFD、F_GETFD、F_GETFL 以及 F_GETOWN。第1个命令返回新的⽂件描述符，
第2个和第3个命令返回相应的标志，最后⼀个命令返回⼀个正的进程ID或负的进程组ID。    

## 3.16 /dev/fd

较新的系统都提供名为 /dev/fd 的目录，其目录项是名为 0, 1, 2等的文件。打开文件 /dev/fd/n 
等效于复制描述符 n。    

在下列函数调用中：   

```c
fd = open("/dev/fd/0", mode);
```    

⼤多数系统忽略它所指定的 mode，⽽另外⼀些系统则要求 mode 必须是所引⽤的⽂件（在这⾥是标准输⼊）
初始打开时所使⽤的打开模式的⼀个⼦集。因为上⾯的打开等效于：   

```c
fd = dup(0);
```   

所以描述符 0 和 fd 共享同一文件表项。例如，若描述符 0 先前被打开为只读，那么我们也只能对fd进⾏
读操作。     

Linux 实现中的 /dev/fd 是个例外。它把⽂件描述符映射成指向底层物理⽂件的符号链接。例如，当打开
/dev/fd/0 时，事实上正在打开与标准输⼊关联的⽂件，因此返回的新⽂件描述符的模式与 /dev/fd ⽂件
描述符的模式其实并不相关。    

/dev/fd ⽂件主要由 shell 使⽤，它允许使⽤路径名作为调⽤参数的程序，能⽤处理其他路径名的相同
⽅式处理标准输⼊和输出。     

