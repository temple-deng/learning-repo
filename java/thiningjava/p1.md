# Thinking in Java

<!-- TOC -->

- [Thinking in Java](#thinking-in-java)
  - [枚举](#枚举)
  - [加载](#加载)
  - [运行顺序](#运行顺序)
  - [多态](#多态)
  - [内部类](#内部类)
  - [集合](#集合)
  - [第十二章 异常](#第十二章-异常)
    - [12.6 异常链](#126-异常链)
  - [第十三章　字符串](#第十三章　字符串)
    - [+和StringBuilder](#和stringbuilder)
    - [13.6 正则表达式](#136-正则表达式)
    - [13.7 创建正则表达式](#137-创建正则表达式)
  - [第十四章 类型信息](#第十四章-类型信息)
    - [14.2 Class 对象](#142-class-对象)
      - [14.2.1 类字面常量](#1421-类字面常量)
    - [14.6 反射：运行时类信息](#146-反射运行时类信息)
    - [14.7 动态代理](#147-动态代理)
  - [第十五章 泛型](#第十五章-泛型)
    - [15.1 泛型擦除](#151-泛型擦除)
    - [15.2 通配符](#152-通配符)
  - [第十六章 数组](#第十六章-数组)
    - [16.1 数组和泛型](#161-数组和泛型)
    - [16.2 Arrays 实用功能](#162-arrays-实用功能)
  - [第十七章 容器](#第十七章-容器)
    - [17.1 Collection 的功能方法](#171-collection-的功能方法)
  - [第十八章 IO](#第十八章-io)
    - [18.1 File 类](#181-file-类)
    - [18.2 输入和输出](#182-输入和输出)
    - [18.3 添加属性和有用的接口](#183-添加属性和有用的接口)
    - [18.4 缓冲输入文件](#184-缓冲输入文件)
  - [第十九章 枚举](#第十九章-枚举)
    - [19.1 向枚举添加方法](#191-向枚举添加方法)
  - [第二十章 注解](#第二十章-注解)
    - [20.1 注解的定义](#201-注解的定义)
    - [20.2 四种元注解](#202-四种元注解)
    - [20.3 注解处理器](#203-注解处理器)
  - [第二十一章 并发](#第二十一章-并发)
    - [21.1 使用 Executor](#211-使用-executor)
    - [21.2 从任务中产生返回值](#212-从任务中产生返回值)
    - [21.3 优先级](#213-优先级)
    - [21.4 后台线程](#214-后台线程)
    - [21.5 加入一个线程](#215-加入一个线程)
    - [21.6 捕获异常](#216-捕获异常)
    - [21.7 解决共享资源竞争](#217-解决共享资源竞争)
    - [21.8 原子性与易变性](#218-原子性与易变性)
    - [21.9 临界区](#219-临界区)
    - [21.10 线程本地存储](#2110-线程本地存储)
    - [21.11 在阻塞时终结](#2111-在阻塞时终结)
    - [21.12 检查中断](#2112-检查中断)
    - [21.13 线程之间的协作](#2113-线程之间的协作)

<!-- /TOC -->

## 枚举

在你创建enum时，编译器会自动添加一些有用的特性。例如，
它会创建toString()方法，以便你可以很方便地显示某个enum实
例的名字，这正是上面的打印语句如何产生其输出的答案。编译器
还会创建ordinal()方法，用来表示某个特定enum常量的声明顺
序，以及static values()方法，用来按照enum常量的声明顺序，产
生由这些常量值构成的数组。


尽管enum看起来像是一种新的数据类型，但是这个关键字只是
为enum生成对应的类时，产生了某些编译器行为，因此在很大程度
上，你可以将enum当作其他任何类来处理。事实上，enum确实是
类，并且具有自己的方法。


## 加载

当编译一个.java文件时，在.java文件中的每个类都会有一个输
出文件，而该输出文件的名称与.java文件中每个类的名称相同，只
是多了一个后缀名.class。

Java 解 释 器 的 运 行 过 程 如 下 ： 首 先 ， 找 出 环 境 变 量
CLASSPATH（可以通过操作系统来设置，有时也可通过安装程
序-用来在你的机器上安装Java或基于Java的工具-来设置）。
CLASSPATH包含一个或多个目录，用作查找.class文件的根目录。
从根目录开始，解释器获取包的名称并将每个句点替换成反斜杠，
以 从 CLASSPATH 根 中 产 生 一 个 路 径 名 称 （ 于 是 ， package
foo.bar.baz就变成为foo\bar\baz或foo/bar/baz或其他，这一切取决于
操作系统）。得到的路径会与CLASSPATH中的各个不同的项相连
接，解释器就在这些目录中查找与你所要创建的类名称相关的.class
文件。（解释器还会去查找某些涉及Java解释器所在位置的标准目
录。）但在使用JAR文件时会有一点变化。必须在类路径中将JAR文
件的实际名称写清楚，而不仅是指明它所在位置的目录。


protected也提供包访问权限，也就是说，相同包内的其他类可以访问protected元素。

## 运行顺序

一般来说，可
以说：“类的代码在初次使用时才加载。”这通常是指加载发生于创
建类的第一个对象之时，但是当访问static域或static方法时，也会发
生加载。

初次使用之处也是static初始化发生之处。所有的static对象和
static代码段都会在加载时依程序中的顺序（即，定义类时的书写顺
序）而依次初始化。


## 多态

多态只适用于普通的方法，字段和静态方法都是没有多态的。   

```java
class Super {
  public int field = 0;
  public int getField() {
    return field;
  }
}

class Sub extends Super {
  public int field = 1;
  public int getField() {
    return field;
  }

  public int getSuperField() {
    return super.getField();
  }
}

public class FieldAccess {
  public static void main(String args[]) {
    Super sup = new Sub();

    System.out.println("sup.field = " + sup.field + " . sup.getField() = " + sup.getField());

    Sub sub = new Sub();

    System.out.println("sub.field = " + sub.field + ". sub.getField = " + sub.getField() + ". sub.getSuperField =" + sub.getSuperField())
  }
}

// sup.field = 0, sup.getField() = 1
// sub.field = 1, sub.getField() = 1, sub.getSuperField() = 0
```    

当Sub对象转型为Super引用时，任何域访问操作都将由编译器
解析，因此不是多态的。在本例中，为Super.field和Sub.field分配了
不同的存储空间。这样，Sub实际上包含两个称为field的域：它自
己的和它从Super处得到的。然而，在引用Sub中的field时所产生的
默认域并非Super版本的field域。因此，为了得到Super.field，必须
显式地指明super.field。


## 内部类

普通的内部类的类型，在任何外部类非静态方法之外的任意地方，都需要用 OuterClassName.InnerClassName
这样的形式。

同时，如果要在这样的地方创建一个内部类的实例，这样用 .new 的语法：

```java
DotNew dn = new DotNew();
// 这里还是挺奇怪的，Inner 不用加外部类的前缀
DotNew.Inner dni = dn.new Inner();
```


所以内部类自动拥有对其外围类所有成员的访问权。这是如何
做到的呢？当某个外围类的对象创建了一个内部类对象时，此内部
类对象必定会秘密地捕获一个指向那个外围类对象的引用。然后，
在你访问此外围类的成员时，就是用那个引用来选择外围类的成
员。幸运的是，编译器会帮你处理所有的细节，但你现在可以看
到：内部类的对象只能在与其外围类的对象相关联的情况下才能被
创建（就像你应该看到的，在内部类是非static类时）。构建内部类
对象时，需要一个指向其外围类对象的引用，如果编译器访问不到
这个引用就会报错。不

如果你需要生成对外部类对象的引用，可以使用外部类的名字
后面紧跟圆点和this。

```java
public class DotThis {
  void f() {
    System.out.println("DotThis.f()");
  }

  public class Inner {
    public DotThis outer() {
      return DotThis.this;
    }
  }

  public Inner inner() {
    return new Inner();
  }

  public static void main(String[] args) {
    DotThis dt = new DotThis();
    DotThis.Inner dti = dt.inner();
    dti.outer().f();
  }
}
```   

在拥有外部类对象之前是不可能创建内部类对象的。这是因为
内部类对象会暗暗地连接到创建它的外部类对象上。但是，如果你创建的是嵌套类（静态内部类），那么它就不需要对外部类对象的引用。     


嵌套类与普通的内部类还有一个区别。普通内部类的字段与方
法，只能放在类的外部层次上，所以普通的内部类不能有static数据
和static字段，也不能包含嵌套类。但是嵌套类可以包含所有这些东西。

## 集合


当确定一个元素是否属于某个List，发现某个元素的索引，以及从某个List中移除一个元素时，都会用到equals()方法。


Java的Iterator只能单向移动，这个Iterator只
能用来：
1. 使用方法iterator()要求容器返回一个Iterator。Iterator将准
备好返回序列的第一个元素。
2. 使用next()获得序列中的下一个元素。
3. 使用hasNext()检查序列中是否还有元素。
4. 使用remove()将迭代器新近返回的元素删除。


ListIterator是一个更加强大的Iterator的子类型，它只能用于各
种List类的访问。尽管Iterator只能向前移动，但是ListIterator可以双
向移动。它还可以产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引，并且可以使用set()方法替换它访问过
的最后一个元素。你可以通过调用listIterator()方法产生一个指向
List开始处的ListIterator，并且还可以通过调用listIterator（n）方法
创建一个一开始就指向列表索引为n的元素处的ListIterator。


尝试把数组当作一个Iterable参数传递会导致失败。这说明不存
在任何从数组到Iterable的自动转换，你必须手工执行这种转换。

## 第十二章 异常

### 12.6 异常链

常常会想要在捕获一个异常后抛出另一个异常，并且希望把原
始异常的信息保存下来，这被称为异常链。在JDK 1.4以前，程序员
必须自己编写代码来保存原始异常的信息。现在所有Throwable的子
类在构造器中都可以接受一个cause（因由）对象作为参数。这个
cause就用来表示原始异常，这样通过把原始异常传递给新的异常，
使得即使在当前位置创建并抛出了新的异常，也能通过这个异常链
追踪到异常最初发生的位置。

有趣的是，在Throwable的子类中，只有三种基本的异常类提供
了带cause参数的构造器。它们是Error（用于Java虚拟机报告系统错
误）、Exception以及RuntimeException。如果要把其他类型的异常
链接起来，应该使用initCause()方法而不是构造器

##　第十三章　字符串

### +和StringBuilder

有的时候我们用 + 进行字符串拼接的时候，编译器可能会自动帮我们转换成 StringBuilder，单也
并不是所有的情况编译器都能处理好。因此建议我们大部分情况下，还是自己通过 StringBuilder
处理。

### 13.6 正则表达式

Java 对反斜线和其他的语言不太一样。一般`\\`这样我们在 js 里面都是意味着匹配一个字面意义的
反斜线。但是 Java 中意义反而是这里我就是插入一个正则表达式的反斜线，后面的字符是有特殊的意义。
所以 js 里面的 `\d` 表示数字，Java 里面是 `\\d`，一个普通的反斜线要写成 `\\\\`。
话说，那单个反斜线表示什么意思。

```java
public class IntegerMatch {
  public static  void main(String args[]) {
    System.out.println("-1234".matches("-?\\d+"));
    System.out.println("5678".matches("-?\\d+"));
    System.out.println("+911".matches("-?\\d+"));
    System.out.println("+911".matches("(-|\\+)?\\d+"));
  }
}

// true true false true
```

这里需要着重注意第三个，第三个这里在 js 里面是 true 的，部分是可以匹配的，但是 java 里面
是 false，看起来 java 是必须全匹配？

### 13.7 创建正则表达式

话说它这里有一些语法是 js 里面没见过的。

- `[abc[ijk]]`，等同于 `[abcijk]` 相当于合并了
- `[a-z&&[ijk]]` 匹配任意的 `i,j,k`。相当于交集

一般来说使用 Pattern 和 Matcher 要比使用 String 上面的方法更高效（多次使用的情况）。

## 第十四章 类型信息

### 14.2 Class 对象

类加载器子系统实际上可以包含一条类加载器链，但是只有一
个原生类加载器，它是JVM实现的一部分。原生类加载器加载的是
所谓的可信类，包括Java API类，它们通常是从本地盘加载的。在
这条链中，通常不需要添加额外的类加载器，但是如果你有特殊需
求（例如以某种特殊的方式加载类，以支持Web服务器应用，或者
在网络中下载类），那么你有一种方式可以挂接额外的类加载器。


所有的类都是在对其第一次使用时，动态加载到JVM中的。当
程序创建第一个对类的静态成员的引用时，就会加载这个类。这个
证明构造器也是类的静态方法，即使在构造器之前并没有使用static
关键字。因此，使用new操作符创建类的新对象也会被当作对类的
静态成员的引用。


因此，Java程序在它开始运行之前并非被完全加载，其各个部
分是在必需时才加载的。这一点与许多传统语言都不同。

类加载器首先检查这个类的Class对象是否已经加载。如果尚未
加载，默认的类加载器就会根据类名查找.class文件（例如，某个附
加类加载器可能会在数据库中查找字节码）。在这个类的字节码被
加载时，它们会接受验证，以确保其没有被破坏，并且不包含不良
Java代码。


无论何时，只要你想在运行时使用类型信息，就必须首先获得
对恰当的Class对象的引用。Class.forName()就是实现此功能的便
捷途径，因为你不需要为了获得Class引用而持有该类型的对象。但
是，如果你已经拥有了一个感兴趣的类型的对象，那就可以通过调
用getClass()方法来获取Class引用了，这个方法属于根类Object的
一部分，它将返回表示该对象的实际类型的Class引用。

```java
package com.dengbo.test;

interface HasBatteries {}
interface Waterproof {}
interface Shoots {}

class Toy {
  Toy() {}

  Toy(int i) {}
}


class FancyToy extends Toy implements HasBatteries, Waterproof, Shoots {
  FancyToy() {
    super(1);
  }
}

public class ToyTest {
  static void printInfo(Class<?> cls) {
    System.out.println("Class name: " + cls.getName() + " is interface? [" 
    + cls.isInterface() + "]");
    System.out.println("Simple name: " + cls.getSimpleName());
    System.out.println("Canonical name: " + cls.getCanonicalName());
  }

  public static void main(String args[]) {
    Class<?> c = null;

    try {
      c = Class.forName("com.dengbo.test.FancyToy");
    } catch (ClassNotFoundException e) {
      System.out.println("Can't find FancyToy");
      System.exit(1);
    }

    printInfo(c);

    for (Class<?> face: c.getInterfaces()) {
      printInfo(face);
    }

    Class<?> up = c.getSuperclass();
    Object obj = null;

    try {
      obj = up.newInstance();
    } catch (InstantiationException e) {
      System.out.println("can't 实例化");
      System.exit(1);
    } catch (IllegalAccessException e) {
      System.out.println("can't access");
      System.exit(1);
    }
    printInfo(obj.getClass());
  }
}
/**
 * 
Class name: com.dengbo.test.FancyToy is interface? [false]
Simple name: FancyToy
Canonical name: com.dengbo.test.FancyToy
Class name: com.dengbo.test.HasBatteries is interface? [true]
Simple name: HasBatteries
Canonical name: com.dengbo.test.HasBatteries
Class name: com.dengbo.test.Waterproof is interface? [true]
Simple name: Waterproof
Canonical name: com.dengbo.test.Waterproof
Class name: com.dengbo.test.Shoots is interface? [true]
Simple name: Shoots
Canonical name: com.dengbo.test.Shoots
Class name: com.dengbo.test.Toy is interface? [false]
Simple name: Toy
Canonical name: com.dengbo.test.Toy
 */
```

#### 14.2.1 类字面常量

`FancyToy.class`。


注意，有一点很有趣，当使用“.class”来创建对Class对象的引用
时，不会自动地初始化该Class对象。为了使用类而做的准备工作实际包含三个步骤：

1. 加载，这是由类加载器执行的。该步骤将查找字节码（通常
在classpath所指定的路径中查找，但这并非是必需的），并从这些
字节码中创建一个Class对象。
2. 链接。在链接阶段将验证类中的字节码，为静态域分配存储
空间，并且如果必需的话，将解析这个类创建的对其他类的所有引
用。
3. 初始化。如果该类具有超类，则对其初始化，执行静态初始
化器和静态初始化块

Class.forName 会立即进行初始化。而 .class初始化被延迟到了对静态方法（构造器隐式地是静态的）或者非常数静态域进行首次引用时才执行

### 14.6 反射：运行时类信息

人们想要在运行时获取类的信息的另一个动机，便是希望提供
在跨网络的远程平台上创建和运行对象的能力。这被称为远程方法
调用（RMI），它允许一个Java程序将对象分布到多台机器上。


Class类与java.lang.reflect类库一起对反射的概念进行了支持，
该类库包含了Field、Method以及Constructor类（每个类都实现了
Member接口）。这些类型的对象是由JVM在运行时创建的，用以
表示未知类里对应的成员。这样你就可以使用Constructor创建新的
对象，用get()和set()方法读取和修改与Field对象关联的字
段，用invoke()方法调用与Method对象关联的方法。另外，还可
以调用getFields()、getMethods()和getConstructors()等很便
利的方法，以返回表示字段、方法以及构造器的对象的数组.

### 14.7 动态代理

Java的动态代理比代理的思想更向前迈进了一步，因为它可以
动态地创建代理并动态地处理对所代理方法的调用。在动态代理上
所做的所有调用都会被重定向到单一的调用处理器上，它的工作是
揭示调用的类型并确定相应的对策。

```java
package com.dengbo.test;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

interface Interface {
  void doSomething();
  void somethingElse(String arg);
}

class DynamicProxyHandler implements InvocationHandler {
  private Object proxied;

  public DynamicProxyHandler(Object proxied) {
    this.proxied = proxied;
  }

  // 这里这个 proxy 对象是啥啊
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    System.out.println("proxy: " + proxy.getClass() + ", method:" + method + ". args: " + args);

    if (args != null) {
      for (Object arg: args) {
        System.out.println(" " + arg);
      }
    }

    return method.invoke(proxied, args);
  }
}

class RealObject implements Interface {
  public void doSomething() {
    System.out.println("doSomething");
  }

  public void somethingElse(String arg) {
    System.out.println("something else " + arg);
  }
}

public class SimpleDynamicProxy {
  public static void consumer(Interface iface) {
    iface.doSomething();
    iface.somethingElse("banana");
  }

  public static void main(String[] args) {
    RealObject real = new RealObject();

    consumer(real);

    Interface proxy = (Interface) Proxy.newProxyInstance(
      Interface.class.getClassLoader(), 
      new Class[]{ Interface.class }, 
      new DynamicProxyHandler(real)
    );

    consumer(proxy);
  }
}

/**
 * doSomething
something else banana
proxy: class com.dengbo.test.$Proxy0, method:public abstract void com.dengbo.test.Interface.doSomething(). args: null
doSomething
proxy: class com.dengbo.test.$Proxy0, method:public abstract void com.dengbo.test.Interface.somethingElse(java.lang.String). args: [Ljava.lang.Object;@442d9b6e
 banana
something else banana
 */
```


通过调用静态方法Proxy.newProxyInstance()可以创建动态代
理，这个方法需要得到一个类加载器（你通常可以从已经被加载的
对象中获取其类加载器，然后传递给它），一个你希望该代理实现
的接口列表（不是类或抽象类），以及InvocationHandler接口的一
个实现。动态代理可以将所有调用重定向到调用处理器，因此通常
会向调用处理器的构造器传递给一个“实际”对象的引用，从而使得
调用处理器在执行其中介任务时，可以将请求转发。


这里感觉意思是，首先可以通过 `new DynamicProxyHandler(real)` 获取一个我们普通的代理对象，
理论上以后的操作都是对代理对象上的，而我们想让哪些操作获得代理的话，应该就是第二个参数，
估计是这个接口列表定义的方法，理论上都能在代理对象上调用了。而至于第一个类加载器的作用我就
不清楚了。


invoke()方法中传递进来了代理对象，以防你需要区分请求
的来源，但是在许多情况下，你并不关心这一点。

## 第十五章 泛型

### 15.1 泛型擦除

擦除的代价是显著的。泛型不能用于显式地引用运行时类型的
操作之中，例如转型、instanceof操作和new表达式。因为所有关于
参数的类型信息都丢失了。


这里的擦除应该是指类似于 `x instanceof T` 或者 `new T()` 这种形式，T 都会被删除掉。

### 15.2 通配符

```java
package com.dengbo.test;

class Fruit {}
class Apple extends Fruit {}
class Jonathan extends Apple {}
class Orange extends Fruit {}

public class CovariantArrays {
  public static void main(String[] args) {
    Fruit[] fruit = new Apple[10];

    fruit[0] = new Apple();
    fruit[1] = new Jonathan();

    try {
      fruit[0] = new Fruit(); // ArrayStoreException
    } catch (Exception e) {
      System.out.println(e);
    }

    try {
      fruit[0] = new Orange(); // ArrayStoreException
    } catch (Exception e) {
      System.out.println(e);
    }
  }
}

```

如果实际的数组类型是Apple[]，你应该只能在其中放置
Apple或Apple的子类型，这在编译期和运行时都可以工作。但是请
注意，编译器允许你将Fruit放置到这个数组中，这对于编译器来说
是有意义的，因为它有一个Fruit[]引用——它有什么理由不允许将
Fruit对象或者任何从Fruit继承出来的对象（例如Orange），放置到
这个数组中呢？因此，在编译期，这是允许的。但是，运行时的数
组机制知道它处理的是Apple[]，因此会在向数组中放置异构类型时
抛出异常。

我们之前好像确实没考虑过这个问题。对于这种情况，数组的存储空间怎么分配。

也不太对啊，如果是对象，理论上数组里面保存的都是对对象地址的引用吧。能讲通的话就是在运行时
这就是个 Apple[] 的类型。

同样的例子，如果把数组换成 List 的话，在编译时期就通不过。`List<Fruit>` 和 `List<Apple>`
相当于两种类型。这可能就叫做数组的协变？


## 第十六章 数组

### 16.1 数组和泛型

通常，数组与泛型不能很好地结合。你不能实例化具有参数化类型的数组。擦除会移除参数类型信息，而数组必须知道它们所持有的确切
类型，以强制保证类型安全。

### 16.2 Arrays 实用功能

- `equals`
- `fill`
- `sort`
- `binarySearch`
- `toString`
- `hasCode`
- `asList`

## 第十七章 容器

### 17.1 Collection 的功能方法

- `boolean add(T)`
- `boolean addAll(Collection<? extends T>)`
- `void clear()`
- `boolean contains(T)`
- `boolean containsAll(Collection<?>)`
- `boolean isEmpty()`
- `Iterator<T> iterator()`
- `boolean remove(Object)`
- `boolean removeAll(Collection<?>)`
- `boolean retainAll(Collection<?>)`
- `int size()`
- `Object[] toArray()`
- `<T> T[] toArray(T[] a)`

## 第十八章 IO

### 18.1 File 类

File（文件）类这个名字有一定的误导性；我们可能会认为它
指代的是文件，实际上却并非如此。它既能代表一个特定文件的名
称，又能代表一个目录下的一组文件的名称。

```java
package com.dengbo.test;

import java.io.File;
import java.io.FilenameFilter;
import java.util.Arrays;
import java.util.regex.Pattern;

class DirFilter implements FilenameFilter {
  private Pattern pattern;

  public DirFilter(String regex) {
    pattern = Pattern.compile(regex);
  }

  public boolean accept(File dir, String name) {
    return pattern.matcher(name).matches();
  }
}

public class DirList {
  public static void main(String[] args) {
    File path = new File(".");

    String[] list;

    if (args.length == 0) {
      list = path.list();
    } else {
      list = path.list(new DirFilter(args[0]));
    }

    Arrays.sort(list, String.CASE_INSENSITIVE_ORDER);

    for (String dirItem: list) {
      System.out.println(dirItem);
    }
  }
}
```   

### 18.2 输入和输出

InputStream的作用是用来表示那些从不同数据源产生输入的类。这些数据源包括：

1. 字节数组 ByteArrayInputStream
2. String, StringBufferInputStream
3. 文件 FileInputStream
4. 管道 PipedInputStream
5. 一个由其他种类的流组成的序列，以便我们可以将它们收集合并到一个流内 SequenceInputStream
6. 其他数据源，如 Internet 连接


每一种数据源都有相应的InputStream子类。另外，
FilterInputStream也属于一种InputStream，为“装饰器”（decorator）
类提供基类，其中，“装饰器”类可以把属性或有用的接口与输入流连接在一起。

OutputStream:  

- ByteArrayOutputStream
- FileOutputStream
- PipedOutputStream
- FilterOutputStream

### 18.3 添加属性和有用的接口

FilterInputStream类能够完成两件完全不同的事情。其中，
DataInputStream允许我们读取不同的基本类型数据以及String对象
（所有方法都以“read”开头，例如readByte()、readFloat()等
等）。搭配相应的DataOutputStream，我们就可以通过数据“流”将基
本类型的数据从一个地方迁移到另一个地方。

PrintStream最初的目的便是为了以可视化格式打印所有的基本
数据类型以及String对象。这和DataOutputStream不同，后者的目的
是将数据元素置入“流”中，使DataInputStream能够可移植地重构它
们

PrintStream内有两个重要的方法：print()和println()。对它
们进行了重载，以便可打印出各种数据类型。print()和
println()之间的差异是，后者在操作完毕后会添加一个换行符


### 18.4 缓冲输入文件

如果想要打开一个文件用于字符输入，可以使用以String或File
对象作为文件名的FileInputReader。为了提高速度，我们希望对那
个文件进行缓冲，那么我们将所产生的引用传给一个BufferedReader
构造器。由于BufferedReader也提供readLine()方法，所以这是我
们的最终对象和进行读取的接口。当readLine()将返回null时，你
就达到了文件的末尾。

```java
package com.dengbo.io;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class BufferedInputFile {
    public static String read(String filename) throws IOException {
        BufferedReader in = new BufferedReader(new FileReader(filename));

        String s;
        StringBuilder sb = new StringBuilder();
        while ((s = in.readLine()) != null) {
            sb.append(s);
        }
        in.close();

        return sb.toString();
    }

    public static void main(String[] args) throws IOException {
        System.out.println(read("promise.ts"));
    }
}
```

## 第十九章 枚举

### 19.1 向枚举添加方法

除了不能继承自一个enum之外，我们基本上可以将enum看作一个常规的类。也就是说，我们可以向enum中添加方法。

注意，如果你打算定义自己的方法，那么必须在enum实例序列的最后添加一个分号。同时，Java要求你必须先定义enum实例。
如果在定义enum实例之前定义了任何方法或属性，那么在编译时就会得到错误信息。

## 第二十章 注解

### 20.1 注解的定义

注解的定义看起来很像接口的定义。事实上，与其他任何Java接口一样，
注解也将会编译成class文件。

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Test {}
```

在注解中，一般都会包含一些元素以表示某些值。当分析处理
注解时，程序或工具可以利用这些值。注解的元素看起来就像接口
的方法，唯一的区别是你可以为其指定默认值。

没有元素的注解称为标记注解（marker annotation），例如上例
中的@Test。

```java
package com.dengbo.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface UseCase {
	public int id();
	public String description() default "no description";
}
```   

还得是书本啊，这些元素像接口的方法，这一说就明白了，之前还看不懂这个结构。

```java
package com.dengbo.annotation;

import java.util.List;

public class PasswordUtils {
  @UseCase(id = 47, description = "Passwords must contain at least one numeric")
  public boolean validatePassword(String pwd) {
    return pwd.matches("\\w*\\d\\w*");
  }

  @UseCase(id = 48)
  public String encryptPassword(String password) {
    return new StringBuilder(password).reverse().toString();
  }

  @UseCase(id = 49, description = "New passwords can't equal previously used ones")
  public boolean checkForNewPassword(List<String> prevPasswords, String password) {
    return !prevPasswords.contains(password);
  }
}
```    

### 20.2 四种元注解

- @Target: 表示可以用在什么地方，可能的 ElementType 参数包括
  - CONSTUCTOR: 构造函数的声明
  - FIELD: 字段声明，包括enum实例
  - LOCAL_VARIABLE: 局部变量声明
  - METHOD: 方法声明
  - PACKAGE: 包声明
  - PARAMETER: 形式参数声明
  - TYPE: 类、接口（包括注解类型）或enum声明
- @Retention: 表示注解保留的时间长短，可能的 RetentionPolicy 参数包括
  - SOURCE: 源代码，在编译器处理完之后就丢弃了
  - CLASS: 编译成class文件，但jvm不处理
  - RUNTIME: 运行时，jvm保留该注解，因此可以通过反射机制读取注解的信息，这个应该是重点
- @Documented: 表示是否将注解包含在JavaDoc中
- @Inherited: 表示是否允许子类继承父类的注解


### 20.3 注解处理器

```java
package com.dengbo.annotation;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class UseCaseTracker {

  public static void trackUseCases(List<Integer> useCases, Class<?> cl) {
    for (Method m: cl.getDeclaredMethods()) {
      UseCase uc = m.getAnnotation(UseCase.class);

      if (uc != null) {
        System.out.println("Found Use Case: " + uc.id() + " " + uc.description());

        useCases.remove(new Integer(uc.id()));
      }
    }

    for (int i : useCases) {
      System.out.println("Warning: Missing use case-" + i);
    }
  }

  public static void main(String[] args) {
    List<Integer> useCases = new ArrayList<Integer>();

    Collections.addAll(useCases, 47, 48, 49, 50);

    trackUseCases(useCases, PasswordUtils.class);
  }
}
```   

编译器对元素的默认值有些过分挑剔。首先，元素不能有不确
定的值。也就是说，元素必须要么具有默认值，要么在使用注解时
提供元素的值。

其次，对于非基本类型的元素，无论是在源代码中声明时，或
是在注解接口中定义默认值时，都不能以null作为其值。这个约束
使得处理器很难表现一个元素的存在或缺失的状态，因为在每个注
解的声明中，所有的元素都存在，并且都具有相应的值。为了绕开
这个约束，我们只能自己定义一些特殊的值，例如空字符串或负
数，以此表示某个元素不存在。


假设你希望提供一些基本的对象/关系映射功能，能够自动生成
数据库表，用以存储JavaBean对象。你可以选择使用XML描述文
件，指明类的名字、每个成员以及数据库映射的相关信息。然而，
如果使用注解的话，你可以将所有信息都保存在JavaBean源文件
中。为此，我们需要一些新的注解，用以定义与Bean关联的数据库
表的名字，以及与Bean属性关联的列的名字和SQL类型。


```java
package com.dengbo.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface DBTable {
    public String name() default "";
}

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Constraints {
  boolean primaryKey() default false;
  boolean allowNull() default true;
  boolean unique() default false;
}

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface SQLString {
  int value() default 0;
  String name() default "";

  // 看不太懂这个
  Constraints constraints() default @Constraints;
}

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface SQLInteger {
  String name() default "";
  Constraints constraints() default @Constraints;
}
```    

一个 Bean 的定义

```java
package com.dengbo.annotation;

@DBTable(name = "MEMBER")
public class Member {

  @SQLString(30)
  String firstName;

  @SQLString(50)
  String lastName;

  @SQLInteger
  Integer age;

  @SQLString(value = 30, constraints = @Constraints(primaryKey = true))
  String handle;

  static int memberCount;
  public String getFirstName() {
    return firstName;
  }

  public void setFirstName(String firstName) {
    this.firstName = firstName;
  }

  public String getLastName() {
    return lastName;
  }

  public void setLastName(String lastName) {
    this.lastName = lastName;
  }

  public Integer getAge() {
    return age;
  }

  public void setAge(Integer age) {
    this.age = age;
  }

  public String getHandle() {
    return handle;
  }

  public void setHandle(String handle) {
    this.handle = handle;
  }

  public static int getMemberCount() {
    return memberCount;
  }

  public static void setMemberCount(int memberCount) {
    Member.memberCount = memberCount;
  } 
}
```


实现注解处理器：

```java
package com.dengbo.annotation;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.List;

public class TableCreator {
  public static void main(String[] args) throws Exception {
    if (args.length < 1) {
      System.out.println("arguments: annotated classes");
      System.exit(1);
    }

    for (String className: args) {
      Class<?> cl = Class.forName(className);
      DBTable dbTable = cl.getAnnotation(DBTable.class);
      if (dbTable == null) {
        System.out.println("No DBTable annotations in class " + className);
        continue;
      }

      String tableName = dbTable.name();

      if (tableName.length() < 1) {
        tableName = cl.getName().toUpperCase();
      }

      List<String> columnsDefs = new ArrayList<>();

      for (Field field: cl.getDeclaredFields()) {
        String columnName = null;

        Annotation[] anns = field.getAnnotations();

        if (anns.length < 1) {
          continue;
        }

        if (anns[0] instanceof SQLInteger) {
          SQLInteger sInt = (SQLInteger) anns[0];
          if (sInt.name().length() < 1) {
            columnName = field.getName().toUpperCase();
          } else {
            columnName = sInt.name();
          }

          columnsDefs.add(columnName + " INT" + getConstraints(sInt.constraints()));
        }

        if (anns[0] instanceof SQLString) {
          SQLString sqlString = (SQLString) anns[0];
          if (sqlString.name().length() < 1) {
            columnName = field.getName().toUpperCase();
          } else {
            columnName = sqlString.name();
          }

          columnsDefs.add(columnName + " VARCHAR(" + sqlString.value() + ")" + getConstraints(sqlString.constraints()));
        }

        StringBuilder createCommand = new StringBuilder();
        createCommand.append("CREATE TABLE " + tableName + "(");

        for (String columnDef : columnsDefs) {
          createCommand.append("\n     " + columnDef + ",");
        }

        String tableCreate = createCommand.substring(0, createCommand.length() - 1) + ");";

        System.out.println("Table Creation SQL for " + className + " is: \n" + tableCreate);
      }
    }
  }

  private static String getConstraints(Constraints con) {
    String constraints = "";

    if (!con.allowNull()) {
      constraints += " NOT NULL";
    } else if (con.primaryKey()) {
      constraints += " PRIMARY KEY";
    } else if (con.unique()) {
      constraints += " UNIQUE";
    }

    return constraints;
  }
}
```

## 第二十一章 并发

### 21.1 使用 Executor

Java SE5的java.util.concurrent包中的执行器（Executor）将为你
管理Thread对象，从而简化了并发编程。Executor在客户端和任务
执行之间提供了一个间接层；与客户端直接执行任务不同，这个中
介对象将执行任务。Executor允许你管理异步任务的执行，而无须
显式地管理线程的生命周期。

有了FixedThreadPool，你就可以一次性预先执行代价高昂的线
程分配，因而也就可以限制线程的数量了。这可以节省时间，因为
你不用为每个任务都固定地付出创建线程的开销。在事件驱动的系
统中，需要线程的事件处理器，通过直接从池中获取线程，也可以
如你所愿地尽快得到服务。你不会滥用可获得的资源，因为
FixedThreadPool使用的Thread对象的数量是有界的。

### 21.2 从任务中产生返回值

Runnable是执行工作的独立任务，但是它不返回任何值。如果
你希望任务在完成时能够返回一个值，那么可以实现Callable接口而
不是Runnable接口。在Java SE5中引入的Callabel是一种具有类型参
数的泛型，它的类型参数表示的是从方法call()（而不是
run()）中返回的值，并且必须使用ExecutorService.submit()方
法调用它:

```java
package com.dengbo.concurrency;

import java.util.ArrayList;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

class TaskWithResult implements Callable<String> {
  private int id;
  public TaskWithResult(int id) {
    this.id = id;
  }

  public String call() {
    return "result of TaskWithResult " + id;
  }
}

public class CallableDemo {
  public static void main(String[] args) {
    ExecutorService exec = Executors.newCachedThreadPool();

    ArrayList<Future<String>> results = new ArrayList<>();

    for (int i = 0; i < 10; i++) {
      results.add(exec.submit(new TaskWithResult(i)));
    }

    for (Future<String> fs: results) {
      try {
        System.out.println(fs.get());
      } catch (InterruptedException e) {
        System.out.println(e);
        return;
      } catch (ExecutionException e) {
        System.out.println(e);
      } finally {
        exec.shutdown();
      }
    }
  }
}
```    

submit()方法会产生Future对象，它用Callable返回结果的特
定类型进行了参数化。你可以用isDone()方法来查询Future是否
已经完成。当任务完成时，它具有一个结果，你可以调用get()方
法来获取该结果。你也可以不用isDone()进行检查就直接调用
get()，在这种情况下，get()将阻塞，直至结果准备就绪。你
还可以在试图调用get()来获取结果之前，先调用具有超时的
get()，或者调用isDone()来查看任务是否完成

所以是 get 方法阻塞了进程的结束。

### 21.3 优先级

```java
package com.dengbo.concurrency;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class SimplePriorities implements Runnable{

  private int countDown = 5;
  private volatile double d;
  private int priority;

  public SimplePriorities(int priority) {
    this.priority = priority;
  }

  public String toString() {
    return Thread.currentThread() + " : " + countDown;
  }

  public void run() {
    Thread.currentThread().setPriority(priority);

    while (true) {
      for (int i = 1; i < 10000; i++) {
        d += (Math.PI + Math.E) / (double) i;
        if (i % 1000 == 0) {
          Thread.yield();
        }
      }

      System.out.println(this);
      if (--countDown == 0) {
        return;
      }
    }
  }

  public static void main(String[] args) {
    ExecutorService exec = Executors.newCachedThreadPool();

    for (int i = 0; i <5 ; i++) {
      exec.execute(new SimplePriorities(Thread.MIN_PRIORITY));
    }

    exec.execute(new SimplePriorities(Thread.MAX_PRIORITY));

    exec.shutdown();
  }
}
// 所以我这个结果并没有按照优先级来计算
Thread[pool-1-thread-3,1,main] : 5
Thread[pool-1-thread-4,1,main] : 5 
Thread[pool-1-thread-5,1,main] : 5 
Thread[pool-1-thread-1,1,main] : 5 
Thread[pool-1-thread-6,10,main] : 5
Thread[pool-1-thread-2,1,main] : 5 
Thread[pool-1-thread-3,1,main] : 4 
Thread[pool-1-thread-4,1,main] : 4 
Thread[pool-1-thread-1,1,main] : 4 
Thread[pool-1-thread-5,1,main] : 4 
Thread[pool-1-thread-6,10,main] : 4
Thread[pool-1-thread-2,1,main] : 4 
Thread[pool-1-thread-3,1,main] : 3 
Thread[pool-1-thread-4,1,main] : 3 
Thread[pool-1-thread-1,1,main] : 3 
Thread[pool-1-thread-5,1,main] : 3 
Thread[pool-1-thread-6,10,main] : 3
Thread[pool-1-thread-3,1,main] : 2 
Thread[pool-1-thread-2,1,main] : 3 
Thread[pool-1-thread-4,1,main] : 2 
Thread[pool-1-thread-1,1,main] : 2 
Thread[pool-1-thread-5,1,main] : 2
Thread[pool-1-thread-2,1,main] : 2
Thread[pool-1-thread-4,1,main] : 1
Thread[pool-1-thread-3,1,main] : 1
Thread[pool-1-thread-6,10,main] : 2
Thread[pool-1-thread-5,1,main] : 1
Thread[pool-1-thread-1,1,main] : 1
Thread[pool-1-thread-6,10,main] : 1
Thread[pool-1-thread-2,1,main] : 1
```   

toString()方法被覆盖，以便使用Thread.toString()方法来
打印线程的名称、线程的优先级以及线程所属的”线程组”。你可以
通过构造器来自己设置这个名称；这里是自动生成的名称，如pool
1-thread-1，pool-1-thread-2等。覆盖后的toString()方法还打印了
线程的倒计数值。注意，你可以在一个任务的内部，通过调用
Thread.currentThread()来获得对驱动该任务的Thread对象的引
用。

### 21.4 后台线程

所谓后台（daemon）线程，是指在程序运行的时候在后台提供
一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部
分。因此，当所有的非后台线程结束时，程序也就终止了，同时会
杀死进程中的所有后台线程。反过来说，只要有任何非后台线程还
在运行，程序就不会终止。

```java
package com.dengbo.concurrency;

import java.util.concurrent.TimeUnit;

public class SimpleDaemons implements Runnable {
  public void run() {
    try {
      while (true) {
        TimeUnit.MILLISECONDS.sleep(100);
        System.out.println(Thread.currentThread() + "  " + this);
      }
    } catch (InterruptedException e) {
      System.out.println("sleep() interrupted");
    }
  }

  public static void main(String[] args) throws Exception{
    for (int i = 0; i < 10; i++) {
      Thread daemon = new Thread(new SimpleDaemons());
      daemon.setDaemon(true);
      daemon.start();
    }

    System.out.println("All daemons started");
    TimeUnit.MILLISECONDS.sleep(175);
  }
}

```   

SimpleDaemons. java创建了显式的线程，以便可以设置它们的
后台标志。通过编写定制的ThreadFactory可以定制由Executor创建
的线程的属性（后台、优先级、名称）

```java
package com.dengbo.concurrency;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;

public class DaemonThreadFactory implements ThreadFactory{
  public Thread newThread(Runnable r) {
    Thread t =  new Thread(r);
    t.setDaemon(true);
    return t;
  }
  

  public static void main(String[] args) throws Exception {
    ExecutorService exec = Executors.newCachedThreadPool(
      new DaemonThreadFactory()
    );

    for (int i = 0; i < 10; i++) {
      exec.execute(new DaemonFormFactory());
    }

    System.out.println("All daemons started");

    TimeUnit.MILLISECONDS.sleep(175);
  }
}

class DaemonFormFactory implements Runnable {
  public void run() {
    try {
      while (true) {
        TimeUnit.MILLISECONDS.sleep(100);
        System.out.println(Thread.currentThread() + " " + this);
      }
    } catch (InterruptedException e) {
      System.out.println("Interrupted");
    }
  }
}
```   

### 21.5 加入一个线程

一个线程可以在其他线程之上调用join()方法，其效果是等
待一段时间直到第二个线程结束才继续执行。如果某个线程在另一
个线程t上调用t.join()，此线程将被挂起，直到目标线程t结束才
恢复（即t.isAlive()返回为假）。

也可以在调用join()时带上一个超时参数（单位可以是毫
秒，或者毫秒和纳秒），这样如果目标线程在这段时间到期时还没
有结束的话，join()方法总能返回。

对join()方法的调用可以被中断，做法是在调用线程上调用
interrupt()方法，这时需要用到try-catch子句。

```java
package com.dengbo.concurrency;

class Sleeper extends Thread {
  private int duration;

  public Sleeper(String name, int sleepTime) {
    super(name);
    duration =sleepTime;
    start();
  }

  public void run() {
    try {
      sleep(duration);
    } catch (InterruptedException e) {
      System.out.println(getName() + " was interrupted. " + "isInterrupted()"
      + isInterrupted());
      return;
    }

    System.out.println(getName() + " has awakened");
  }
}

class Joiner extends Thread {
  private Sleeper sleeper;

  public Joiner(String name, Sleeper sleeper) {
    super(name);
    this.sleeper = sleeper;
    start();
  }

  public void run() {
    try {
      sleeper.join();
    } catch (InterruptedException e) {
      System.out.println("Interrupted");
    }
    System.out.println(getName() + " join completed ");
  }

}

public class Joining {
  public static void main(String[] args) {
    Sleeper  sleepy = new Sleeper("Sleepy", 1500);
    Sleeper grumpy = new Sleeper("Grumpy", 1500);

    Joiner dopey = new Joiner("Docey", sleepy);
    Joiner doc = new Joiner("Doc", grumpy);

    grumpy.interrupt();
  }
}

/**
 * Grumpy was interrupted. isInterrupted()false
Doc join completed
Sleepy has awakened
Docey join completed
 * 
 */
```   


Sleeper是一个Thread类型，它要休眠一段时间，这段时间是通
过构造器传进来的参数所指定的。在run()中，sleep()方法有
可能在指定的时间期满时返回，但也可能被中断。在catch子句中，
将根据isInterrupted()的返回值报告这个中断。当另一个线程在该
线程上调用interrupt()时，将给该线程设定一个标志，表明该线
程已经被中断。然而，异常被捕获时将清理这个标志，所以在catch子句中，在异常被捕获的时候这个标志总是为假。除异常之外，这
个标志还可用于其他情况，比如线程可能会检查其中断状态


Joiner线程将通过在Sleeper对象上调用join()方法来等待
Sleeper醒来。在main()里面，每个Sleeper都有一个Joiner，这可
以在输出中发现，如果Sleeper被中断或者是正常结束，Joiner将和
Sleeper一同结束。

### 21.6 捕获异常

由于线程的本质特性，使得你不能捕获从线程中逃逸的异常。
一旦异常逃出任务的run()方法，它就会向外传播到控制台，除非
你采取特殊的步骤捕获这种错误的异常。

Thread.UncaughtException-Handler是Java SE5中的新接口，它允许你
在 每 个 Thread 对 象 上 都 附 着 一 个 异 常 处 理 器 。
Thread.UncaughtExceptionHandler.uncaughtException()会在线程因
未捕获的异常而临近死亡时被调用。

```java
package com.dengbo.concurrency;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;

class ExceptionThread2 implements Runnable {
  public void run() {
    Thread t = Thread.currentThread();

    System.out.println("run() by " + t);
    System.out.println("eh = " + t.getUncaughtExceptionHandler());
    throw new RuntimeException();
  }
}

class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {
  public void uncaughtException(Thread t, Throwable e) {
    System.out.println("caught " + e);
  }
}

class HandlerThreadFactory implements ThreadFactory {
  public Thread newThread(Runnable r) {
    System.out.println(this + " creating new Thread");
    Thread t = new Thread(r);
    System.out.println("created " + t);
    t.setUncaughtExceptionHandler(new MyUncaughtExceptionHandler());

    System.out.println("eh = " + t.getUncaughtExceptionHandler());

    return t;
  }
}

public class CatpureUncaughtException {

  public static void main(String[] args) {
    ExecutorService exec = Executors.newCachedThreadPool(
      new HandlerThreadFactory()
    );

    exec.execute(new ExceptionThread2());
  }
}

/**
 * com.dengbo.concurrency.HandlerThreadFactory@5fcfe4b2 creating new Thread
created Thread[Thread-0,5,main]
eh = com.dengbo.concurrency.MyUncaughtExceptionHandler@5eb5c224
run() by Thread[Thread-0,5,main]
eh = com.dengbo.concurrency.MyUncaughtExceptionHandler@5eb5c224
caught java.lang.RuntimeException
 */
```   

### 21.7 解决共享资源竞争

Java以提供关键字synchronized的形式，为防止资源冲突提供了
内置支持。当任务要执行被synchronized关键字保护的代码片段的时
候，它将检查锁是否可用，然后获取锁，执行代码，释放锁。

共享资源一般是以对象形式存在的内存片段，但也可以是文
件、输入/输出端口，或者是打印机。要控制对共享资源的访问，得
先把它包装进一个对象。然后把所有要访问这个资源的方法标记为
synchronized。如果某个任务处于一个对标记为synchronized的方法
的调用中，那么在这个线程从该方法返回之前，其他所有要调用类
中任何标记为synchronized方法的线程都会被阻塞。

所有对象都自动含有单一的锁（也称为监视器）。当在对象上
调用其任意synchronized方法的时候，此对象都被加锁，这时该对象
上的其他synchronized方法只有等到前一个方法调用完毕并释放了锁
之后才能被调用。

针对每个类，也有一个锁（作为类的Class对象的一部分），所
以synchronized static方法可以在类的范围内防止对static数据的并发
访问。


所以对象天生就带锁，如果使用 synchronized关键字，那么这个方法就相当于成为
临界区了，对当前对象进行了加锁。

### 21.8 原子性与易变性

volatile关键字还确保了应用中的可视性。如果你将一个域声明
为volatile的，那么只要对这个域产生了写操作，那么所有的读操作
就都可以看到这个修改。即便使用了本地缓存，情况也确实如此，
volatile域会立即被写入到主存中，而读取操作就发生在主存中。

### 21.9 临界区

除了加锁整个方法，还可以加锁部分代码。这里，synchronized被用来指定某个对象，此对象的锁被用来对花括号
内的代码进行同步控制。

synchronized块必须给定一个在其上进行同步的对象，并且最合
理的方式是，使用其方法正在被调用的当前对象：synchronized（this）


### 21.10 线程本地存储

防止任务在共享资源上产生冲突的第二种方式是根除对变量的
共享。线程本地存储是一种自动化机制，可以为使用相同变量的每
个不同的线程都创建不同的存储。

创建和管理线程本地存储可以由java.lang.ThreadLocal类来实现。

```java
package com.dengbo.concurrency;

import java.util.Random;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

class Accessor implements Runnable {
  private final int id;

  public Accessor(int idn) {
    id = idn;
  }

  public void run() {
    while (!Thread.currentThread().isInterrupted()) {
      ThreadLocalVariableHolder.increment();
      System.out.println(this);
      Thread.yield();
    }
  }

  public String toString() {
    return "#" + id + ": " +
      ThreadLocalVariableHolder.get();
  }
}


public class ThreadLocalVariableHolder {

  private static ThreadLocal<Integer> value = new ThreadLocal<Integer>() {
    private Random rand = new Random(47);

    protected synchronized Integer initialValue() {
      return rand.nextInt(10000);
    }
  };

  public static void increment() {
    value.set(value.get() + 1);
  }

  public static int get() {
    return value.get();
  }

  public static void main(String[] args) throws Exception {
    ExecutorService exec = Executors.newCachedThreadPool();

    for (int i = 0; i < 5; i++) {
      exec.execute(new Accessor(i));
    }

    TimeUnit.MILLISECONDS.sleep(30);
    exec.shutdownNow();
  }
}

/**
 * #2: 6694
#1: 556
#3: 1862
#4: 962
#0: 9259
#4: 963
#3: 1863
#1: 557
#2: 6695
#1: 558
#3: 1864
#4: 964
#0: 9260
#4: 965
#3: 1865
#1: 559
#2: 6696
#1: 560
#3: 1866
#4: 966
 */
```

ThreadLocal对象通常当作静态域存储。在创建ThreadLocal时，
你只能通过get（）和set（）方法来访问该对象的内容，其中，
get（）方法将返回与其线程相关联的对象的副本，而set（）会将参
数插入到为其线程存储的对象中，并返回存储中原有的对象。


### 21.11 在阻塞时终结

ThreadLocal对象通常当作静态域存储。在创建ThreadLocal时，
你只能通过get（）和set（）方法来访问该对象的内容，其中，
get（）方法将返回与其线程相关联的对象的副本，而set（）会将参
数插入到为其线程存储的对象中，并返回存储中原有的对象。

Thread类包含interrupt（）方法，因此你可以终止被阻塞的任
务，这个方法将设置线程的中断状态。如果一个线程已经被阻塞，
或者试图执行一个阻塞操作，那么设置这个线程的中断状态将抛出
InterruptedException 。 当 抛 出 该 异 常 或 者 该 任 务 调 用
Thread.interrupted（）时，中断状态将被复位。正如你将看到的，
Thread.interrupted（）提供了离开run（）循环而不抛出异常的第二
种方式。


为了调用interrupt（），你必须持有Thread对象。你可能已经注
意到了，新的concurrent类库似乎在避免对Thread对象的直接操作，
转而尽量通过Executor来执行所有操作。如果你在Executor上调用
shutdownNow（），那么它将发送一个interrupt（）调用给它启动的
所有线程。这么做是有意义的，因为当你完成工程中的某个部分或
者整个程序时，通常会希望同时关闭某个特定Executor的所有任
务。然而，你有时也会希望只中断某个单一任务。如果使用
Executor，那么通过调用submit（）而不是executor（）来启动任
务，就可以持有该任务的上下文。submit（）将返回一个泛型Future
＜?＞，其中有一个未修饰的参数，因为你永远都不会在其上调用
get （）——持有这种Future的关键在于你可以在其上调用
cancel（），并因此可以使用它来中断某个特定任务。如果你将true
传递给cancel（），那么它就会拥有在该线程上调用interrupt（）以
停止这个线程的权限。因此，cancel（）是一种中断由Executor启动
的单个线程的方式。

```java
package com.dengbo.concurrency;

import java.io.IOException;
import java.io.InputStream;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

class SleepBlocked implements Runnable {
  public void run() {
    try {
      TimeUnit.MILLISECONDS.sleep(5000);

    } catch (InterruptedException e) {
      System.out.println("Interrupted");
    }

    System.out.println("Exiting SleepBlocked.run()");
  }
}

class IOBlocked implements Runnable {
  private InputStream in;
  public IOBlocked(InputStream is) {
    in = is;
  }

  public void run() {
    try {
      System.out.println("Waiting for read()");
      in.read();
    } catch (IOException e) {
      if (Thread.currentThread().isInterrupted()) {
        System.out.println("Interrupted from blocked IO");
      } else {
        throw new RuntimeException(e);
      }
    }

    System.out.println("Exiting IOBlocked run()");
  }
}

class SynchronizedBlocked implements Runnable {
  public synchronized void f() {
    while(true) {
      // never releases lock
      Thread.yield();
    }
  }

  public SynchronizedBlocked() {
    new Thread() {
      public void run(){
        f();
      }
    }.start();
  }

  public void run() {
    System.out.println("Trying to call f()");
    f();
    System.out.println("Exiting SynchronizedBlocked.run()");
  }
}

public class Interrupting {
  private static ExecutorService exec = Executors.newCachedThreadPool();

  static void test(Runnable r) throws InterruptedException {
    Future<?> f = exec.submit(r);
    TimeUnit.MILLISECONDS.sleep(100);
    System.out.println("Interrupting " + r.getClass().getName());
    f.cancel(true);
    System.out.println("Interrupt sent to " + r.getClass().getName());
  }

  public static void main(String[] args) throws Exception {
    test(new SleepBlocked());
    test(new IOBlocked(System.in));
    test(new SynchronizedBlocked());
    TimeUnit.SECONDS.sleep(3);
    System.out.println("Aborting with System.exit(0)");
    System.exit(0);
  }
}

/**
 * Interrupting com.dengbo.concurrency.SleepBlocked
Interrupt sent to com.dengbo.concurrency.SleepBlocked
Interrupted
Exiting SleepBlocked.run()
Waiting for read()
Interrupting com.dengbo.concurrency.IOBlocked
Interrupt sent to com.dengbo.concurrency.IOBlocked
Trying to call f()
Interrupting com.dengbo.concurrency.SynchronizedBlocked
Interrupt sent to com.dengbo.concurrency.SynchronizedBlocked
Aborting with System.exit(0)
 */
```   


从输出中可以看到，你能够中断对sleep（）的调用（或者任何
要求抛出InterruptedException的调用）。但是，你不能中断正在试
图获取synchronized锁或者试图执行I/O操作的线程。这有点令人烦
恼，特别是在创建执行I/O的任务时，因为这意味着I/O具有锁住你
的多线程程序的潜在可能。特别是对于基于Web的程序，这更是关
乎利害。

### 21.12 检查中断

注意，当你在线程上调用interrupt（）时，中断发生的唯一时
刻是在任务要进入到阻塞操作中，或者已经在阻塞操作内部时（如
你所见，除了不可中断的I/O或被阻塞的synchronized方法之外，在
其余的例外情况下，你无可事事）。但是如果根据程序运行的环
境，你已经编写了可能会产生这种阻塞调用的代码，那又该怎么办
呢？如果你只能通过在阻塞调用上抛出异常来退出，那么你就无法
总是可以离开run（）循环。因此，如果你调用interrupt（）以停止
某个任务，那么在run（）循环碰巧没有产生任何阻塞调用的情况
下，你的任务将需要第二种方式来退出。

就是说我们的 run 方法如果压根不会进入阻塞状态，那么也就永远不会发生中断。


这种机会是由中断状态来表示的，其状态可以通过调用
interrupt（）来设置。你可以通过调用interrupted（）来检查中断状
态，这不仅可以告诉你interrupt（）是否被调用过，而且还可以清
除中断状态。清除中断状态可以确保并发结构不会就某个任务被中
断这个问题通知你两次，你可以经由单一的InterruptedException或
单一的成功的Thread.interrupted（）测试来得到这种通知。如果想
要 再次检查以了解是否被中断，则可以在调用
Thread.interrupted（）时将结果存储起来。


### 21.13 线程之间的协作

当任务协作时，关键问题是这些任务之间的握手。为了实现这
种握手，我们使用了相同的基础特性：互斥。在这种情况下，互斥
能够确保只有一个任务可以响应某个信号，这样就可以根除任何可
能的竞争条件。在互斥之上，我们为任务添加了一种途径，可以将
其自身挂起，直至某些外部条件发生变化（例如，管道现在已经到
位），表示是时候让这个任务向前开动了为止。在本节，我们将浏
览任务间的握手问题，这种握手可以通过Object的方法wait（）和
notify（）来安全地实现。Java SE5的并发类库还提供了具有
await（）和signal（）方法的Condition对象。我们将看到产生的各
类问题，以及相应的解决方案。

wait（）使你可以等待某个条件发生变化，而改变这个条件超
出了当前方法的控制能力。通常，这种条件将由另一个任务来改
变。你肯定不想在你的任务测试这个条件的同时，不断地进行空循
环，这被称为忙等待，通常是一种不良的CPU周期使用方式。因此
wait（）会在等待外部世界产生变化的时候将任务挂起，并且只有
在notify（）或notifyAll（）发生时，即表示发生了某些感兴趣的事
物，这个任务才会被唤醒并去检查所产生的变化。因此，wait（）
提供了一种在任务之间对活动同步的方式。



调用sleep（）的时候锁并没有被释放，调用yield（）也属于这
种情况，理解这一点很重要。另一方面，当一个任务在方法里遇到
了对wait（）的调用的时候，线程的执行被挂起，对象上的锁被释
放。因为wait（）将释放锁，这就意味着另一个任务可以获得这个
锁，因此在该对象（现在是未锁定的）中的其他synchronized方法可
以在wait（）期间被调用。这一点至关重要，因为这些其他的方法
通常将会产生改变，而这种改变正是使被挂起的任务重新唤醒所感
兴趣的变化。因此，当你调用wait（）时，就是在声明：“我已经刚
刚做完能做的所有事情，因此我要在这里等待，但是我希望其他的
synchronized操作在条件适合的情况下能够执行。

```java
package com.dengbo.concurrency;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

class Car {
  private boolean waxOn = false;

  public synchronized void waxed() {
    waxOn = true;
    notifyAll();
  }

  public synchronized void buffed() {
    waxOn = false;
    notifyAll();
  }

  public synchronized void waitForWaxing() throws InterruptedException {
    while (waxOn == false) {
      wait();
    }
  }

  public synchronized void waitForBuffing() throws InterruptedException {
    while (waxOn == true) {
      wait();
    }
  }
}

class WaxOn implements Runnable {
  private Car car;

  public WaxOn(Car c) {
    car = c;
  }

  public void run() {
    try {
      while(!Thread.interrupted()) {
        System.out.println("Wax on!");
        TimeUnit.MILLISECONDS.sleep(200);
        car.waxed();
        car.waitForBuffing();
      }
    } catch (InterruptedException e) {
      System.out.println("Exiting via interrupte");
    }

    System.out.println("Ending Wax On task");
  }
}

class WaxOff implements Runnable {
  private Car car;

  public WaxOff(Car c) { car = c; }

  public void run() {
    try {
      while (!Thread.interrupted()) {
        car.waitForWaxing();
        System.out.println("Wax Off! ");
        TimeUnit.MILLISECONDS.sleep(200);
        car.buffed();
      }
    } catch (InterruptedException e) {
      System.out.println("Exiting via interrupt");
    }
    System.out.println("Ending wax off task");
  }
}

public class WaxOMatic {
  public static void main(String[] args) throws Exception {
    Car car = new Car();
    ExecutorService exec = Executors.newCachedThreadPool();
    exec.execute(new WaxOff(car));
    exec.execute(new WaxOn(car));
    TimeUnit.SECONDS.sleep(5);
    exec.shutdownNow();
  }
}
```  