# 第 2 部分 PHP 基础篇

<!-- TOC -->

- [第 2 部分 PHP 基础篇](#第-2-部分-php-基础篇)
- [第 6 章 安装环境](#第-6-章-安装环境)
- [第 7 章 PHP 的基本语法](#第-7-章-php-的基本语法)
  - [7.3 PHP 语言标记](#73-php-语言标记)
  - [7.7 变量](#77-变量)
  - [7.8 变量的类型](#78-变量的类型)
    - [7.8.2 布尔型](#782-布尔型)
    - [7.8.3 整型](#783-整型)
    - [7.8.4 浮点](#784-浮点)
    - [7.8.5 字符串](#785-字符串)
    - [7.8.6 数组](#786-数组)
    - [7.8.7 对象](#787-对象)
    - [7.8.8 资源类型（resource）](#788-资源类型resource)
    - [7.8.9 NULL 类型](#789-null-类型)
    - [7.8.10 伪类型介绍](#7810-伪类型介绍)
  - [7.9 数据类型之间的相互转换](#79-数据类型之间的相互转换)
    - [7.9.1 自动类型转换](#791-自动类型转换)
    - [7.9.2 强制类型转换](#792-强制类型转换)
    - [7.9.4 变量类型的测试函数](#794-变量类型的测试函数)
  - [7.10 常量](#710-常量)
    - [7.10.3 系统中的预定义常量](#7103-系统中的预定义常量)
    - [7.10.4 PHP 中的魔术常量](#7104-php-中的魔术常量)
  - [7.11 运算符](#711-运算符)
    - [7.11.1 算术运算符](#7111-算术运算符)
    - [7.11.2 字符串运算符](#7112-字符串运算符)
    - [7.11.4 比较运算符](#7114-比较运算符)
    - [7.11.5 逻辑运算符](#7115-逻辑运算符)
    - [7.11.6 位运算符](#7116-位运算符)
    - [7.11.7 其他运算符](#7117-其他运算符)

<!-- /TOC -->

# 第 6 章 安装环境

这里直接用容器了，可以使用 linode/lamp 镜像：    

```cmd
$ docker container run -p 8080:80 -it --name lamp linode/lamp /bin/bash
```    

启动 apache 和 mysql:   

```cmd
$ service apache2 start
$ service mysql start
```    

服务器根目录是在 /var/www/example.com/public_html/。    

# 第 7 章 PHP 的基本语法

## 7.3 PHP 语言标记

1. 以 &lt;?php 开始和以 ?&gt; 结束的标记是标准风格的标记，属于 XML 风格。这是 PHP 推荐使⽤
的标记风格。服务器管理员不能禁⽤这种风格的标记。
2. 以 &lt;script language="php"&gt; 开始和以 &lt;/script&gt; 结束是长分格标记。这种
风格也总是可⽤的，但并不常⽤。
3. 以 &lt;? 开始和以 &gt; 结束的标记是简短风格的标记。系统管理员偶尔会禁⽤它，因为它会⼲扰XML
⽂档的声明。只有通过 php.ini 配置⽂件中的指令 short_open_tag 打开，或者在PHP编译时加⼊了--enable-short-tags 选项后才可⽤。    
4. 以 &lt;% 开始和以 %&gt; 结束的标记是 ASP 风格的标记。如果在php.ini配置⽂件设定中启⽤了
asp_tags 选项，就可以使⽤它。     

## 7.7 变量

PHP的特性之⼀就是它不要求在使⽤变量之前声明变量。当第⼀次给⼀个变量赋值时，你才创建了这个变量。
在 PHP 中的变量声明必须使用一个美元符号 "$" 后跟变量名来表示。大部分的 PHP 变量如果不是在函数
里面声明的，则只能在声明处到文件结束的一个单独的范围内使用。这个单独的范围跨度不仅是在 &lt;?php
标记开始到 ?&gt; 结束标记处使用，可以在一个页面的所有开启的 PHP 模式下使用，也包含了 include
和 require 引入的文件。     

在变量的使用范围内，可以使用 `unset()` 释放指定的变量，使用 `isset()` 检测变量是否设置，使用
`empty()` 检查一个变量是否为空。    

空字符串，0, "0", NULL, FALSE, `array()`, `var $var`，以及没有任何属性的对象都被认为是
空的。    

若使用 `isset()` 测试一个被设置成 NULL 的变量或使用 `unset()` 释放了一个变量，将返回 FALSE。   

变量总是传值赋值。不过 PHP 中提供了另外⼀种⽅式给变量赋值：引⽤赋值。使⽤引⽤赋值，简单地将⼀个
“&” 符号加到将要赋值的变量前（源变量）。   

另外，PHP 的引⽤并不是像C语⾔中的地址指针。例如，在表达式 `$bar=&$foo` 中，不会导致 `$bar`
和 `$foo` 在内存上同体，只是把各⾃的值相关联起来。基于这⼀点，使⽤ `unset()` 则不会导致所有
引⽤变量消失。    

## 7.8 变量的类型

PHP 中支持 8 种原始类型。布尔、整型、浮点、字符串、数组、对象、资源（resource）和 NULL。   

如果想查看某个表达式的值和类型，可以使用 `var_dump()`。  

### 7.8.2 布尔型

TRUE 或 FALSE。在PHP中，布尔型不是只有 TRUE 或 FALSE 两个值，当运算符、函数或者流程控制需要
⼀个 boolean 参数时，任何类型的值PHP都会⾃动转换成布尔型的值。将其他类型作为boolean时，以下
值被认为是 FALSE，所有其他值都被认为是TRUE（包括任何资源）：   

- FALSE
- 0
- 0.0（浮点）
- 空字符串和 "0"
- 没有任何成员变量的数组
- 没有单元的对象（仅适用于 PHP4）
- 特殊类型 NULL（包括尚未设定的变量）    

### 7.8.3 整型

八进制 0 开头，十六进制 0x 开头，好像没有二进制。整型数的字长和平台有关。PHP 不支持无符号整数。

### 7.8.4 浮点

浮点数的字长也和平台相关的。   

浮点数只是⼀种近似的数值，不要⽐较两个浮点数是否相等。     

### 7.8.5 字符串

字符串可以使用单引号、双引号、定界符三种字面上的方法定义。虽然这三种方法都可以定义相同的字符串，
但它们在功能上有明显的区别。    

1. 单引号。单引号中出现的变量不会被变量的值替代。
2. 双引号。双引号中的变量名会被变量值替代。如果是复杂的语法，可以⽤花括号括起⼀个表达式。例如
遇到美元符号（$），解析器会尽可能多地取得后⾯的字符以组成⼀个合法的变量名。如果想明⽰指定名字的
结束，可以⽤花括号把变量名括起来。 
3. 定界符。`<<<`，应该是在 `<<<` 之后提供一个标识符开始，然后是包含的字符串，最后是同样的标识符
结束字符串。结束标识符必须从行的第一列开始，并且后面除了分号不能包含任何其他的字符。    

```php
<?php
	echo <<<he
	1213123123
	hhhhhhhhh
he;
?>
/* 1213123123 hhhhhhhhh */
```    

有点像模板字符串，但是却又进行了空白符的合并，等等，这里空白符的合并是不是 HTML 做的呢。    

定界符⽂本除了不能初始化类成员，表现得就和双引号字符串⼀样，只是没有双引号。    

### 7.8.6 数组

PHP中的数组实际上是⼀张有序图。图是⼀种把values映射到keys的类型，此类型在很多⽅⾯进⾏了优化，
因此可以把它当成真正的数组或列表（⽮量）、散列表（图的⼀种实现）、字典、集合、栈、队列来使⽤，
以及更多可能性。     

在PHP中，可以使⽤多种⽅法构造⼀个数组，在这⾥只⽤ `array()` 语⾔结构来新建⼀个array，它接受
⼀定数量的⽤逗号分隔的 `key=>value` 参数对。    

```php
	<?php
		$arr = array("foo" => "bar", 12 => true);
		print_r($arr);
		echo $arr["foo"];
		echo $arr[12]
  ?>
  /* 打印出 Array ( [foo] => bar [12] => 1 ) bar1 */
```    

看这个意思打印的时候进行了隐式的类型转换。    

那这里数组就完全是一个哈希表啊，目前还没看出一点数组的特性来。    

### 7.8.7 对象

一个对象类型变量，是由一组属性值和一组方法构成的。（所以这里对象和数组的区别就是对象可以包含方法？）    

要初始化一个对象，用 new 语句将对象实例化到一个变量中。     

```php
class Person {
  var $name;
  function say() {
    echo "Hello World";
  }
}
$p = new Person;
$p->name = "Tom";
$p->say();
```    

这里好像对象的属性和方法不能用点运算符访问，只能用 `->` 这种。   

### 7.8.8 资源类型（resource）   

资源是一种特殊类型的变量，保存了到外部资源的一个引用。资源是通过专门的函数来建立和使用的。使用
资源类型变量保存有为打开文件、数据库连接、图形画布区域等的特殊句柄，由程序员创建、使用和释放。    

### 7.8.9 NULL 类型

特殊的 NULL 值表⽰⼀个变量没有值，NULL类型唯⼀可能的值就是 NULL。NULL不区分⼤⼩写，在下列情况
下⼀个变量被认为是 NULL：   

- 将声明直接赋值为 NULL
- 声明的变量尚未被赋值
- 被 `unset()` 函数销毁的变量    

### 7.8.10 伪类型介绍

伪类型并不是PHP语⾔中的基本数据类型，只是因为PHP是弱类型语⾔，所以在⼀些函数中，⼀个参数可以接受
多种类型的数据，还可以接受其他函数作为回调函数使⽤。为了确保代码的易读性，在本书中将介绍⼀些
伪类型的使⽤。在本书中常⽤的伪类型有如下⼏种。   

- mixed: 说明一个参数可以接受多种不同的类型。
- number: 说明一个参数可以是 integer 或者 float。
- callback: 接受一个函数作为参数。    

## 7.9 数据类型之间的相互转换

在PHP中可以根据变量或值的使⽤环境⾃动将其转换为最合适的数据类型，也可以根据需要强制转换为⽤户
指定的类型。     

### 7.9.1 自动类型转换

通常只有4种标量类型（integer、float、string、boolean）才能使⽤⾃动类型转换。注意，这并没有
改变这些运算数本⾝的类型，改变的仅是这些运算数如何被求值。    

- 布尔参与运算时，TRUE 转为 1，FALSE 转为 0
- 有 NULL 参与运算时，转为 0
- 有 integer 和 float 参与运算时，先把 integer 转为 float
- 有字符串和 integer/float 参与运算时，字符串先转换为数字，再参与运算。转换后的数字是从字符串
开始的数值型字符串，如果在字符串开始的数值型字符串不带⼩数点，则转换为integer类型的数字；如果
带有⼩数点，则转换为 float 类型的数字。例如，字符串"123abc"转换为整数123，字符串"123.45abc"
转换为浮点数123.45，字符串"abc"转换为整数0。     

### 7.9.2 强制类型转换

PHP中的类型强制转换和其他语⾔类似，可以在要转换的变量之前加上⽤括号括起来的⽬标类型，也可以使⽤
具体的转换函数，即 `intval()`、`floatval()` 和 `strval()` 等，或是使⽤ `settype()`函数
转换类型。     

```php
$foo = 10;
$bar = (boolean)$foo;
```    

在括号中允许的强制类型转换如下：    

- (int), (integer)
- (bool), (boolean)
- (float), (double), (real)
- (string)
- (array)
- (object)    

函数 `intval()` ⽤于获取变量的整数值；函数 `floatval()` ⽤于获取变量的浮点值；函数
`strval()` ⽤于获取变量的字符串值。    

```php
$str = "123.45abc";
$int = intval($str);    // 123
$flo = floatval($str);   // 123.45
$str = strval(123.45);    // "123.45"
```    

如果需要将变量本⾝的类型转变成其他类型，可以使⽤ `settype()` 函数来设置变量的类型。    

```php
$foo = "hello";
$bar = true;

settype($foo, "integer");
settype($bar, "string");
```     

### 7.9.4 变量类型的测试函数

`gettype()` 函数将确定变量的类型并且返回⼀个包含名称的字符串。`is_type()` 函数，它是PHP提供
的⼀些特定类型的测试函数之⼀。每个函数都使⽤⼀个变量作为其参数，并返回true或false。这些函数如下。    

- `is_bool()`
- `is_int()`, `is_integer()`, `is_long()`
- `is_float()`, `is_double()`, `is_real()`
- `is_string()`
- `is_array()`
- `is_object()`
- `is_resource()`
- `is_null()`
- `is_scalar()`: 判断是否为标量，也就是一个整数、浮点数、布尔型或字符串
- `is_numeric()`: 判断是否是任何类型的数字或数字字符串
- `is_callable()`: 是否有效的函数名

## 7.10 常量

在脚本执⾏期间⼀个常量⼀旦被定义，就不能再改变或者取消定义。常量的作⽤域是全局的，可以在脚本的
任何地⽅声明和访问到常量。常量声明的类型只能是标量数据。     

声明常量和声明变量的⽅式不同，在PHP中是通过 `define()` 函数来定义常量的。常量的命名与变量相似，
也要遵循PHP标识符的命名规则。常量命名不需前加 $。     

```php
boolean define(string name, mixed value [, bool case_insensitive])
```    

如果只想检查是否定义了某个常量，则⽤ `defined()` 函数。    

### 7.10.3 系统中的预定义常量

很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库才会出现。    

常量名 | 常量值 | 说明
---------|----------|---------
 PHP_OS | UNIX 或 WINNT 等 | 执行 PHP 解析的操作系统名称
 PHP_VERSION | 5.2.6 等 | 当前 PHP 服务器的版本
 TRUE | TRUE | 真
 FALSE | FALSE | 假
 NULL | NULL | 空值
 DIRECTORY_SEPARATOR | \ 或 / | 根据操作系统决定⽬录的分隔符
 PATH_SEPARATOR | ; 或 : | 根据操作系统决定环境变量的⽬录列表分隔符
 E_ERROR | 1 | 错误，导致 PHP 脚本运行终止
 E_WARNING | 2 | 警告，不会导致 PHP 脚本运行终止
 E_PARSE | 4 | 解析错误，由程序解析器报告
 E_NOTICE | 8 | 非关键的错误，例如变量未初始化
 M_PI | 3.1415892653 | π

### 7.10.4 PHP 中的魔术常量

PHP 中还有 5 个常量hi根据他们使用的位置而改变，这样的常量在 PHP 中被称为 “魔术常量”，这些特殊
的常量不区分大小写：    

- `__FILE__`: 当前的文件名
- `__LINE__`: 当前的行数
- `__FUNCTION__`: 当前的函数名
- `__CLASS__`: 当前的类名
- `__METHOD__`: 当前对象的方法名    

## 7.11 运算符

可以根据操作数的个数分为⼀元运算符、⼆元运算符、三元运算符。⽽三元运算符只有⼀个（?:）。如果按运算
符的不同功能去分类，可以分为算术运算符、字符串运算符、赋值运算符、⽐较运算符、逻辑运算符、位运算
符和其他运算符。    

### 7.11.1 算术运算符

`+, -, *, /, %, ++, --`。除法和取余，除数不能为 0，取余会将两个操作数都转为整型。   

### 7.11.2 字符串运算符

在PHP中字符串运算符只有⼀个，即点运算符（.），也称为连接运算符。    

这个运算符不仅可以将两个字符串连接起来，变成合并的新字符串；也可以将⼀个字符串和任何标量数据类型
相连接，合并成的都是新的字符串。    

### 7.11.4 比较运算符

⽐较运算符也称关系运算符，又称条件运算符，⽐较运算符的结果只能是布尔值。      

`>, <, >=, <=, ==, ===, <>, !=, !==`。     

### 7.11.5 逻辑运算符

逻辑运算符只能操作布尔型数值，处理后的结果值也是布尔型数值。    

`&&, and, ||, or, !, not, xor`。

### 7.11.6 位运算符

如果左右参数都是字符串，则位运算符将操作字符的ASCII值，浮点数也会⾃动转换为整型再参与位运算。    

`&, |, ^, ~, <<, >>`。    

### 7.11.7 其他运算符

- `?:` 三元运算符
- \`\`: 执行运算符，PHP将尝试将反引号中的内容作为外壳命令来执⾏，并将其输出信息返回。$a=\`ls -al\`
- `@`: 错误控制运算符，当将其放置在一个 PHP 表达式之前时，该表达式可能产生的任何错误信息都将被
忽略。
- `=>`: 数组下标指定符号，通过此符号指定数组的键和值
- `->`: 对象成员访问符号，访问对象中的成员属性或成员方法
- instanceof: 类型运算符，用来测定一个给定的对象是否来自指定的对象类   