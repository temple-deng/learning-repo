# 第 8 章 流程控制结构

<!-- TOC -->

- [第 8 章 流程控制结构](#第-8-章-流程控制结构)
  - [8.1 分支结构](#81-分支结构)
  - [8.2 循环结构](#82-循环结构)
- [第 9 章 函数](#第-9-章-函数)
  - [9.2 自定义函数](#92-自定义函数)
  - [9.4 PHP 变量的作用域](#94-php-变量的作用域)
    - [9.4.1 局部变量](#941-局部变量)
    - [9.4.2 全局变量](#942-全局变量)
    - [9.4.3 静态变量](#943-静态变量)
  - [9.5 声明及应用各种形式的 PHP 函数](#95-声明及应用各种形式的-php-函数)
    - [9.5.6 回调函数](#956-回调函数)
  - [9.7 使用自定义函数库](#97-使用自定义函数库)
  - [9.8 PHP 匿名函数和闭包](#98-php-匿名函数和闭包)
- [第 10 章 数组](#第-10-章-数组)
  - [10.1 数组的分类](#101-数组的分类)
  - [10.2 数组的定义](#102-数组的定义)
  - [10.3 数组的遍历](#103-数组的遍历)
    - [10.3.3 联合使用 list()、each() 和 while 循环遍历数组](#1033-联合使用-listeach-和-while-循环遍历数组)
    - [10.3.4 使用数组的内部指针控制函数遍历数组](#1034-使用数组的内部指针控制函数遍历数组)
  - [10.4 预定义数组](#104-预定义数组)
  - [10.5 数组的相关处理函数](#105-数组的相关处理函数)
    - [10.5.1 数组的键/值操作函数](#1051-数组的键值操作函数)
    - [10.5.2 统计数组元素的个数和唯一性](#1052-统计数组元素的个数和唯一性)
    - [10.5.3 使用回调函数处理数组的函数](#1053-使用回调函数处理数组的函数)
    - [10.5.4 数组的排序函数](#1054-数组的排序函数)
    - [10.5.5 拆分、合并、分解和连接数组](#1055-拆分合并分解和连接数组)
    - [10.5.7 其他函数](#1057-其他函数)
  - [10.6 操作PHP数组需要注意的⼀些细节](#106-操作php数组需要注意的⼀些细节)
    - [10.6.1 数组运算符号](#1061-数组运算符号)

<!-- /TOC -->

## 8.1 分支结构

switch 语句后⾯的控制表达式的数据类型只能是整型或字符串。    

## 8.2 循环结构

在 PHP 中提供了 while、do-while 和 for 三种循环。     

# 第 9 章 函数

## 9.2 自定义函数

在PHP中不能使⽤函数重载，所以不能定义重名的函数，也包括不能和系统函数同名。    

只要声明的函数在脚本中可见，就可以通过函数名在脚本的任意位置调⽤。在PHP中可以在函数的声明之后调⽤，
也可以在函数的声明之前调⽤。    

## 9.4 PHP 变量的作用域

变量依据声明的位置分为局部变量的全局变量两种。    

### 9.4.1 局部变量

局部变量也称为内部变量，是在函数内部声明的变量，其作⽤域仅限于函数内部，离开该函数后再使⽤这种
变量是⾮法的。不仅在函数中声明的变量是局部变量，为声明函数设置的参数因为只能在本函数的内部使⽤，
所以也是局部变量。区别在于函数的参数具体数值从函数外部获得（函数被调⽤时传⼊的值），⽽直接在函数
中声明的变量只能在函数内部被赋值。但它们的作⽤域都仅限于函数内部，因为当每次函数被调⽤时，函数
内部的变量才被声明，执⾏完毕后函数内部的变量都被释放。   

### 9.4.2 全局变量

全局变量也称为外部变量，是在函数的外部定义的，它的作⽤域为从变量定义处开始，到本程序⽂件的末尾。
和其他编程语⾔不同，全局变量不是⾃动设置为可⽤的。在PHP中，由于函数可以视为单独的程序⽚段，所以
局部变量会覆盖全局变量的能见度，因此在函数中⽆法直接调⽤全局变量。    

在函数中若要使⽤全局变量，必须要利⽤ `global` 关键字定义⽬标变量，以告诉函数主体此变量为全局变量。    

```php
$one = 100;
$two = 200;

function demo() {
  global $one, $two;

  echo $one + $two;
}

demo();
```    

在函数中使⽤全局变量，除了使⽤关键字 global，还可以⽤特殊的 PHP ⾃定义 `$GLOBALS` 数组。   

### 9.4.3 静态变量

局部变量从存储⽅式上可分为动态存储类型和静态存储类型。函数中的局部变量，如不专门声明为 `static`
存储类别，默认都是动态地分配存储空间的。其中的内部动态变量在函数调⽤结束后⾃动释放。如果希望在
函数执⾏后，其内部变量依然保存在内存中，应使⽤静态变量。在函数执⾏完毕后，静态变量并不会消失，⽽
是在所有对该函数的调⽤之间共享，即在函数再次执⾏时，静态变量将接续前次的结果继续运算，并且仅在
脚本的执⾏期间函数第⼀次被调⽤时被初始化。     

这东西挺像闭包的，而且看起来使用 `static` 声明就只是来区分应该在堆上给变量分配空间，还是在栈中。   

```php
function test() {
  static $a = 0;
  echo $a . '<div></div>';
  $a++;
}

test();   // 0
test();   // 1
test();   // 2
```    

## 9.5 声明及应用各种形式的 PHP 函数

引用参数的函数格式说明如下：   

```php
void funcName (array &arg)
```    

如果在函数的形参中由使用 "&" 修改的参数，则在调用该函数时就必须传入一个变量给这个参数，而不能
传递一个值。    

默认参数的函数格式说明如下：   

```php
mixed funcName (string name [, string value [, int expire]])
```    

在定义函数时声明了参数，⽽在调⽤函数时没有指定参数或是少指定了参数，就会出现缺少参数的警告。
在 PHP 中，⽀持函数的默认⽅式调⽤，即为参数指定⼀个默认值。默认值必须是常量表达式，不能是
变量、类成员或者函数调⽤。    

```php
function person ($name = 'Tom', $age = 20, $sex = 'male') {
  // ...
}
```   

通常，⽤户在定义函数时，设置的参数数量是有限的。如果希望函数可以接受任意数量的参数，则需要在函数
中使⽤PHP系统提供的 `func_get_args()` 函数，它将所有传递给脚本函数的参数当作⼀个数组返回，
相当于返回了 JS 中 Arguments 对象。    

除此之外，也可以使用 `func_num_args()` 函数返回参数的总数，使用 `func_get_arg()` 函数接受
一个数字索引，返回指定索引的参数。    

### 9.5.6 回调函数

变量函数也称为可变函数。如果⼀个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且将尝试执⾏
它。例如，声明⼀个函数 `test`，将函数名称字符串“test”赋给变量 `$demo`。如果直接打印`$demo`变
量，输出的值⼀定是字符串“test”；但如果在 `$demo` 变量后加上圆括号 `$demo()`，则为调⽤对应
`$demo` 变量值“test”的函数。这样就可以将不同的函数名称赋给同⼀个变量，再通过变量去调⽤这个函数。    

```php
function sum($a, $b) {
  return $a + $b;
}
function squareSum($a, $b) {
  return $a * $a + $b * $b;
}
function cubicSum($a, $b) {
  return $a * $a * $a + $b * $b * $b;
}

$result = "sum";

echo '和：' . $result(2, 4) . '<div></div>';

$result = "squareSum";

echo '平方和：' . $result(2, 4) . '<div></div>';

$result = "cubicSum";

echo '立方和：' . $result(2, 4) . '<div></div>';
```    

虽然可以使⽤变量函数去声明⾃⼰的回调函数，但最多的还是通过 `call_user_func_array()` 函数去
实现。函数 `call_user_func_array()` 是PHP中的内置函数，其实它也是⼀个回调函数。    

。。。我觉得作者连什么是回调函数的定义都没搞懂，这样的函数应该叫高阶函数。     

```php
mixed call_user_func_array (callback function, array param_arr)
```    

该函数有两个参数：第一个参数因为使用伪类型 callback，所以这个参数需要是一个字符串，表示要调用的
函数名；第二个参数则是一个数组类型的参数，表示参数列表，按照顺序依次会传递给要调用的函数。   

。。。凭心而论，我觉得这里作者对这个函数的示例有误解。。。。

前⾯介绍的都是通过全局函数（没有在任何对象或类中定义的函数）声明和应⽤的回调函数，但如果遇到回调
类中的静态⽅法，或是对象中的普通⽅法，则会有所不同。    

```php
call_user_func_array("函数名称字符串")   // 回调全局函数
call_user_func_array(array("类名称字符串", "类中静态方法名称字符串"))
call_user_func_array(array(对象引用, "对象中方法名称字符串"))
```    

## 9.7 使用自定义函数库

使⽤ `include()`、`include_once()`、`require()` 或 `require_once()` 中的⼀个函数，
将函数库⽂件载⼊脚本程序中。     

`require()` 语句的性能与 `include()` 类似，都是包括并运⾏指定⽂件。不同之处在于，对 `include()`
语句来说，在执⾏⽂件时每次都要进⾏读取和评估；⽽对于 `require()` 语句来说，⽂件只处理⼀次（实际上
⽂件内容替换了 `require()` 语句）。这就意味着如果可能执⾏多次的代码，则使⽤ `require()`效率
⽐较⾼。另外，如果每次执⾏代码时读取不同的⽂件，或者有通过⼀组⽂件迭代的循环，就使⽤ `include()`
语句。    

`require()` 语句的使⽤⽅法如 `require("myfile.php")`，这条语句通常放在 PHP 脚本程序的最
前⾯。PHP程序在执⾏前就会先读⼊ `require()` 语句所引⼊的⽂件，使它变成PHP脚本⽂件的⼀部分。
`include()` 语句的使⽤⽅法和 `require()` 语句⼀样，如 `include("myfile.php")`。
⽽这条语句⼀般放在流程控制的处理区段中。PHP脚本⽂件在读到 `include()` 语句时，才将它包含的⽂件
读进来。     

`require()` 和 `include()` 语句是语⾔结构，不是真正的函数，可以像 PHP中其他的语⾔结构⼀样，
例如 `echo()` 可以使⽤ `echo("abc")` 形式，也可以使⽤ `echo"abc"` 形式输出字符串abc。
`require()` 和 `include()` 语句也可以不加圆括号⽽直接加参数，例如 include 语句可以使⽤
`include("file.php")` 包含 file.php ⽂件，也可以使⽤ `include"file.php"` 形式。    

`include_once()` 和 `require_once()` 语句也是在脚本执⾏期间包括并运⾏指定⽂件。此⾏为和
`include()` 及 `require()` 语句类似，使⽤⽅法也⼀样。唯⼀区别是如果该⽂件中的代码已经被包括
了，则不会再次包括。    

## 9.8 PHP 匿名函数和闭包

匿名函数也叫闭包函数（closures），它允许临时创建⼀个没有指定名称的函数，常⽤作回调函数参数的值。    

```php
function callback($callback) {
  $callback();
}

callback(function() {
  echo "closure";
});
```    

闭包的⼀个重要概念就是在内部函数中可以使⽤外部变量，需要通过关键字 `use` 来连接闭包函数和外界变量，
这些变量都必须在函数或类的头部声明。闭包函数是从⽗作⽤域中继承变量，与使⽤全局变量是不同的。全局
变量存在于⼀个全局的范围，⽆论当前正在执⾏的是哪个函数。⽽闭包的⽗作⽤域是定义该闭包的函数，
不⼀定是调⽤它的函数。     

。。。。这里作者好像对闭包的理解也有问题，它举的例子好像和闭包没什么关系。。。。    

# 第 10 章 数组

## 10.1 数组的分类

存储在数组中的单个值称为数组的元素，每个数组元素都有⼀个相关的索引，可以视为数据内容在此数组中的
识别名称，通常也被称为数组下标。可以⽤数组中的下标来访问和下标相对应的元素。也可以将下标称为键名，
键和值之间的关联通常称为绑定，键和值之间相互映射。在 PHP 中，根据数组提供下标的不同⽅式，可将
数组分为索引数组（indexed）和关联数组（associative）两种。    

索引数组的索引值是整数。关联数组使用字符串作为索引值。   

## 10.2 数组的定义

在 PHP 中⾃定义数组可以使⽤以下两种⽅法：   

- 直接为数组元素赋值即可声明数组
- 使⽤ `array()` 函数声明数组

使⽤直接为数组元素赋值的⽅法声明⼀维数组的语法如下所⽰：   

```
$arrName[index] = value
```    

可以使⽤ `print_r()` 或 `var_dump()` 函数打印数组中所有元素的内容。    

声明索引数组时，如果索引值是递增的，可以不在⽅括号内指定索引值，默认的索引值从0开始依次增加。    

```php
$arr[] = 1;
$arr[] = 2;
$arr[] = 3;
```   

## 10.3 数组的遍历

由于 PHP 中存在关联数组，所以比较少用 for 来遍历。   

一般用 foreach 来遍历，使⽤ foreach 语句遍历数组时与数组的下标⽆关，不管是连续的数字索引数组，
还是以字符串为下标的关联数组，都可以使⽤ foreach 语句遍历。foreach 只能⽤于数组，⾃ PHP5 起，
还可以遍历对象。当试图将其⽤于其他数据类型或者⼀个未初始化的变量时会产⽣错误。foreach 语句有两
种语法格式，第⼆种⽐较次要，但却是第⼀种有⽤的扩展。     

```
第一种语法格式
foreach(array_expression as $value) {
  ...
}

第二种语法格式
foreach (array_expression as $key->$value) {
  ...
}
```    

左边第⼀种格式遍历给定的 array_expression 数组。每次循环中，当前元素的值被赋给变量 $value
（$value是⾃定义的任意变量），并且把数组内部的指针向后移动⼀步，因此下⼀次循环中将会得到该数组的下
⼀个元素，直到数组的结尾停⽌循环，结束数组的遍历。     

foreach 语句的第⼆种格式和第⼀种格式是做同样的事，只是当前元素的键名也会在每次循环中被赋给变量
$key。    

### 10.3.3 联合使用 list()、each() 和 while 循环遍历数组

遍历数组的另外⼀种简便⽅法就是使⽤ `list()`、`each()` 和 `while` 语句联合，也是忽略数组元素
下标就可以遍历数组的⽅法。     

`each()` 函数需要传递⼀个数组作为参数，返回数组中当前元素的键/值对，并向后移动数组指针到下⼀个
元素的位置。键/值对被返回为带有4个元素的关联和索引混合的数组，键名分别为0、1、key 和 value。
其中键名0和key对应的值是⼀样的，是数组元素的键名，1和value则包含数组元素的值。如果内部指针越过
了数组的末端，则 `each()` 返回 FALSE。    

```php
$arr = array("hello" => "world", 1 => "magic");

$item = each($arr);
var_dump($item);
$item = each($arr);
var_dump($item);
$item = each($arr);
```    

list 也是 PHP 的语言结构，那现在知道的语言结构包括 echo, include。`list()` ⽤⼀步操作给⼀组
变量进⾏赋值，即把数组中的值赋给⼀些变量。`list()` 仅能⽤于数字索引的数组并假定数字索引从0开始。    

```
list (mixed varname, mixed ...) = array_expression
```    

`list()` 语句和其他函数在使⽤上有很⼤的区别，它并不是直接接收一个数组作为参数，⽽是通过“=”运算
符以赋值的⽅式，将数组中每个元素的值，对应地赋给 `list()` 函数中的每个参数。`list()` 函数又将
其中的每个参数转换为直接可以在脚本中使⽤的变量。     

```php
$info = array("coffee", "brown", "caffsine");
list($drink, $color, $power) = $info;
echo $drink . '<div></div>';
echo $color . '<div></div>';
echo $power . '<div></div>';
```    

将 `each()` 函数和 `list()` 函数结合起来使⽤。     

```php
$contact = array("ID" => 1, "name": "Tom", "company": "facebook", "location": "New York");

list($key, $val) = each($contact);
```   

然后再结合一下 while 即可遍历数组。   

注意貌似 each 在 7.2 中已被废弃。   

### 10.3.4 使用数组的内部指针控制函数遍历数组

数组的内部指针是数组内部的组织机制，指向⼀个数组中的某个元素。默认指向数组中第⼀个元素，通过移动
或改变指针的位置，可以访问数组中的任意元素。对于数组指针的控制，PHP提供了以下⼏个内建函数可以利用：   

+ `current()`: 取得目前指针位置的内容资料
+ `key()`: 读得目前指针所指向资料的索引值
+ `next()`: 将数组中的内部指针移动到下一个单元
+ `prev()`: 将数组的内部指针倒回一位
+ `end()`: 将数组的内部指针指向最后一个元素
+ `reset()`: 将目前指针无条件移至第一个索引位置    

```php
$arr = array("hello" => "world", "sex" => "male", 1 => "coffee");

$cur = current($arr);
$curKey = key($arr);
echo "CurKey $curKey, CurVal $cur" . '<div></div>';

next($arr);
$cur = current($arr);
$curKey = key($arr);
echo "CurKey $curKey, CurVal $cur" . '<div></div>';

end($arr);
$cur = current($arr);
$curKey = key($arr);
echo "CurKey $curKey, CurVal $cur" . '<div></div>';
```    

## 10.4 预定义数组

从 PHP 4.1.0 开始，PHP 提供了⼀套附加的预定义数组，这些数组变量包含了来⾃ Web服务器、客户端、
运⾏环境和⽤户输⼊的数据。这些数组⾮常特别，通常被称为⾃动全局变量或者“超”全局变量，它们具有
以下⼏个特性：    

- 就是⼀种特殊的数组，操作⽅式没有区别。
- 不⽤去声明它们，在每个PHP脚本中默认存在，因为在 PHP 中⽤户不⽤⾃定义它们，所以在⾃定义变量时
应避免和预定义的全局变量同名。
- 它们在全局范围内⾃动⽣效，即在函数中直接就可以使⽤，且不⽤使⽤ `global` 关键字访问它们。    

目前版本中包含的预定义超全局数组变量：    

- `$_SERVER`: 变量由Web服务器设定或者直接与当前脚本的执⾏环境相关联
- `$_ENV`: 执行环境提交至脚本的变量
- `$_GET`: 经由 URL 请求提交至脚本的变量
- `$_POST`: 经由 HTTP POST 方法提交至脚本的变量
- `$_REQUEST`: 经由 GET、POST 和 Cookie 机制提交至脚本的变量
- `$_FILES`: 经由 HTTP POST 文件上传而提交至脚本的变量
- `$_COOKIE`: 经由 HTTP Cookies 方法提交至脚本的变量
- `$_SESSION`: 当前注册给脚本会话的变量
- `$GLOBALS`: 包含⼀个引⽤指向每个当前脚本的全局范围内有效的变量。该数组的键名为全局变量的名称    

## 10.5 数组的相关处理函数

### 10.5.1 数组的键/值操作函数

- `array_values()`: 返回数组中所有元素的值，一个必选参数，即给定的数组，返回一个包含给定数组
中所有值的数组，但不保留键名，被返回的数组将使⽤顺序的数值键重新建⽴索引，从0开始且以1递增。
- `array_keys()`: 返回数组中所有的键名，一个必选参数和两个可选参数，第一个可选参数是 search_value，
如果指定了这个参数，则只返回该键名，否则数值中的所有键名都被返回，第二个可选参数是 strict，进行
严格相等比较。   
- `in_array()`: 在数组中搜索给定值。三个参数，前两个必选，第一个参数是要搜索的值，第二个参数
haystack 是要被搜索的数组，第三个是 strict。   
- `array_search()`: 与 `in_array` 参数相同，但是在存在时返回相应的键名
- `array_key_exists()`: 检查给定的键名是否存在于数组中
- `array_flip()`: 交换数组中的键和值，返回⼀个反转后的数组。如果同⼀个值出现了多次，则最后⼀
个键名将作为它的值，覆盖前⾯出现的元素。如果原数组中的值的数据类型不是字符串或整数，函数将报错。 
- `array_reverse()`: 将原数组中的元素顺序翻转，创建新的数组并返回。第二个参数 preserve_keys，
如果为 true，则元素的键名保持不变，否则键名将丢失，话说这个排序规则是什么啊    

### 10.5.2 统计数组元素的个数和唯一性

- `count()`: 计算数组中的元素数⽬或对象中的属性个数。对于数组，返回其元素的个数；对于其他值，
则返回1。第二个参数是可选的，规定函数的模式是否递归地计算多维数组中的数组的元素个数 
- `array_count_values()`: 统计数组中所有值的出现的次数，返回一个数组，元素的键名是原数组的
值，键值是改值再原数组中出现的次数
- `array_unique()`: 删除数组中重复的值，并返回没有重复值的新数组

### 10.5.3 使用回调函数处理数组的函数

- `array_filter()`: 过滤数组中元素，返回新数组 `array array_filter(array input[, callback])`，
貌似cb的唯一参数是元素值，貌似新版本的 php 中加了第三个参数，用来控制可以接收键名
- `array_walk()`: 对每个元素调用回调，如果成功返回 true，回调第一个参数元素值，第二个参数是键名
- `array_map()`: 回调函数作⽤于给定数组的元素上，返回⽤户⾃定义函数作⽤后的数组。回调函数接收的参
数数⽬应该和传递给 `array_map()` 函数的数组数⽬⼀致。`array array_map(cb, array arr1 [, arr2...])`

### 10.5.4 数组的排序函数

- `sort()`, `rsort()`: 对值进行排序，即按照按数字也可以按字母序，参数列表一致，r 是从大到小
`bool sort(array &array[, int sort_flags])`，第二个排序方式：
  + SORT_REGULAR: 默认值，自动识别元素类型进行排序
  + SORT_NUMBERIC: 数字排序
  + SORT_STRING: 用于字符串元素的排序
  + SORT_LOCALE_STRING: 根据当前 locale 设置把元素当做字符串比较
- `ksort()`, `krsort()`: 对键名进行排序
- `asort()`, `arsort()`: 也是对键值进行排序，与 sort 不同的是，sort 排序后原始键名丢失了，
但 asort 会保留原始键值对的映射关系
- `natsort()`, `natcasesort()`   
- `usort()`, `uasort()`, `uksort()`: 自定义比较函数排序 `bool usort(&array, cmp_function)`

### 10.5.5 拆分、合并、分解和连接数组

- `array array_slice(array, offset [, length [, preserve_keys]])`
- `array array_splice(&input, offset [, length [array replacement]])`
- `array array_combine(keys, values)`: 其中的⼀个数组是键名，另⼀个数组的值为键值。如果
其中⼀个数组为空，或者两个数组的元素个数不同，则该函数返回false。    
- `array array_merge(array1[,array2[,....]])`: 把⼀个或多个数组合并为⼀个数组。如果数组
是数字索引的，则键名会以连续⽅式重新索引。   
- `array array_intersect(array1, array2[, array3...])`: 计算数组的交集。返回的结果数
组中包含了所有在被⽐较数组中，也同时出现在所有其他参数数组中的值，键名保留不变，仅有值⽤于⽐较。
- `array_diff()`: 返回两个数组的差集数组。该数组包括了所有在被⽐较的数组中，但是不在任何其他
参数数组中的元素值。在返回的数组中，键名保持不变。

### 10.5.7 其他函数

- `int array_push(&array, mixed var[, mixed ...])`
- `mixed array_pop(&array)`
- `mixed array_shift(&array)`
- `int array_push(&array, mixed var[, mixed ...])`
- `mixed array_rand(input[, num_req])`: 随机选出一个或多个元素并返回。如果只取出⼀个，
`array_rand()` 函数返回⼀个随机元素的键名，否则就返回⼀个包含随机键名的数组。 
- `shuffle()`: 把数组中的元素按随机顺序重新排列，即将数组中的顺序打乱。 
- `array range(mixed first, mixed second[, number step])`    

## 10.6 操作PHP数组需要注意的⼀些细节

### 10.6.1 数组运算符号

数组这种复合类型的数据也可以像整型⼀样通过⼀些运算符号进⾏运算。例如，“+”运算符的使⽤就可以直接
合并两个数组，把右边运算元的数组附加到左边运算元的数组后⾯，但是重复的键值不会被覆盖。    

$a == $b 如果$a和$b具有相同的键/值对则为TRUE。   

$a === $b 如果$a和$b具有相同的键/值对并且顺序和类型都相同则为TRUE。