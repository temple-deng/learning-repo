# 第 11 章 面对对象

<!-- TOC -->

- [第 11 章 面对对象](#第-11-章-面对对象)
  - [11.2 如何抽象一个类](#112-如何抽象一个类)
    - [11.2.1 类的声明](#1121-类的声明)
  - [11.3 通过类实例化对象](#113-通过类实例化对象)
    - [11.3.1 实例化对象](#1131-实例化对象)
    - [11.3.4 特殊的对象引用 $this](#1134-特殊的对象引用-this)
    - [11.3.5 构造方法与析构方法](#1135-构造方法与析构方法)
  - [11.4 封装性](#114-封装性)
    - [11.4.1 设置私有成员](#1141-设置私有成员)
    - [11.4.3 __set(), __get(), __isset(), __unset()](#1143-__set-__get-__isset-__unset)
  - [11.5 继承性](#115-继承性)
    - [11.5.2 访问类型控制](#1152-访问类型控制)
    - [11.5.3 子类中重载父类的方法](#1153-子类中重载父类的方法)
  - [11.6 常见的关键字和魔术方法](#116-常见的关键字和魔术方法)
    - [11.6.6 克隆对象](#1166-克隆对象)
    - [11.6.8 __call()](#1168-__call)
    - [11.6.9 自动加载类](#1169-自动加载类)
  - [11.7 抽象类与接口](#117-抽象类与接口)
    - [11.7.1 抽象类](#1171-抽象类)
    - [11.7.2 接口技术](#1172-接口技术)

<!-- /TOC -->

## 11.2 如何抽象一个类

### 11.2.1 类的声明

```
[修饰词] class 类名 {
  类中成员
}
```    

在类中声明成员属性时，属性名前⾯⼀定要使⽤⼀个关键字，例如使⽤ `public`、`private`、`static`
等关键字来修饰，但这些关键字修饰的变量都具有⼀定的意义。如果不需要有特定意义的修饰，就使⽤ `var`
关键字:   

```php
class Person {
  public $var1;
  private $var2;
  static $var3;
  var $var4;
}
```   

成员⽅法的声明和函数的声明完全⼀样，只不过可以加⼀些关键字的修饰来控制成员⽅法的⼀些权限，
例如 `private`、`public`、`static` 等。修饰词是在 function 关键字前面。   

## 11.3 通过类实例化对象

### 11.3.1 实例化对象

```
$obj = new ClassName([arguments])
$obj2 = new ClassName
```    

### 11.3.4 特殊的对象引用 $this

对象⼀旦被创建，在对象中的每个成员⽅法⾥⾯都会存在⼀个特殊的对象引⽤ `$this`。成员⽅法属于哪个
对象，`$this` 引⽤就代表哪个对象，专门⽤来完成对象内部成员之间的访问。    

### 11.3.5 构造方法与析构方法

构造⽅法是对象创建完成后第⼀个被对象⾃动调⽤的⽅法，⽽析构⽅法是对象在销毁之前最后⼀个被对象⾃动
调⽤的⽅法。析构⽅法允许在销毁⼀个对象之前执⾏⼀些特定操作，例如关闭⽂件、释放结果集等。   

如果没有显式地声明构造函数，类中都会默认存在⼀个没有参数列表并且内容为空的构造函数。如果显式地声
明它，则类中的默认构造函数将不会存在。   

构造函数名称必须是 `__construct()`。析构函数名称为 `__destruct()`。    

## 11.4 封装性

### 11.4.1 设置私有成员

使⽤ `private` 关键字修饰就实现了对成员的封装。封装后的成员在对象的外部不能被访问。   

### 11.4.3 __set(), __get(), __isset(), __unset()

PHP系统中给我们提供了很多预定义的⽅法，这些⽅法⼤部分需要在类中声明，只有需要时才添加到类中。
它们的作⽤、⽅法名称、使⽤的参数列表和返回值都是在PHP中规定好的，并且都是以两个下画线开始的⽅法
名称。如果需要使⽤这些⽅法，⽅法体中的内容需要⽤户⾃⼰按需求编写。每个预定义的⽅法都有它特定的作⽤，
使⽤时不需要⽤户直接调⽤，⽽是在特定的情况下⾃动被调⽤。这⼀节中⽤到的 `__set()`、`__get()`、
`__isset()` 和 `__unset()` 4个⽅法，以及前⾯介绍过的构造⽅法 `__construct()` 和析构⽅法
`__destruct()` 都是这样的⽅法，通常也称为魔术⽅法。    

⼀般来说，把类中的成员属性都定义为私有的，这更符合现实的逻辑，能够更好地对类中的成员起到保护作⽤。
但是，对成员属性的读取和赋值操作是⾮常频繁的，⽽如果在类中为每个私有的属性都定义可以在对象的外部
获取和赋值的公有⽅法，又是⾮常烦琐的。因此，在 PHP5.1.0 以后的版本中，预定义了两个⽅法 `__get()`
和 `__set()`，⽤来完成对所⽤私有属性都能获取和赋值的操作，以及⽤来检查私有属性是否存在的⽅法
`__isset()` 和⽤来删除对象中私有属性的⽅法 `__unset()`。    

`__set()` 可以在对象外部为私有的成员属性赋值。`void __set(string name, mixed value)`。
这个⽅法是在⽤户值为私有属性设置值时⾃动调⽤的。    

`mixed __get(string name)` 该⽅法的作⽤是在程序运⾏过程中，通过它可以在对象的外部获取私有
成员属性的值。    

`bool __isset(string name)` 在类外部使⽤ `isset()` 函数来测定对象⾥⾯的私有属性时，就会⾃
动调⽤类⾥⾯的 `__isset()` ⽅法帮助我们完成测定的操作。    

`void __unset(string name)` 如果对象中的成员属性被封装，就需要在类中添加 `__unset()` ⽅法，
才可以在对象的外部使⽤ `unset()` 函数直接删除对象中的私有成员属性时，⾃动调⽤对象中的 `__unset()`
⽅法帮助我们间接地将私有的成员属性删除。    

## 11.5 继承性

```php
class Student extends Person {
  // ...
}
```   

### 11.5.2 访问类型控制


n | private | protected | public
---------|----------|---------|---------
 同一个类中 | ok | ok | ok
 类的子类中 | no | ok | ok
 所有的外部成员 | no | no | yes

### 11.5.3 子类中重载父类的方法

在PHP中，提供了在⼦类重载的⽅法中调⽤⽗类中被覆盖⽅法的功能。这样就可以在⼦类重写的⽅法中继续
使⽤从⽗类中继承过来并被覆盖的⽅法，然后再按要求多添加⼀些新功能。调⽤的格式是使⽤ `parent::⽅法名`
在⼦类的重载⽅法中调⽤⽗类中被它覆盖的⽅法。将上例中的代码修改⼀下，在⼦类重写的构造⽅法中使⽤
`parent::__construct()` 调⽤⽗类中被覆盖的构造⽅法。    

另外，在⼦类覆盖⽗类的⽅法时⼀定要注意，在⼦类中重写的⽅法的访问权限⼀定不能低于⽗类被覆盖的⽅法
的访问权限。例如，如果⽗类中的⽅法的访问权限是 `protected`，那么在⼦类中重写的⽅法的权限就要是
`protected` 或 `public`。如果⽗类的⽅法是 `public` 权限，⼦类中要重写的⽅法只能是 `public`。
总之，在⼦类中重写⽗类的⽅法时，⼀定要⾼于或等于⽗类被覆盖的⽅法的访问权限。    

## 11.6 常见的关键字和魔术方法

在PHP 5的⾯向对象程序设计中提供了⼀些常见的关键字，⽤来修饰类、成员属性和成员⽅法，使它们具有特
定的功能，例如 final、static、const等关键字。还有⼀些⽐较适⽤的魔术⽅法，⽤来提⾼类或对象的应
⽤能⼒，例如 `__call()`、`__toString()`、`__autoload()` 等。    

`final` 关键字可以加在类或类中的⽅法前。但不能使⽤ `final` 标识成员属性。final关键字的作⽤如下:   

- 使⽤ `final` 标识的类，不能被继承
- 在类中使⽤ `final` 标识的成员⽅法，在⼦类中不能被覆盖

使⽤ `static` 关键字可以将类中的成员标识为静态的，既可以⽤来标识成员属性，也可以⽤来标识成员
⽅法。static 成员作为整个类的属性存在。static 成员总是唯⼀存在的，在多个对象之间共享的。因
为使⽤ `static` 标识的成员是属于类的，所以与对象实例和其他的类⽆关。类中的静态成员是不需要对
象⽽使⽤类名来直接访问的。`className::staticMember`。    

在类中声明的成员⽅法中，也可以使⽤关键字 `self` 来访问其他静态成员。因为静态成员是属于类的，
⽽不属于任何对象，所以不能⽤ `$this` 来引⽤它，⽽在PHP中给我们提供的 `self` 关键字，就是在类
的成员⽅法中⽤来代表本类的关键字。注意没有变量 $ 前缀符。   

另外，在使⽤静态⽅法时需要注意，在静态⽅法中只能访问静态成员。因为⾮静态的成员必须通过对象的引⽤
才能访问，通常是使⽤ `$this` 完成的。⽽静态的⽅法在对象不存在的情况下也可以直接使⽤类名来访问，
没有对象也就没有 `$this` 引⽤，没有了 `$this` 引⽤就不能访问类中的⾮静态成员，但是可以使⽤
类名或 `self` 在⾮静态⽅法中访问静态成员。   

在PHP中定义常量是通过调⽤ `define()` 函数来完成的，但要将类中的成员属性定义为常量，则只能使⽤
`const` 关键字。将类中的成员属性使⽤ `const` 关键字标识为常量，其访问的⽅式和静态成员⼀样，
都是通过类名或在成员⽅法中使⽤ `self` 关键字访问，也不能⽤对象来访问。标识为常量的属性是只读的，
不能重新赋值。使⽤ `const` 声明的常量名称前不要使⽤“$”符号，⽽且常量名称通常都是⼤写的。   

### 11.6.6 克隆对象

在 PHP5 中使⽤ `clone` 关键字克隆对象。   

```php
$p1 = new Person;
$p2 = clone $p1;
```    

如果需要对克隆后的副本对象在克隆时重新为成员属性赋初值，则可以在类中声明⼀个魔术⽅法 `__clone()`。
该⽅法是在对象克隆时⾃动调⽤的，所以就可以通过此⽅法对克隆后的副本重新初始化。`__clone()` ⽅法
不需要任何参数，该⽅法中⾃动包含 `$this` 对象的引⽤，`$this` 是副本对象的引⽤。   

### 11.6.8 __call()

如果尝试调⽤对象中不存在的⽅法，⼀定会出现系统报错，并退出程序不能继续执⾏。在 PHP 中，可以在类
中添加⼀个“魔术”⽅法 `__call()`，则调⽤对象中不存在的⽅法时就会⾃动调⽤该⽅法，并且程序也可以
继续向下执⾏。`__call()` ⽅法需要两个参数：第⼀个参数是调⽤不存在的⽅法时，接收这个⽅法名称
字符串；⽽参数列表则以数组的形式传递到 `__call()` ⽅法的第⼆个参数中。     

### 11.6.9 自动加载类

PHP 提供了类的⾃动加载功能，这样可以节省编程的时间。当你尝试使⽤⼀个 PHP 没有组织到的类时，
它会寻找⼀个名为 `__autoload()` 的全局函数（不是在类中声明的函数）。如果存在这个函数，PHP
会⽤⼀个参数来调⽤它，参数即类的名称。    

## 11.7 抽象类与接口

抽象类和接口相似，都是⼀种⽐较特殊的类。抽象类是⼀种特殊的类，⽽接口也是⼀种特殊的抽象类。   

### 11.7.1 抽象类

抽象⽅法就是没有⽅法体的⽅法，所谓没有⽅法体是指在⽅法声明时没有花括号及其中的内容，⽽是在声明⽅
法时直接在⽅法名后加上分号结束。另外，在声明抽象⽅法时，还要使⽤关键字abstract来修饰：   

```php
abstract function fun1();
```   

只要在声明类时有⼀个⽅法是抽象⽅法，那么这个类就是抽象类，抽象类也要使⽤ `abstract` 关键字来修饰。
在抽象类中可以有不是抽象的成员⽅法和成员属性，但访问权限不能使⽤ `private` 关键字修饰为私有的。    

也就是说抽象类提供的所有非抽象方法和属性都必须能被子类继承。   

在抽象类中有没有被实现的抽象⽅法，所以抽象类是不能被实例化的，即创建不了对象，也就不能直接使⽤它。
当⼦类继承抽象类以后，就必须把抽象类中的抽象⽅法按照⼦类⾃⼰的需要去实现。⼦类必须把⽗类中的抽象
⽅法全部实现，否则⼦类中还存在抽象⽅法，所以还是抽象类，也不能实例化对象。    

### 11.7.2 接口技术

因为 PHP 只⽀持单继承，也就是说每个类只能继承⼀个⽗类。当声明的新类继承抽象类实现模板以后，它就
不能再有其他⽗类了。为了解决这个问题，PHP引⼊了接口。接口是⼀种特殊的抽象类，⽽抽象类又是⼀种特
殊的类，所以接口也是⼀种特殊的类。如果抽象类中的所有⽅法都是抽象⽅法，那么我们就可以换另外⼀种
声明⽅式——使⽤“接口”技术。接口中声明的⽅法必须都是抽象⽅法，另外不能在接口中声明变量，只能使⽤
`const` 关键字声明为常量的成员属性，⽽且接口中的所有成员都必须有public的访问权限。类的声明是
使⽤ `class` 关键字标识的，⽽接口的声明则是使⽤ `interface` 关键字标识的。    

```php
interface interfaceName {
  // 常量成员
  // 抽象方法
}
```    

可以使⽤ `extends` 关键字让⼀个接口去继承另⼀个接口，实现接口之间的扩展。    

通过类去继承接口时需要使⽤ `implements` 关键字来实现，⽽并不是使⽤ `extends` 关键字完成。
如果需要使⽤抽象类去实现接口中的部分⽅法，也需要使⽤ `implements` 关键字实现。    

⼀个类可以实现多个接口。将要实现的多个接口之间使⽤逗号分隔开，⽽且在⼦类中要将所有接口中的抽象⽅
法全部实现才可以创建对象。    

