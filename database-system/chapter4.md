# 第 4 章 中级 SQL

## 4.1 连接表达式

除了自然连接之外，SQL 提供了连接运算的其他形式，包括能够指定显示的**连接谓词**，能够在结果
中包含被**自然连接**排除在外的元祖。       

### 4.1.1 连接条件

前面介绍了 **join ... using**子句，它是一种自然连接的形式，只需要在指定属性上的取值匹配。SQL
支持另外一种形式的连接，其中可以指定任意的连接条件。    

说的其实很清楚了，我们要连接两个元祖，是可以指定一些条件的，不然的话就是笛卡尔积的形式了，
自然连接和上面的 using 子句都是指定两个元祖的一些属性的取值相等的连接起来。而下面的 on
条件则像 where 子句一样，可以随意限定连接的条件。    

**on** 条件允许在参与连接的关系上设置通用的谓词。该谓词的写法与**where**子句谓词类似，只不过
使用的是关键词**on**而不是**where**。与**using**条件一样，**on**条件出现在表达式的末尾。     

```sql
select *
from student join takes on student.ID = takes.ID
```     

### 4.1.2 外连接

实际上有三种形式的外链接：

+ **左外连接**只保留出现在**左外连接**运算左边的关系中的元祖
+ **右外连接**只保留出现在**右外连接**运算右边的关系中的元祖
+ **全外连接**保留出现在两个关系中的元祖。    

```sql
select *
from student natural left outer join takes
```     

全外连接是左外连接与右外连接类型的组合。在内连接结果计算出来之后，左侧关系中不匹配右侧关系任何
元祖的元祖被填上空值并加到结果中。类似地，右侧关系中不匹配左侧关系任何元祖的元祖被填上空值
并加到结果中。       

### 4.1.3 连接类型和条件

为了把常规连接和外连接区分开来，SQL 中把常规连接称作**内连接**。这样连接子句就可以用 **inner join**
来替换**outer join**，说明使用的是常规连接。然而关键词**inner**是可选的。     

下表中给出了所有连接类型的列表，任意的连接形式可以和任意的连接条件进行组合。    


连接类型 | 连接条件
---------|----------
 inner join | natural
 left outer join | on &lt;predicate&gt;
 right outer join | using(A1, A2, ...An)
 full outer join | 

## 4.2 视图

SQL 允许通过查询来定义“虚关系”，它在概念上包含查询的结果。虚关系并不预先计算并存储，而是在使用
虚关系的时候才通过执行查询被计算出来。     

任何像这种不是逻辑模型的一部分。但作为虚关系对用户可见的关系称为**视图**。在任何给定的实际关系
集合上能支持大量视图。    

### 4.2.1 视图定义

我们在 SQL 中用 **create view** 命令来定义视图。为了定义视图，我们必须给视图一个名称，并且
必须提供计算视图的查询。     

```sql
create view view_name as <query expression>
```     

数据库系统存储与视图关系相关联的查询表达式。当视图关系被访问时，其中的元祖是通过计算查询结果而被
创建出来的。从而，视图关系只在需要的时候才被创建。      

### 4.2.2 SQL 查询中使用视图

一旦定义了一个视图，我们就可以用视图名指代该视图生成的虚关系。在查询中，视图名可以出现在关系中
可以出现的任何地方。     

视图的属性名可以按下述方式指定：   

```sql
create view department_total_salary (dept_name, total_salary) as
select dept_name, sum(salary)
from instructor
group by dept_name;
```    

视图通常这样来实现：当我们定义一个视图时，数据库系统存储视图的定义本身，而不存储定义该视图的查询表达式
的执行结果。一旦视图关系出现在查询中，它就被已存储的查询表达式代替。因此，无论我们何时执行这个查询，
视图关系都被重新计算。     

### 4.2.3 物化视图

特定数据库系统允许存储视图关系，但他们保证：如果用于定义视图的实际关系改变，视图也跟着修改。这样的
视图被称为**物化视图**。     

保持物化视图一直在最新状态的过程称为**物化视图维护**，或者通常简称**视图维护**。当构成视图定义
的任何关系被更新时，可以马上进行视图维护。然而某些数据库系统在视图被访问时才进行视图维护。还有一些
系统仅采用周期性的物化视图更新方式，在这种情况下，当物化视图被使用时，其中的内容可能是陈旧的。      

### 4.2.4 视图更新

一般不允许对视图关系进行修改。一般说来，如果定义视图的查询对下列条件都能满足，我们称视图是
**可更新的**：    

+ **from** 子句只有一个数据库关系
+ **select** 子句中只包含关系的属性名，不包含任何表达式、聚集或**distinct**声明。
+ 任何没有出现在**select**子句中的属性可以取空值
+ 查询中不含有 **group by** 或 **having**子句     

可以通过在视图定义的末尾包含**with check option**子句的方式来定义视图。这样，如果向视图中插入
一条不满足视图的 **where**子句条件的元祖，数据库系统将拒绝该插入操作。类似地，如果新值不满足
**where** 子句的条件，更新也会被拒绝。       

## 4.3 事务

事务由查询和（或）更新语句的序列造成。SQL 标准规定当一条 SQL 语句被执行，就隐式地开始了一个事务。下列
SQL 语句之一会结束一个事务：    

+ **Commit work**: 提交当前事务，也就是将该事务所做的更新在数据库中持久保存。在事务被提交后，
一个新的事务自动开始。
+ **Rollback work**: 回滚当前事务，即撤销该事务中所有 SQL 语句对数据库的更新。这样，数据库就
恢复到执行该事务第一条语句之前的状态。     

在很多 SQL 实现中，默认方式下每个SQL语句自成一个事务，且一执行完就提交。如果一个事务要执行多条
SQL 语句，就必须关闭单独 SQL 语句的自动提交。     

一个较好的选择是，作为SQL:1999 标准的一部分，允许多条SQL 语句包含在关键字**begin atomic ... end**之间。     

## 4.4 完整性约束

完整性约束保证授权用户对数据库所做的修改不会破坏数据的一致性。因此，完整性约束防止的是对数据的以外破坏。     

完整性约束通常被看成是数据库模式设计过程的一部分，它作为用于创建关系的 **create table** 命令的一部分
被声明。     

### 4.4.1 单个关系上的约束    

除了主码约束之外，还有许多其他可以包括在 **create table** 命令中的约束。允许的完整性约束包括：

+ **not null**
+ **unique**
+ **check**(&lt;谓词&gt;)     

### 4.4.3 unique 约束

SQL 支持下面这种完整性约束：    

`unique(A1, A2, ... An)`     

**unique**声明指出属性 A1, A2...An 形成了一个候选码，即在关系中没有两个原则能在所有列出的属性上
取值相同。然而候选码属性可以为 null，除非它们已被显示地声明为 not null。      

### 4.4.4 check 子句

当应用于关系声明时，**check**(P)子句指定一个谓词P，关系中的每个元祖都必须满足谓词 P。     

```sql
create table section
(
  course_id varchar(8),
  sec_id varchar (8),
  year numeric(4,0),
  semester varchar(6),
  primary key (course_id, sec_id, year, semester),
  check (semester in ('Spring', 'Summer', 'Fall', 'Winter'))
)
```     

### 4.4.5 参照完整性

我们常常希望保证在一个关系中给定属性集上的取值也在另一个关系的特定属性值的取值中出现，这种情况
称为参照完整性。    

令关系 r1 和 r2 的属性集分别为 R1 和 R2，主码分别为 K1 和 K2。如果要求对 r2 中任意元祖 t2，
均存在 r1 中元祖 t1 使得 t1 * K1 = t2 * α，我们称 R2 的子集α为参照关系r1 中 K1 的外码。    

这种要求称为**参照完整性约束**或**子集依赖**。后一种称法是由于上述参照完整性可以表示为
这样一种要求：r2 中 α 上的取值集合必须是 r1 中 K1 上的取值集合的子集。请注意，为使参照完整性
约束有意义，α和 K1 必须是相容的属性集；也就是说，要么 α等于 K1，要么它们必须包含相同数目的属性，
并且对应属性的类型必须相容。不同于外码约束，参照完整性约束通常不要求 K1 是 r1 的主码；
其结果是，r1 中可能有不止一个元祖在属性 K1 上取值相同。     

这就尴尬了，现在貌似 SQL 实现的都是外码约束，而不是参照完整性约束，也就是说 K1 是不是主码的区别。     

默认情况下，SQL 中外码参照的是被参照表中的主码属性。SQL 还支持一个可以显示指定被参照关系的属性列表
的**references**子句。然而，这个指定的属性列表必须声明为被参照关系的候选码，要么使用 **primary key**
约束，要么使用 **unique**约束。  

我们可以使用如下的简写形式作为属性定义的一部分，并声明该属性为外码：    

`dept_name varchar(20) references department`    

话说这种写法意思是参照了 department 表的 dept_name 属性是吧。那这种简写只适合外码是一个单一属性的吧。
多属性还是得写成外码约束。      

当违反参照完整性约束时，通常的处理时拒绝执行导致完整性破坏的操作。但是，在**foreign key**子句
中可以指明：如果被参照关系上的删除或更新动作违反了约束，那么系统必须采取一些步骤通过修改参照关系中的元祖来
恢复完整性约束，而不是拒绝这样的操作。    

```sql
create table course
(
  ...
  foreign key (dept_name) references department
  on delete cascade
  on update cascade,
)
```     

由于有了与外码声明相关联的 **on delete cascade** 子句，如果删除 department 中的元祖导致了
此参照完整性约束被违反，则删除并不被系统拒绝，而是对 course 关系做级联删除，即删除参照了被删除
系的元祖。类似地，如果更新被参照字段时违反了约束，则更新操作并不被系统拒绝，而是将 course 中
参照的元祖的 dept_name 字段也改为新值。SQL 还允许 foreign key 子句指明除 cascade 以外的其他
动作，如果约束被违反：可将参照域置为 null（用 **set null**代替 **cascade**），或者置为
域的默认值（用 **set default**）。      

### 4.4.6 事务中对完整性约束的违反

事务可能包括几个步骤，在某一步之后完整性约束也许会暂时被违反，但是后面的某一步也许就会消除这个违反。    

为了处理这样的情况，SQL 标准允许将 **initially deferred** 子句加入到约束声明中；这样完整性约束
不是在事务的中间步骤上检查，而是在事务结束的时候检查。对于声明为可延迟的约束，执行**set constraints constraint-list deferred**
语句作为事务的一部分，会导致对指定约束的检查被延迟到该事务结束时执行。       

## 4.5 SQL 的数据类型与模式

在第 3 章中，我们介绍了一些 SQL 支持的固有数据类型，如整数类型、实数类型和字符类型。SQL 还支持一些
其他1的固有数据类型，我们将在下面描述。我们还将描述如何在 SQL 中创建基本的用户定义类型。    

### 4.5.1 SQL 的日期和时间类型

SQL 标准支持与日期和时间相关的几种数据类型：     

+ **date**：日历日期，包括年（四位）、月和日
+ **time**：一天中的时间，包括小时、分和秒。可以用变量 **time(p)** 来表示秒的小数点后的数字
位数（这里默认值为0）。通过指定 **time with timezone**，还可以把时区信息连同时间一起存储。    
+ **timestamp**: date 和 time 的组合。可以用变量 **timestamp(p)** 来表示秒的小数点后的数字
位数（这里默认值为6），如果指定**with timezone**，则时区信息也会被存储。      

日期和时间类型的值可按如下方式说明：    

```
date '2001-04-25'
time '09:30:00'
timestamp '2001-04-25 10:29:01.45'
```     

话说上面不是说 timestamp 小数点后默认是6位数嘛，在逗我？      

我们可以使用 **cast e as t** 形式的表达式来将一个字符串 e 转换成类型 t，其中 t 是 date,
time, timestamp 中的一种。字符串必须符合正确的格式。     

我们可以利用 **extract (field from d)**，从 **date** 或 **time** 值 d 中提取出单独的域，这里的域
可以是**year, month, day, hour, minute, second** 中的任意一种。时区信息可以用 **timezone_hour**
和**timezone_minute**来提取。     

SQL 定义了一些函数以获取当前日期和时间。例如，**current_date** 返回当前日期，**current_time**
返回当前时间（带时区），还有**localtime**返回当前的本地时间。时间戳由 **current_timestamp**
和**local_timestamp** 返回。      

SQL 允许在上面列出的所有类型上进行比较运算，也允许在各种数字类型上进行算术运算和比较运算。
SQL 还支持 **interval**数据类型，它允许在日期、时间和时间间隔上进行计算。       

### 4.5.2 默认值

SQL 允许为属性指定默认值：    

```sql
create table student
(
  ID varchar(5),
  name varchar(20) not null,
  dept_name varchar(20),
  tot_cred numeric(3,0) default 0,
  primary key(ID)
)
```     

### 4.5.3 创建索引

在关系的属性上所创建的索引是一种数据结构，它允许数据库系统高效地找到关系中那些在索引属性上
取给定值的元祖，而不用扫描关系中的所有元祖。索引也可以建立在一个属性列表上。       

```sql
create index studentID_index on student(ID)
```     

如果用户提交的 SQL 查询能从索引使用中获益，那么SQL 查询处理器就会自动使用索引。     

### 4.5.4 大对象类型

SQL 提供字符数据的大对象数据类型（clob）和二进制数据大对象数据类型（blob）。     

### 4.5.6 create table 的扩展

应用常常要求创建与现有的某个表的模式相同的表。SQL 提供了一个 **create table like**的扩展来
支持这项任务：    

`create table temp_instructor like instructor`       

当书写一个复杂查询时，把查询的结果存储成一个新表通常是很有用的；这个表是临时的。这里需要
两条语句，一条用于创建表，另一条用于把查询结果插入到表中。SQL：2003 提供了一种更简单的技术
来创建包含查询结果的表。    

```sql
create table t1 as
(
  select *
  from instructor
  where dept_name = 'Music'
)
with data;
```      

通过在关系名后面列出列名，可以给列显示指派名字。      

### 4.5.7 模式、目录与环境

当代数据库系统提供了三层结构的关系命名机制。最顶层由**目录**(catalog)构成，每个目录都可以
包括**模式**(schema)。诸如关系和视图那样的 SQL 对象都包含在模式中，一些数据库实现用术语“数据库”
代替术语目录。      

要在数据库上做任何操作，用户必须先连接到数据库，为了验证用户身份，用户必须提供用户名及密码。
每个用户都有一个默认的目录和模式，这个组合对用户来说是唯一的。当一个用户连接到数据库系统时，
将为该连接设置好默认的目录和模式。      

我们可以用 **create schema** 和 **drop schema** 语句来创建和删除模式。在大多数数据库系统中，模式
还随着用户账户的创建而自动创建，此时模式名被置为用户账户名。模式要么建立在默认目录中，要么
建立在创建用户账户时所指定的目录中。     

## 4.6 授权

除了在数据上的授权之外，用户还可以被授予在数据库模式上的权限，例如，可以允许用户创建、修改或删除
关系。拥有某些形式的权限的用户还可以把这样的权限转授给其他用户，或者撤销（收回）一种此前授出
的权限。     

最大的授权形式是被授予数据库管理员的。数据库管理员可以授权新用户、重构数据库，等等。这种权限
方式和操作系统中的超级用户、管理员或操作员的权限是类似的。      

### 4.6.1 权限的授予与回收

SQL 标准包括 **select, insert, update, delete**权限。**所有权限**(all privileges)可以用作
所有允许权限的简写形式。一个创建了新关系的用户将自动被授予该关系上的所有权限。     

SQL 数据定义语言包括授予与收回权限的命令。**grant**语句用来授予权限。此语句的基本形式为：    

```sql
grant <权限列表>
on <关系或视图名>
to <用户/角色列表>
```      

**update** 权限既可以在关系的所有属性上授予，又可以只在某些属性上授予。如果 grant 语句中
包括 **update** 权限，将被授予 **update** 权限的属性列表可以出现在紧跟关键字 update 的括号中。    

关系上的 **insert** 权限允许用户往关系中插入元祖。**insert**权限也可以指定属性列表；对关系所作
的任何插入必须只针对这些属性，系统将其余属性要么赋默认值，要么赋 null。     

用户名 **public** 指系统的所有当前用户和将来的用户。      

在默认情况下，被授予权限的用户/角色无权把此权限授予其他用户/角色。SQL 允许用授予权限来指定权限的
接受者可以进一步把权限授予其他用户。       

我们使用 **revoke** 语句来收回权限。此语句的形式与 grant 几乎是一样的：    

```sql
revoke <权限列表>
on <关系或视图名>
from <用户/角色列表>
```      

### 4.6.2 角色

任何可以授予给用户的权限都可以授予给角色。在 SQL 中创建角色如下所示：    

`create role instructor`     

角色可以授予给用户，也可以授予给其他角色：   

```sql
grant dean to Amit;
create role dean;
grant instructor to dean;
grant dean to Satoshi;
```    

因此，一个用户或一个角色的权限包括：    

+ 所有直接授予给用户/角色的权限
+ 所有授予给用户/角色所拥有角色的权限       

### 4.6.3 视图的授权

其实针对视图的查询最终还是会转移到对对应的关系上，所以其实最终还是检查关系上的权限。    

创建视图的用户不需要获得该视图上的所有权限。他得到的那些权限不会为他提供超越他已有权限的
额外授权。例如，如果一个创建视图的用户在用来定义视图的关系上没有**update**权限的话，那么它
不能得到视图上的**update**权限。如果用户创建一个视图，而此用户在该视图上不能获得任何权限，系统
会拒绝这样的视图创建请求。       


### 4.6.4 模式的授权

SQL 标准为数据库模式指定了一种基本的授权机制：只有模式的拥有者才能够执行对模式的任何修改，诸如
创建或删除关系，增加或删除关系的属性，以及增加或删除索引。      

然而，SQL 提供了一种 **references** 权限，允许用户在创建关系时声明外码。SQL 的 **references**
权限可以与**update**权限类似的方式授予到特定属性上。下面的**grant**语句允许用户创建这样的关系，
它能够参照 department 关系的码 dept_name:    

`grant references (dept_name) on department to Mariano;`      

初看起来，似乎没有理由不允许用户创建参照了其他关系的外码。但是，回想一下外码约束限制了被参照
关系的删除和更新操作。假定 Mariano 在关系 r 中创建了一个外码，它参照 department 关系的
dept_name 属性，然后在 r 中插入一条属于 Geology 系的元祖。那么就再也不可能从 department 关系中
将 Geology 系删除，除非同时也修改关系 r。这样，Mariano 定义的外码限制了其他用户将来的行为，
因此，需要有 references 权限。      

### 4.6.5 权限的转移

如果我们在授权时允许接受者把得到的权限再传递给其他用户，我们可以在相应的**grant**命令后
附加**with grant option**子句。    

`grant select on department to Amit with grant option`     

一个对象（关系/视图/角色）的创建者拥有该对象上的所有权限，包括给其他用户授权的权限。     

### 4.6.6 权限的收回

从一个用户/角色那里收回权限可能导致其他用户/角色也失去该权限。这一行为称为级联收回。在大多数的
数据库系统中，级联是默认行为，然而，**revoke**语句可以申明**restrict**来防止级联收回。    

`revoke select on department from Amit, Satoshi restrict`     

`revoke grant option for select on department from Amit`    

这条语句仅仅收回 grant option，而并不是真正收回 select 权限。      

