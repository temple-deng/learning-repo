# 第 4 章 中级 SQL

<!-- TOC -->

- [第 4 章 中级 SQL](#第-4-章-中级-sql)
  - [4.1 连接表达式](#41-连接表达式)
    - [4.1.1 连接条件](#411-连接条件)
    - [4.1.2 外连接](#412-外连接)
    - [4.1.3 连接类型和条件](#413-连接类型和条件)
  - [4.2 视图](#42-视图)
    - [4.2.1 视图定义](#421-视图定义)
    - [4.2.2 SQL 查询中使用视图](#422-sql-查询中使用视图)
    - [4.2.3 物化视图](#423-物化视图)
    - [4.2.4 视图更新](#424-视图更新)
  - [4.3 事务](#43-事务)
  - [4.4 完整性约束](#44-完整性约束)
    - [4.4.1 单个关系上的约束](#441-单个关系上的约束)
    - [4.4.3 unique 约束](#443-unique-约束)
    - [4.4.4 check 子句](#444-check-子句)
    - [4.4.5 参照完整性](#445-参照完整性)
    - [4.4.6 事务中对完整性约束的违反](#446-事务中对完整性约束的违反)
  - [4.5 SQL 的数据类型与模式](#45-sql-的数据类型与模式)
    - [4.5.1 SQL 的日期和时间类型](#451-sql-的日期和时间类型)
    - [4.5.2 默认值](#452-默认值)
    - [4.5.3 创建索引](#453-创建索引)
    - [4.5.4 大对象类型](#454-大对象类型)
    - [4.5.5 用户定义的类型](#455-用户定义的类型)
    - [4.5.6 create table 的扩展](#456-create-table-的扩展)
    - [4.5.7 模式、目录与环境](#457-模式目录与环境)
  - [4.6 授权](#46-授权)
    - [4.6.1 权限的授予与回收](#461-权限的授予与回收)
    - [4.6.2 角色](#462-角色)
    - [4.6.3 视图的授权](#463-视图的授权)
    - [4.6.4 模式的授权](#464-模式的授权)
    - [4.6.5 权限的转移](#465-权限的转移)
    - [4.6.6 权限的收回](#466-权限的收回)

<!-- /TOC -->

## 4.1 连接表达式

除了自然连接之外，SQL 提供了连接运算的其他形式，包括能够指定显示的 **连接谓词**，能够在结果
中包含被 **自然连接** 排除在外的元祖。       

### 4.1.1 连接条件

前面介绍了 **join ... using**子句，它是一种自然连接的形式，只需要在指定属性上的取值匹配。SQL
支持另外一种形式的连接，其中可以指定任意的连接条件。    

说的其实很清楚了，我们要连接两个元祖，是可以指定一些条件的，不然的话就是笛卡尔积的形式了，
自然连接和上面的 using 子句都是指定两个元祖的一些属性的取值相等的连接起来。而下面的 on
条件则像 where 子句一样，可以随意限定连接的条件。    

**on** 条件允许在参与连接的关系上设置通用的谓词。该谓词的写法与**where**子句谓词类似，只不过
使用的是关键词**on**而不是**where**。与**using**条件一样，**on**条件出现在表达式的末尾。     

```sql
select *
from student join takes on student.ID = takes.ID
```     

在上例中的连接表达式与连接表达式 `student natural join takes` 几乎是一样的，因为自然连接
运算也需要 student 元组和 takes 元组是匹配的。这两者之间的一个区别在于：在上述连接查询
结果中，ID 属性出现两次，一次是 student 中的，另一次是 takes 中的，即便他们的 ID 属性值
是相同的。   

实际上，上述查询与以下查询是等价的：   

```sql
select *
from student, takes
where student.ID = takes.ID
```    

正如上例所示，使用带 `on` 条件的连接表达式的查询可以用不带 `on` 条件的等价表达式来替换，
只要把 `on` 子句中的谓词移到 `where` 子句中即可。这样看来，`on` 条件似乎是一个冗余的
SQL 特征。    

但是，引入 `on` 条件有两个优点。首先，对于我们马上要介绍的，被称作外连接的这类连接来说，
`on` 条件的表现与 `where` 条件是不同的。其次，如果在 `on` 子句中指定连接条件，并在 `where`
子句中出现其余的条件，这样的 SQL 查询通常更容易让人读懂。    

因此，其实和标题一致，`on` 其实是用来在连接表达式中指定两个关系之间的连接条件的。    

### 4.1.2 外连接

**外连接** 运算与我们之前学过的连接运算类似，但通过在结果中创建包含空值元组的方式，保留了
那些在连接中丢失的元组。   

例如，为了保证在我们前例中的名为 Snow 的学生出现在结果中，可以在连接结果中加入一个元组，
它在来自 student 关系的所有属性上的值都被设置为学生 Snow 的相应值，在所有余下的来自 takes
关系属性上的值被设为 null，这些属性是 course_id, sec_id, semester 和 year。   

实际上有三种形式的外连接：

+ **左外连接**只保留出现在**左外连接**运算左边的关系中的元祖
+ **右外连接**只保留出现在**右外连接**运算右边的关系中的元祖
+ **全外连接**保留出现在两个关系中的元祖。    

相比而言，为了和外连接运算相区分，我们此前学习的不保留未匹配元组的连接运算被称作 **内连接**
运算。   

我们现在详细解释每种形式的外连接是怎样操作的。我们可以按照如下方式计算左外连接运算：首先，
像前面那样计算出内连接的结果；然后，对于在内连接的左侧关系中任意一个与右侧关系中任何元组
都不匹配的元组 t，向连接结果中加入一个元组 r，r 的构造如下：    

+ 元组 r 从左侧关系得到的属性被赋为 t 中的值。
+ r 的其他属性被赋为空值。    

```sql
select *
from student natural left outer join takes
```     

那这个表达式其实揭露了两点内容，首先是自然连接，那相当于有 `student.ID = takes.ID` 的
连接条件，其次是外连接，左边的不匹配元组在加入结果中。   

**右外连接** 和 **左外连接** 是对称的。来自右侧关系中的不匹配左侧关系任何元组的元组被
补上空值，并加入到右外连接的结果中。   

全外连接是左外连接与右外连接类型的组合。在内连接结果计算出来之后，左侧关系中不匹配右侧关系任何
元祖的元祖被填上空值并加到结果中。类似地，右侧关系中不匹配左侧关系任何元祖的元祖被填上空值
并加到结果中。       

### 4.1.3 连接类型和条件

为了把常规连接和外连接区分开来，SQL 中把常规连接称作**内连接**。这样连接子句就可以用 **inner join**
来替换**outer join**，说明使用的是常规连接。然而关键词**inner**是可选的。     

下表中给出了所有连接类型的列表，任意的连接形式可以和任意的连接条件进行组合。    

连接类型指明了，结果中不匹配的元组是否要出现，连接条件指明了两个关系中的元组使用怎样的
规则来匹配。   

连接类型 | 连接条件
---------|----------
 inner join | natural
 left outer join | on &lt;predicate&gt;
 right outer join | using(A1, A2, ...An)
 full outer join | 

## 4.2 视图

在上面的所有例子中，我们一直都在 **逻辑模型层** 操作，即我们假定了给定的集合中的关系都是
实际存储在数据库中的。    

让所有用户看到整个逻辑模型是不合适的。出于安全考虑，可能需要向用户隐藏特定的数据。   

SQL 允许通过查询来定义“虚关系”，它在概念上包含查询的结果。虚关系并不预先计算并存储，而是在使用
虚关系的时候才通过执行查询被计算出来。     

任何像这种不是逻辑模型的一部分。但作为虚关系对用户可见的关系称为 **视图**。在任何给定的
实际关系集合上能支持大量视图。    

### 4.2.1 视图定义

我们在 SQL 中用 **create view** 命令来定义视图。为了定义视图，我们必须给视图一个名称，并且
必须提供计算视图的查询。     

```sql
create view view_name as <query expression>
```     

数据库系统存储与视图关系相关联的查询表达式。当视图关系被访问时，其中的元祖是通过计算查询结果而被
创建出来的。从而，视图关系只在需要的时候才被创建。      

### 4.2.2 SQL 查询中使用视图

一旦定义了一个视图，我们就可以用视图名指代该视图生成的虚关系。在查询中，视图名可以出现在关系中
可以出现的任何地方。     

视图的属性名可以按下述方式指定：   

```sql
create view department_total_salary (dept_name, total_salary) as
select dept_name, sum(salary)
from instructor
group by dept_name;
```    

视图通常这样来实现：当我们定义一个视图时，数据库系统存储视图的定义本身，而不存储定义该视图的查询表达式
的执行结果。一旦视图关系出现在查询中，它就被已存储的查询表达式代替。因此，无论我们何时执行这个查询，
视图关系都被重新计算。     

### 4.2.3 物化视图

特定数据库系统允许存储视图关系，但他们保证：如果用于定义视图的实际关系改变，视图也跟着修改。这样的
视图被称为 **物化视图**。     

保持物化视图一直在最新状态的过程称为 **物化视图维护**，或者通常简称 **视图维护**。当构成视图定义
的任何关系被更新时，可以马上进行视图维护。然而某些数据库系统在视图被访问时才进行视图维护。还有一些
系统仅采用周期性的物化视图更新方式，在这种情况下，当物化视图被使用时，其中的内容可能是陈旧的。      

### 4.2.4 视图更新

尽管对查询而言，视图是一个有用的工具，但如果我们用它们来表达更新、插入或删除，它们可能带来
严重的问题。困难在于，用视图表达的数据库修改必须被翻译为对数据库逻辑模型中实际关系的修改。   

一般不允许对视图关系进行修改。一般说来，如果定义视图的查询对下列条件都能满足，我们称视图是
**可更新的**：    

+ **from** 子句只有一个数据库关系
+ **select** 子句中只包含关系的属性名，不包含任何表达式、聚集或**distinct**声明。
+ 任何没有出现在**select**子句中的属性可以取空值
+ 查询中不含有 **group by** 或 **having**子句     

可以通过在视图定义的末尾包含**with check option**子句的方式来定义视图。这样，如果向视图中插入
一条不满足视图的 **where**子句条件的元祖，数据库系统将拒绝该插入操作。类似地，如果新值不满足
**where** 子句的条件，更新也会被拒绝。       

## 4.3 事务

事务由查询和（或）更新语句的序列造成。SQL 标准规定当一条 SQL 语句被执行，就隐式地开始了一个事务。下列
SQL 语句之一会结束一个事务：    

+ **Commit work**: 提交当前事务，也就是将该事务所做的更新在数据库中持久保存。在事务被提交后，
一个新的事务自动开始。
+ **Rollback work**: 回滚当前事务，即撤销该事务中所有 SQL 语句对数据库的更新。这样，数据库就
恢复到执行该事务第一条语句之前的状态。     

在某种意义上，事务提交就像对编辑文档的变化存盘，而回滚就像不保存变化退出编辑。一旦某事务
执行了 **commit work**，它的影响就不能用 **rollback work** 来撤销了。数据库系统保证在
发生诸如某条 SQL 语句错误、断电、系统崩溃这些故障的情况下，如果一个事务还没有完成 **commit work**，
其影响将被回滚。在断电和系统崩溃的情况下，回滚会在系统重启后执行。   

在很多 SQL 实现中，默认方式下每个SQL语句自成一个事务，且一执行完就提交。如果一个事务要执行多条
SQL 语句，就必须关闭单独 SQL 语句的自动提交。     

一个较好的选择是，作为SQL:1999 标准的一部分，允许多条SQL 语句包含在关键字**begin atomic ... end**
之间。所有在关键字之间的语句构成了一个单一事务。       

## 4.4 完整性约束

完整性约束保证授权用户对数据库所做的修改不会破坏数据的一致性。因此，完整性约束防止的是对数据的以外破坏。     

完整性约束通常被看成是数据库模式设计过程的一部分，它作为用于创建关系的 **create table** 命令的一部分
被声明。     

### 4.4.1 单个关系上的约束    

除了主码约束之外，还有许多其他可以包括在 **create table** 命令中的约束。允许的完整性约束包括：

+ **not null**
+ **unique**
+ **check**(&lt;谓词&gt;)     

许多情况下我们希望避免空值。尤其是 SQL 禁止在关系模式的主码中出现空值。因此，在我们的大学
例子中，在 department 关系上如果声明属性 dept_name 为 department 的主码，那它就不能为
空。因此它不必显示地声明为 `not null`。   

### 4.4.3 unique 约束

SQL 支持下面这种完整性约束：    

`unique(A1, A2, ... An)`     

**unique** 声明指出属性 A1, A2...An 形成了一个候选码，即在关系中没有两个原则能在所有列出的属性上
取值相同。然而候选码属性可以为 `null`，除非它们已被显示地声明为 `not null`。      

### 4.4.4 check 子句

当应用于关系声明时，**check**(P)子句指定一个谓词P，关系中的每个元祖都必须满足谓词 P。     

```sql
create table section
(
  course_id varchar(8),
  sec_id varchar (8),
  year numeric(4,0),
  semester varchar(6),
  primary key (course_id, sec_id, year, semester),
  check (semester in ('Spring', 'Summer', 'Fall', 'Winter'))
)
```     

### 4.4.5 参照完整性

我们常常希望保证在一个关系中给定属性集上的取值也在另一个关系的特定属性值的取值中出现，这种情况
称为 **参照完整性**。    

令关系 r1 和 r2 的属性集分别为 R1 和 R2，主码分别为 K1 和 K2。如果要求对 r2 中任意元祖 t2，
均存在 r1 中元祖 t1 使得 t1 * K1 = t2 * α，我们称 R2 的子集α为参照关系r1 中 K1 的 **外码**。    

这种要求称为**参照完整性约束**或**子集依赖**。后一种称法是由于上述参照完整性可以表示为
这样一种要求：r2 中 α 上的取值集合必须是 r1 中 K1 上的取值集合的子集。请注意，为使参照完整性
约束有意义，α和 K1 必须是相容的属性集；也就是说，要么 α等于 K1，要么它们必须包含相同数目的属性，
并且对应属性的类型必须相容。不同于外码约束，参照完整性约束通常不要求 K1 是 r1 的主码；
其结果是，r1 中可能有不止一个元祖在属性 K1 上取值相同。     

这就尴尬了，现在貌似 SQL 实现的都是外码约束，而不是参照完整性约束，也就是说 K1 是不是主码的区别。     

默认情况下，SQL 中外码参照的是被参照表中的主码属性。SQL 还支持一个可以显示指定被参照关系的属性列表
的**references**子句。然而，这个指定的属性列表必须声明为被参照关系的候选码，要么使用 **primary key**
约束，要么使用 **unique**约束。  

我们可以使用如下的简写形式作为属性定义的一部分，并声明该属性为外码：    

`dept_name varchar(20) references department`    

话说这种写法意思是参照了 department 表的 dept_name 属性是吧。那这种简写只适合外码是一个单一属性的吧。
多属性还是得写成外码约束。      

当违反参照完整性约束时，通常的处理时拒绝执行导致完整性破坏的操作。但是，在**foreign key**子句
中可以指明：如果被参照关系上的删除或更新动作违反了约束，那么系统必须采取一些步骤通过修改参照关系中的元祖来
恢复完整性约束，而不是拒绝这样的操作。    

```sql
create table course
(
  ...
  foreign key (dept_name) references department
  on delete cascade
  on update cascade,
)
```     

由于有了与外码声明相关联的 **on delete cascade** 子句，如果删除 department 中的元祖导致了
此参照完整性约束被违反，则删除并不被系统拒绝，而是对 course 关系做级联删除，即删除参照了被删除
系的元祖。类似地，如果更新被参照字段时违反了约束，则更新操作并不被系统拒绝，而是将 course 中
参照的元祖的 dept_name 字段也改为新值。SQL 还允许 foreign key 子句指明除 cascade 以外的其他
动作，如果约束被违反：可将参照域置为 null（用 **set null**代替 **cascade**），或者置为
域的默认值（用 **set default**）。      

空值使得 SQL 中参照约束的语义复杂化了。外码中的属性允许为 `null`，只要它们没有被声明为
`not null`。如果给定元组中外码的所有列上均取非空值，则对该元组采用外码约束的通常定义。
如果某外码列为 `null`，则该元组自动被认为满足约束。   

### 4.4.6 事务中对完整性约束的违反

事务可能包括几个步骤，在某一步之后完整性约束也许会暂时被违反，但是后面的某一步也许就会
消除这个违反。例如，假设我们有一个主码为 name 的 person 关系，还有一个属性是 spouse，
并且 spouse 是在 person 上的一个外码。也就是说，约束要求 spouse 属性必须包含在 person
表里出现的名字。假设我们希望在上述关系中插入两个元组，一个是关于 John，另一个是关于 Mary，
这两个元组的配偶属性分配设置为 Mary 和 John，以此表示 John 和 Mary 彼此之间的婚姻关系。
无论先插入哪个元组，插入的第一个元组的时候都会违反外码约束。在插入第二个元组后，外码约束
又会满足了。      

为了处理这样的情况，SQL 标准允许将 **initially deferred** 子句加入到约束声明中；这样完整性约束
不是在事务的中间步骤上检查，而是在事务结束的时候检查。对于声明为可延迟的约束，执行
**set constraints constraint-list deferred** 语句作为事务的一部分，会导致对指定约束
的检查被延迟到该事务结束时执行。       

## 4.5 SQL 的数据类型与模式

在第 3 章中，我们介绍了一些 SQL 支持的固有数据类型，如整数类型、实数类型和字符类型。SQL 还支持一些
其他1的固有数据类型，我们将在下面描述。我们还将描述如何在 SQL 中创建基本的用户定义类型。    

### 4.5.1 SQL 的日期和时间类型

SQL 标准支持与日期和时间相关的几种数据类型：     

+ **date**：日历日期，包括年（四位）、月和日
+ **time**：一天中的时间，包括小时、分和秒。可以用变量 **time(p)** 来表示秒的小数点后的数字
位数（这里默认值为0）。通过指定 **time with timezone**，还可以把时区信息连同时间一起存储。    
+ **timestamp**: date 和 time 的组合。可以用变量 **timestamp(p)** 来表示秒的小数点后的数字
位数（这里默认值为6），如果指定**with timezone**，则时区信息也会被存储。      

日期和时间类型的值可按如下方式说明：    

```
date '2001-04-25'
time '09:30:00'
timestamp '2001-04-25 10:29:01.45'
```     

话说上面不是说 timestamp 小数点后默认是6位数嘛，在逗我？      

我们可以使用 **cast e as t** 形式的表达式来将一个字符串 e 转换成类型 t，其中 t 是 date,
time, timestamp 中的一种。字符串必须符合正确的格式。     

我们可以利用 **extract (field from d)**，从 **date** 或 **time** 值 d 中提取出单独的域，这里的域
可以是**year, month, day, hour, minute, second** 中的任意一种。时区信息可以用 **timezone_hour**
和**timezone_minute**来提取。     

SQL 定义了一些函数以获取当前日期和时间。例如，**current_date** 返回当前日期，**current_time**
返回当前时间（带时区），还有**localtime**返回当前的本地时间。时间戳由 **current_timestamp**
和**local_timestamp** 返回。      

SQL 允许在上面列出的所有类型上进行比较运算，也允许在各种数字类型上进行算术运算和比较运算。
SQL 还支持 **interval**数据类型，它允许在日期、时间和时间间隔上进行计算。       

### 4.5.2 默认值

SQL 允许为属性指定默认值：    

```sql
create table student
(
  ID varchar(5),
  name varchar(20) not null,
  dept_name varchar(20),
  tot_cred numeric(3,0) default 0,
  primary key(ID)
)
```     

### 4.5.3 创建索引

许多查询只涉及文件中的少量记录。例如，像这样的查询“找出 Physics 系的所有教师”，或“找出
ID 为 22201 的学生的 tot_cred 值”，只涉及学生记录中的一小部分。如果系统读取每条记录并
一一检查其 ID 域是否为 22201，或者 dept_name 域是否取值 Physics，这样的方式是很低效的。   

在关系的 **属性** 上所创建的 **索引** 是一种数据结构，它允许数据库系统高效地找到关系中那些在索引属性上
取给定值的元祖，而不用扫描关系中的所有元祖。索引也可以建立在一个属性列表上。（比如 BST?）       

```sql
create index studentID_index on student(ID)
```     

如果用户提交的 SQL 查询能从索引使用中获益，那么SQL 查询处理器就会自动使用索引。     

### 4.5.4 大对象类型

SQL 提供字符数据的大对象数据类型（clob）和二进制数据大对象数据类型（blob）。例如我们可以
声明属性：   

```sql
book_review clob(10KB)
image blob(10MB)
movie blob(2GB)
```    

对于包含大对象的结果元组而言，把整个大对象放入内存中是非常低效和不现实的。相反，一个应用
通常用一个 SQL 查询来检索出一个大对象的“定位器”，然后在宿主语言中用这个定位器来操纵对象。   

### 4.5.5 用户定义的类型

SQL 支持两种形式的用户定义数据类型。第一种称为 **独特类型**，另一种称为 **结构化数据类型**，
允许创建具有嵌套记录结构、数组和多重集的复杂数据类型。    

其实独特类型估计就类似于 Go 中的类型定义，无非是为基础类型添加了语义，更得类型的域的语义
化更强，更好理解。   

可以用 `create type` 子句来定义新类型。    

```sql
create type Dollars as numeric (12, 2) final;
create type Pounds as numeric (12, 2) final;
```    

在此关键字 `final` 并不是真的有意义，它是 SQL:1999 标准要求的。   

```sql
create table department (
  dept_name varchar (20),
  building varchar (15),
  budget Dollars
);
```   

尝试为 Pounds 类型的变量赋予一个 Dollars 类型的值会导致一个编译时错误。   

由于有强类型检查，表达式 `(department.budget + 20)` 将不会被接受，因为属性和整型常数 20
具有不同的类型。一种类型的数值可以被转换到另一个域，如下所示：   

```sql
cast (department.budget to numeric(12, 2))
```    

SQL 提供了 `drop type` 和 `alter type` 子句来删除或修改以前创建过的类型。   

### 4.5.6 create table 的扩展

应用常常要求创建与现有的某个表的模式相同的表。SQL 提供了一个 **create table like**的扩展来
支持这项任务：    

`create table temp_instructor like instructor`       

当书写一个复杂查询时，把查询的结果存储成一个新表通常是很有用的；这个表是临时的。这里需要
两条语句，一条用于创建表，另一条用于把查询结果插入到表中。SQL：2003 提供了一种更简单的技术
来创建包含查询结果的表。    

```sql
create table t1 as
(
  select *
  from instructor
  where dept_name = 'Music'
)
with data;
```      

通过在关系名后面列出列名，可以给列显示指派名字。      

### 4.5.7 模式、目录与环境

跟早期文件系统一样，早期数据库系统也只为所有关系提供一个命名空间。用户不得不相互协调以
保证他们没有对不同的关系使用同样的名字。当代数据库系统提供了三层结构的关系命名机制。
最顶层由**目录**(catalog)构成，每个目录都可以包括**模式**(schema)。诸如关系和视图那样的
SQL 对象都包含在模式中，一些数据库实现用术语“数据库”代替术语目录。    

要在数据库上做任何操作，用户必须先连接到数据库，为了验证用户身份，用户必须提供用户名及密码。
每个用户都有一个默认的目录和模式，这个组合对用户来说是唯一的。当一个用户连接到数据库系统时，
将为该连接设置好默认的目录和模式。      

默认目录和模式是为每个连接建立的 **SQL 环境** 的一部分。环境还包括用户标识符（也称为
授权标识符）。所有通常的 SQL 语句，包括 DDL 和 DML 语句，都在一个模式的环境中运行。   

我们可以用 **create schema** 和 **drop schema** 语句来创建和删除模式。在大多数数据库系统中，模式
还随着用户账户的创建而自动创建，此时模式名被置为用户账户名。模式要么建立在默认目录中，要么
建立在创建用户账户时所指定的目录中。     

## 4.6 授权

除了在数据上的授权之外，用户还可以被授予在数据库模式上的权限，例如，可以允许用户创建、修改或删除
关系。拥有某些形式的权限的用户还可以把这样的权限转授给其他用户，或者撤销（收回）一种此前授出
的权限。     

最大的授权形式是被授予数据库管理员的。数据库管理员可以授权新用户、重构数据库，等等。这种权限
方式和操作系统中的超级用户、管理员或操作员的权限是类似的。      

### 4.6.1 权限的授予与回收

SQL 标准包括 **select, insert, update, delete**权限。**所有权限**(all privileges)可以用作
所有允许权限的简写形式。一个创建了新关系的用户将自动被授予该关系上的所有权限。     

SQL 数据定义语言包括授予与收回权限的命令。**grant**语句用来授予权限。此语句的基本形式为：    

```sql
grant <权限列表>
on <关系或视图名>
to <用户/角色列表>
```      

```sql
grant select on department to Amit, Satoshi
```    

**update** 权限既可以在关系的所有属性上授予，又可以只在某些属性上授予。如果 grant 语句中
包括 **update** 权限，将被授予 **update** 权限的属性列表可以出现在紧跟关键字 update 的括号中。    

```sql
grant update (budget) on department to Amit, Satoshi
```   

关系上的 **insert** 权限允许用户往关系中插入元祖。**insert**权限也可以指定属性列表；对关系所作
的任何插入必须只针对这些属性，系统将其余属性要么赋默认值，要么赋 null。     

用户名 **public** 指系统的所有当前用户和将来的用户。      

在默认情况下，被授予权限的用户/角色无权把此权限授予其他用户/角色。SQL 允许用授予权限来指定权限的
接受者可以进一步把权限授予其他用户。       

我们使用 **revoke** 语句来收回权限。此语句的形式与 grant 几乎是一样的：    

```sql
revoke <权限列表>
on <关系或视图名>
from <用户/角色列表>
```      

### 4.6.2 角色

任何可以授予给用户的权限都可以授予给角色。在 SQL 中创建角色如下所示：    

`create role instructor`     

角色可以授予给用户，也可以授予给其他角色：   

```sql
grant dean to Amit;
create role dean;
grant instructor to dean;
grant dean to Satoshi;
```    

因此，一个用户或一个角色的权限包括：    

+ 所有直接授予给用户/角色的权限
+ 所有授予给用户/角色所拥有角色的权限       

### 4.6.3 视图的授权

其实针对视图的查询最终还是会转移到对对应的关系上，所以其实最终还是检查关系上的权限。    

创建视图的用户不需要获得该视图上的所有权限。他得到的那些权限不会为他提供超越他已有权限的
额外授权。例如，如果一个创建视图的用户在用来定义视图的关系上没有**update**权限的话，那么它
不能得到视图上的**update**权限。如果用户创建一个视图，而此用户在该视图上不能获得任何权限，系统
会拒绝这样的视图创建请求。       


### 4.6.4 模式的授权

SQL 标准为数据库模式指定了一种基本的授权机制：只有模式的拥有者才能够执行对模式的任何修改，诸如
创建或删除关系，增加或删除关系的属性，以及增加或删除索引。      

然而，SQL 提供了一种 **references** 权限，允许用户在创建关系时声明外码。SQL 的 **references**
权限可以与**update**权限类似的方式授予到特定属性上。下面的**grant**语句允许用户创建这样的关系，
它能够参照 department 关系的码 dept_name:    

`grant references (dept_name) on department to Mariano;`      

初看起来，似乎没有理由不允许用户创建参照了其他关系的外码。但是，回想一下外码约束限制了被参照
关系的删除和更新操作。假定 Mariano 在关系 r 中创建了一个外码，它参照 department 关系的
dept_name 属性，然后在 r 中插入一条属于 Geology 系的元祖。那么就再也不可能从 department 关系中
将 Geology 系删除，除非同时也修改关系 r。这样，Mariano 定义的外码限制了其他用户将来的行为，
因此，需要有 references 权限。      

### 4.6.5 权限的转移

如果我们在授权时允许接受者把得到的权限再传递给其他用户，我们可以在相应的**grant**命令后
附加**with grant option**子句。    

`grant select on department to Amit with grant option`     

一个对象（关系/视图/角色）的创建者拥有该对象上的所有权限，包括给其他用户授权的权限。     

### 4.6.6 权限的收回

从一个用户/角色那里收回权限可能导致其他用户/角色也失去该权限。这一行为称为级联收回。在大多数的
数据库系统中，级联是默认行为，然而，**revoke**语句可以申明**restrict**来防止级联收回。    

`revoke select on department from Amit, Satoshi restrict`     

`revoke grant option for select on department from Amit`    

这条语句仅仅收回 grant option，而并不是真正收回 select 权限。      

