# 数值精度及范围

## 数值精度

根据国际标准IEEE 754，JavaScript浮点数的64个二进制位，从最左边开始，是这样组成的。

+ 第1位：符号位，0表示正数，1表示负数
+ 第2位到第12位：储存指数部分
+ 第13位到第64位：储存小数部分（即有效数字）  

符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。  

IEEE 754规定，有效数字第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字总是1.xx...xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript提供的有效数字最长为53个二进制位。

(-1)^符号位 * 1.xx...xx * 2^指数位

上面公式是一个数在JavaScript内部实际的表现形式。

精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-(253-1)到253-1，都可以精确表示。   

![浮点数表示](https://segmentfault.com/image?src=https://ommw6ejay.qnssl.com/IEEE754_floating.jpg&objectId=1190000009084877&token=6dbb2ef31ffd33e204d811f766ace61a)

由于指数也不一定都是整数，也可能有负数，这里 IEEE754 采取的方式是，设置一个偏移量，使指数部分永远表现为一个非负数，然后减去某个偏移值才是真实的指数，这样做的好处是可以表现一些极端值。64bit的浮点数设置的偏移值是1023，因为指数域表现为一个非负数，11位，所以 0<= e < 2^11-1，实际的E=e-1023，所以 -1023<=E<=2014.  

对于二进制的科学计数法，如果保持小数点前必须有1位非0的，那有效域是不是必然是1.XXXX的形式？而这样子的二进制被称为规格化的，这样的二进制在存储时，小数点前的1是默认存在，但是默认不占坑的，尾数部分就存储小数点后的部分。  

如果这个二进制小数太小了，那么会出现什么情况呢？对于一个接近于0的二进制小数，一味追求1.xxx的形式，必然导致指数部分会向负无穷靠拢，而真实的指数部分最小也就能表示-1023，一旦把指数部分逼到了-1023，还没有到1.xxx的形式，那么只能用0.xxx的形式表示有效部分，这样的二进制浮点数表示非规格化的。  

所有数值的计算和比较，都是这样以64个bit的形式来进行的。


# 数值范围

根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则JavaScript能够表示的数值范围为21024到2-1023（开区间），超出这个范围的数无法表示。

如果指数部分等于或超过最大正值1024，JavaScript会返回Infinity（关于Infinity的介绍参见下文），这称为“正向溢出”；如果等于或超过最小负值-1023（即非常接近0），JavaScript会直接把这个数转为0，这称为“负向溢出”。
