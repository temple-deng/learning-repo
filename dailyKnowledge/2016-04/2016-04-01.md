# 2016-04-01
---
	1.TLS/SSL协议（阮一峰http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html）
---

###  1.TLS/SSL
基本的运行过程：SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。

（1）如何保证公钥不被篡改？:解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。

（2）公钥加密计算量太大，如何减少耗用的时间？解决方法：每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。

整个流程
1.客户端发出请求（ClientHello）
```
	
    （1） 支持的协议版本，比如TLS 1.0版。

    （2） 一个客户端生成的随机数，稍后用于生成"对话密钥"。

    （3） 支持的加密方法，比如RSA公钥加密。

    （4） 支持的压缩方法。

```

2.服务器回应（SeverHello）
```

    （1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。

    （2） 一个服务器生成的随机数，稍后用于生成"对话密钥"。

    （3） 确认使用的加密方法，比如RSA公钥加密。

    （4） 服务器证书。

```

3.客户端回应
```	

    （1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。

    （2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。

    （3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。

```
上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称"pre-master key"。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把"会话密钥"。

4.服务器的最后回应
```

    （1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。

    （2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。

```
<br>
<br>


###  2.OAuth
```
    （1） Third-party application：第三方应用程序，本文中又称"客户端"（client），即上一节例子中的"云冲印"。

    （2）HTTP service：HTTP服务提供商，本文中简称"服务提供商"，即上一节例子中的Google。

    （3）Resource Owner：资源所有者，本文中又称"用户"（user）。

    （4）User Agent：用户代理，本文中就是指浏览器。

    （5）Authorization server：认证服务器，即服务提供商专门用来处理认证的服务器。

    （6）Resource server：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。

```
![OAuth2.0授权过程][1]
```
    （A）用户打开客户端以后，客户端要求用户给予授权。

    （B）用户同意给予客户端授权。

    （C）客户端使用上一步获得的授权，向认证服务器申请令牌。

    （D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。

    （E）客户端使用令牌，向资源服务器申请获取资源。

    （F）资源服务器确认令牌无误，同意向客户端开放资源。

```
客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0定义了四种授权方式。
```
    授权码模式（authorization code）
    简化模式（implicit）
    密码模式（resource owner password credentials）
    客户端模式（client credentials）
```

1.授权码模式
![授权码模式][2]
```
    （A）用户访问客户端，后者将前者导向认证服务器。

    （B）用户选择是否给予客户端授权。

    （C）假设用户给予授权，认证服务器将用户导向客户端事先指定的"重定向URI"（redirection URI），同时附上一个授权码。

    （D）客户端收到授权码，附上早先的"重定向URI"，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。

    （E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。
```
    
A步骤中，客户端申请认证的URI，包含以下参数：

   * response_type：表示授权类型，必选项，此处的值固定为"code"
   * client_id：表示客户端的ID，必选项
   * redirect_uri：表示重定向URI，可选项
   * scope：表示申请的权限范围，可选项
   * state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。
    
C步骤中，服务器回应客户端的URI，包含以下参数：

   * code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。
   * state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。
    
D步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数：

   * grant_type：表示使用的授权模式，必选项，此处的值固定为"authorization_code"。
   * code：表示上一步获得的授权码，必选项。
   * redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。
   * client_id：表示客户端ID，必选项。
    
    E步骤中，认证服务器发送的HTTP回复，包含以下参数：

   - access_token：表示访问令牌，必选项。
   - token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。
   - expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。
   - refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。
   - scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。



  [1]: http://image.beekka.com/blog/2014/bg2014051203.png
  [2]: http://image.beekka.com/blog/2014/bg2014051204.png